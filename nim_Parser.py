# Generated from nim_Parser.g4 by ANTLR 4.7.1
# encoding: utf-8
from antlr4 import *
from io import StringIO
from typing.io import TextIO
import sys

def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3s")
<<<<<<< HEAD
        buf.write("\u03cf\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
=======
        buf.write("\u03ec\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
>>>>>>> rev1
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4\23\t\23")
        buf.write("\4\24\t\24\4\25\t\25\4\26\t\26\4\27\t\27\4\30\t\30\4\31")
        buf.write("\t\31\4\32\t\32\4\33\t\33\4\34\t\34\4\35\t\35\4\36\t\36")
        buf.write("\4\37\t\37\4 \t \4!\t!\4\"\t\"\4#\t#\4$\t$\4%\t%\4&\t")
        buf.write("&\4\'\t\'\4(\t(\4)\t)\4*\t*\4+\t+\4,\t,\4-\t-\4.\t.\4")
        buf.write("/\t/\4\60\t\60\4\61\t\61\4\62\t\62\4\63\t\63\4\64\t\64")
        buf.write("\4\65\t\65\4\66\t\66\4\67\t\67\48\t8\49\t9\4:\t:\4;\t")
        buf.write(";\4<\t<\4=\t=\4>\t>\4?\t?\4@\t@\4A\tA\4B\tB\4C\tC\4D\t")
        buf.write("D\4E\tE\4F\tF\4G\tG\4H\tH\4I\tI\4J\tJ\4K\tK\4L\tL\4M\t")
        buf.write("M\4N\tN\4O\tO\4P\tP\4Q\tQ\4R\tR\4S\tS\3\2\3\2\3\3\5\3")
        buf.write("\u00aa\n\3\3\4\3\4\3\5\3\5\3\6\3\6\3\7\3\7\3\b\3\b\3\t")
        buf.write("\3\t\3\t\3\t\5\t\u00ba\n\t\3\n\3\n\3\13\3\13\3\f\3\f\3")
        buf.write("\r\3\r\3\r\3\r\5\r\u00c6\n\r\3\16\3\16\3\17\3\17\3\20")
        buf.write("\3\20\3\21\3\21\3\22\3\22\3\22\3\22\3\22\3\22\3\22\3\22")
        buf.write("\3\22\3\22\3\22\5\22\u00db\n\22\3\23\3\23\3\24\3\24\3")
        buf.write("\24\7\24\u00e2\n\24\f\24\16\24\u00e5\13\24\3\25\3\25\3")
        buf.write("\25\7\25\u00ea\n\25\f\25\16\25\u00ed\13\25\3\26\3\26\3")
        buf.write("\26\7\26\u00f2\n\26\f\26\16\26\u00f5\13\26\3\27\3\27\3")
        buf.write("\27\7\27\u00fa\n\27\f\27\16\27\u00fd\13\27\3\30\3\30\3")
        buf.write("\30\7\30\u0102\n\30\f\30\16\30\u0105\13\30\3\31\3\31\3")
        buf.write("\31\7\31\u010a\n\31\f\31\16\31\u010d\13\31\3\32\3\32\3")
        buf.write("\32\7\32\u0112\n\32\f\32\16\32\u0115\13\32\3\33\3\33\3")
        buf.write("\33\7\33\u011a\n\33\f\33\16\33\u011d\13\33\3\34\3\34\3")
        buf.write("\34\7\34\u0122\n\34\f\34\16\34\u0125\13\34\3\35\3\35\3")
        buf.write("\35\7\35\u012a\n\35\f\35\16\35\u012d\13\35\3\36\3\36\3")
        buf.write("\37\3\37\3 \3 \3 \3 \3 \3 \5 \u0139\n \3!\3!\3!\3!\3!")
        buf.write("\3!\3!\3!\7!\u0143\n!\f!\16!\u0146\13!\5!\u0148\n!\3\"")
        buf.write("\3\"\5\"\u014c\n\"\3\"\3\"\3\"\3\"\5\"\u0152\n\"\5\"\u0154")
        buf.write("\n\"\3#\3#\3#\3#\7#\u015a\n#\f#\16#\u015d\13#\3#\3#\3")
        buf.write("$\3$\3$\3$\7$\u0165\n$\f$\16$\u0168\13$\3$\3$\3%\3%\3")
        buf.write("%\3%\3%\5%\u0171\n%\3&\3&\3&\3&\5&\u0177\n&\3\'\3\'\3")
        buf.write("\'\3\'\7\'\u017d\n\'\f\'\16\'\u0180\13\'\3\'\3\'\3\'\3")
<<<<<<< HEAD
        buf.write("\'\3\'\5\'\u0187\n\'\3\'\3\'\3\'\5\'\u018c\n\'\3\'\3\'")
        buf.write("\3\'\5\'\u0191\n\'\7\'\u0193\n\'\f\'\16\'\u0196\13\'\3")
        buf.write("\'\3\'\3\'\3\'\5\'\u019c\n\'\3(\3(\3(\3(\7(\u01a2\n(\f")
        buf.write("(\16(\u01a5\13(\3(\3(\7(\u01a9\n(\f(\16(\u01ac\13(\3(")
        buf.write("\6(\u01af\n(\r(\16(\u01b0\5(\u01b3\n(\5(\u01b5\n(\3)\3")
        buf.write(")\3)\3)\5)\u01bb\n)\3)\3)\3)\3)\5)\u01c1\n)\3)\3)\6)\u01c5")
        buf.write("\n)\r)\16)\u01c6\3)\3)\6)\u01cb\n)\r)\16)\u01cc\5)\u01cf")
        buf.write("\n)\5)\u01d1\n)\3*\3*\3*\3*\3*\5*\u01d8\n*\3+\3+\3+\3")
        buf.write("+\7+\u01de\n+\f+\16+\u01e1\13+\3,\3,\3,\3,\3-\3-\5-\u01e9")
        buf.write("\n-\3-\3-\3-\3.\3.\3/\3/\5/\u01f2\n/\3\60\3\60\5\60\u01f6")
        buf.write("\n\60\3\60\3\60\3\60\5\60\u01fb\n\60\3\60\3\60\3\60\3")
        buf.write("\60\3\60\3\60\5\60\u0203\n\60\7\60\u0205\n\60\f\60\16")
        buf.write("\60\u0208\13\60\3\60\3\60\3\60\3\60\3\60\3\60\3\60\5\60")
        buf.write("\u0211\n\60\3\61\3\61\5\61\u0215\n\61\3\61\3\61\3\61\3")
        buf.write("\61\3\61\3\61\5\61\u021d\n\61\3\62\3\62\3\62\5\62\u0222")
        buf.write("\n\62\3\62\3\62\3\62\3\62\3\62\5\62\u0229\n\62\3\63\3")
        buf.write("\63\3\63\3\64\3\64\5\64\u0230\n\64\3\64\3\64\3\65\3\65")
        buf.write("\5\65\u0236\n\65\3\65\3\65\3\65\5\65\u023b\n\65\7\65\u023d")
        buf.write("\n\65\f\65\16\65\u0240\13\65\3\66\3\66\3\66\3\66\3\66")
        buf.write("\3\66\6\66\u0248\n\66\r\66\16\66\u0249\3\66\3\66\3\66")
        buf.write("\3\66\5\66\u0250\n\66\5\66\u0252\n\66\3\67\6\67\u0255")
        buf.write("\n\67\r\67\16\67\u0256\3\67\3\67\3\67\3\67\3\67\6\67\u025e")
        buf.write("\n\67\r\67\16\67\u025f\3\67\3\67\3\67\3\67\5\67\u0266")
        buf.write("\n\67\5\67\u0268\n\67\5\67\u026a\n\67\38\38\38\58\u026f")
        buf.write("\n8\38\38\38\38\38\58\u0276\n8\39\39\59\u027a\n9\39\3")
        buf.write("9\3:\3:\5:\u0280\n:\3:\3:\3;\3;\3;\3;\7;\u0288\n;\f;\16")
        buf.write(";\u028b\13;\3;\3;\3;\3;\3;\3;\6;\u0293\n;\r;\16;\u0294")
        buf.write("\3;\3;\3;\3;\5;\u029b\n;\5;\u029d\n;\3<\3<\5<\u02a1\n")
        buf.write("<\3<\3<\3<\5<\u02a6\n<\3<\3<\3<\6<\u02ab\n<\r<\16<\u02ac")
        buf.write("\3<\5<\u02b0\n<\3<\3<\3<\6<\u02b5\n<\r<\16<\u02b6\3<\5")
        buf.write("<\u02ba\n<\5<\u02bc\n<\7<\u02be\n<\f<\16<\u02c1\13<\3")
        buf.write("<\3<\3<\3<\6<\u02c7\n<\r<\16<\u02c8\3<\5<\u02cc\n<\3<")
        buf.write("\3<\3<\6<\u02d1\n<\r<\16<\u02d2\3<\5<\u02d6\n<\5<\u02d8")
        buf.write("\n<\5<\u02da\n<\3=\3=\5=\u02de\n=\3=\3=\3=\3=\3=\3=\5")
        buf.write("=\u02e6\n=\3>\3>\5>\u02ea\n>\3>\3>\3>\3>\3>\3>\5>\u02f2")
        buf.write("\n>\3?\3?\3@\3@\3@\3@\5@\u02fa\n@\3A\3A\3A\3A\5A\u0300")
        buf.write("\nA\3A\3A\3B\3B\3B\7B\u0307\nB\fB\16B\u030a\13B\3C\3C")
        buf.write("\3D\6D\u030f\nD\rD\16D\u0310\3D\3D\6D\u0315\nD\rD\16D")
        buf.write("\u0316\3D\3D\5D\u031b\nD\3E\6E\u031e\nE\rE\16E\u031f\3")
        buf.write("E\3E\6E\u0324\nE\rE\16E\u0325\3E\3E\5E\u032a\nE\3F\3F")
        buf.write("\5F\u032e\nF\3G\3G\3G\3G\7G\u0334\nG\fG\16G\u0337\13G")
        buf.write("\3G\3G\3G\3G\3G\5G\u033e\nG\3G\3G\5G\u0342\nG\3G\3G\3")
        buf.write("G\5G\u0347\nG\3G\3G\5G\u034b\nG\5G\u034d\nG\3H\3H\3H\7")
        buf.write("H\u0352\nH\fH\16H\u0355\13H\3H\3H\5H\u0359\nH\3H\3H\3")
        buf.write("H\3H\3H\3H\5H\u0361\nH\3I\3I\5I\u0365\nI\3I\3I\3J\3J\3")
        buf.write("J\7J\u036c\nJ\fJ\16J\u036f\13J\3J\5J\u0372\nJ\3J\3J\3")
        buf.write("J\3J\3J\3J\5J\u037a\nJ\5J\u037c\nJ\3J\3J\3J\3J\5J\u0382")
        buf.write("\nJ\3J\3J\3J\5J\u0387\nJ\5J\u0389\nJ\3K\3K\5K\u038d\n")
        buf.write("K\3L\3L\3L\5L\u0392\nL\3M\3M\3M\3M\3M\3M\3M\3M\3M\3M\3")
        buf.write("M\3M\5M\u03a0\nM\3N\3N\3N\3O\3O\3O\3O\5O\u03a9\nO\3O\5")
        buf.write("O\u03ac\nO\3P\3P\3P\5P\u03b1\nP\3P\7P\u03b4\nP\fP\16P")
        buf.write("\u03b7\13P\3P\3P\3P\5P\u03bc\nP\3Q\3Q\5Q\u03c0\nQ\3Q\7")
        buf.write("Q\u03c3\nQ\fQ\16Q\u03c6\13Q\3R\6R\u03c9\nR\rR\16R\u03ca")
        buf.write("\3S\3S\3S\2\2T\2\4\6\b\n\f\16\20\22\24\26\30\32\34\36")
        buf.write(" \"$&(*,.\60\62\64\668:<>@BDFHJLNPRTVXZ\\^`bdfhjlnprt")
        buf.write("vxz|~\u0080\u0082\u0084\u0086\u0088\u008a\u008c\u008e")
        buf.write("\u0090\u0092\u0094\u0096\u0098\u009a\u009c\u009e\u00a0")
        buf.write("\u00a2\u00a4\2\13\3\3mm\5\2\'\'++KK\t\2\')\678<<>>DDO")
        buf.write("OUU\4\2\27\27\35\35\4\2\30\32!!\5\2QQYbdj\3\2kl\5\2++")
        buf.write("AAPP\3\2\'(\2\u0425\2\u00a6\3\2\2\2\4\u00a9\3\2\2\2\6")
        buf.write("\u00ab\3\2\2\2\b\u00ad\3\2\2\2\n\u00af\3\2\2\2\f\u00b1")
        buf.write("\3\2\2\2\16\u00b3\3\2\2\2\20\u00b9\3\2\2\2\22\u00bb\3")
        buf.write("\2\2\2\24\u00bd\3\2\2\2\26\u00bf\3\2\2\2\30\u00c5\3\2")
        buf.write("\2\2\32\u00c7\3\2\2\2\34\u00c9\3\2\2\2\36\u00cb\3\2\2")
        buf.write("\2 \u00cd\3\2\2\2\"\u00da\3\2\2\2$\u00dc\3\2\2\2&\u00de")
        buf.write("\3\2\2\2(\u00e6\3\2\2\2*\u00ee\3\2\2\2,\u00f6\3\2\2\2")
        buf.write(".\u00fe\3\2\2\2\60\u0106\3\2\2\2\62\u010e\3\2\2\2\64\u0116")
        buf.write("\3\2\2\2\66\u011e\3\2\2\28\u0126\3\2\2\2:\u012e\3\2\2")
        buf.write("\2<\u0130\3\2\2\2>\u0138\3\2\2\2@\u0147\3\2\2\2B\u014b")
        buf.write("\3\2\2\2D\u0155\3\2\2\2F\u0160\3\2\2\2H\u0170\3\2\2\2")
        buf.write("J\u0176\3\2\2\2L\u019b\3\2\2\2N\u01b4\3\2\2\2P\u01d0\3")
        buf.write("\2\2\2R\u01d7\3\2\2\2T\u01d9\3\2\2\2V\u01e2\3\2\2\2X\u01e6")
        buf.write("\3\2\2\2Z\u01ed\3\2\2\2\\\u01f1\3\2\2\2^\u01f5\3\2\2\2")
        buf.write("`\u0214\3\2\2\2b\u021e\3\2\2\2d\u022a\3\2\2\2f\u022d\3")
        buf.write("\2\2\2h\u0235\3\2\2\2j\u0241\3\2\2\2l\u0254\3\2\2\2n\u026b")
        buf.write("\3\2\2\2p\u0277\3\2\2\2r\u027d\3\2\2\2t\u0283\3\2\2\2")
        buf.write("v\u02a0\3\2\2\2x\u02dd\3\2\2\2z\u02e7\3\2\2\2|\u02f3\3")
        buf.write("\2\2\2~\u02f9\3\2\2\2\u0080\u02fb\3\2\2\2\u0082\u0303")
        buf.write("\3\2\2\2\u0084\u030b\3\2\2\2\u0086\u031a\3\2\2\2\u0088")
        buf.write("\u0329\3\2\2\2\u008a\u032b\3\2\2\2\u008c\u032f\3\2\2\2")
        buf.write("\u008e\u034e\3\2\2\2\u0090\u0362\3\2\2\2\u0092\u0368\3")
        buf.write("\2\2\2\u0094\u038c\3\2\2\2\u0096\u0391\3\2\2\2\u0098\u039f")
        buf.write("\3\2\2\2\u009a\u03a1\3\2\2\2\u009c\u03a4\3\2\2\2\u009e")
        buf.write("\u03bb\3\2\2\2\u00a0\u03bd\3\2\2\2\u00a2\u03c8\3\2\2\2")
        buf.write("\u00a4\u03cc\3\2\2\2\u00a6\u00a7\7q\2\2\u00a7\3\3\2\2")
        buf.write("\2\u00a8\u00aa\5\2\2\2\u00a9\u00a8\3\2\2\2\u00a9\u00aa")
        buf.write("\3\2\2\2\u00aa\5\3\2\2\2\u00ab\u00ac\t\2\2\2\u00ac\7\3")
        buf.write("\2\2\2\u00ad\u00ae\t\3\2\2\u00ae\t\3\2\2\2\u00af\u00b0")
        buf.write("\t\4\2\2\u00b0\13\3\2\2\2\u00b1\u00b2\7\34\2\2\u00b2\r")
        buf.write("\3\2\2\2\u00b3\u00b4\t\5\2\2\u00b4\17\3\2\2\2\u00b5\u00ba")
        buf.write("\7\36\2\2\u00b6\u00b7\7\25\2\2\u00b7\u00ba\7\25\2\2\u00b8")
        buf.write("\u00ba\7\25\2\2\u00b9\u00b5\3\2\2\2\u00b9\u00b6\3\2\2")
        buf.write("\2\u00b9\u00b8\3\2\2\2\u00ba\21\3\2\2\2\u00bb\u00bc\7")
        buf.write("\37\2\2\u00bc\23\3\2\2\2\u00bd\u00be\7 \2\2\u00be\25\3")
        buf.write("\2\2\2\u00bf\u00c0\t\6\2\2\u00c0\27\3\2\2\2\u00c1\u00c6")
        buf.write("\7\"\2\2\u00c2\u00c3\7\26\2\2\u00c3\u00c6\7\26\2\2\u00c4")
        buf.write("\u00c6\7\26\2\2\u00c5\u00c1\3\2\2\2\u00c5\u00c2\3\2\2")
        buf.write("\2\u00c5\u00c4\3\2\2\2\u00c6\31\3\2\2\2\u00c7\u00c8\7")
        buf.write("#\2\2\u00c8\33\3\2\2\2\u00c9\u00ca\7$\2\2\u00ca\35\3\2")
        buf.write("\2\2\u00cb\u00cc\7%\2\2\u00cc\37\3\2\2\2\u00cd\u00ce\7")
        buf.write("&\2\2\u00ce!\3\2\2\2\u00cf\u00db\5\f\7\2\u00d0\u00db\5")
        buf.write("\16\b\2\u00d1\u00db\5\20\t\2\u00d2\u00db\5\22\n\2\u00d3")
        buf.write("\u00db\5\24\13\2\u00d4\u00db\5\26\f\2\u00d5\u00db\5\30")
        buf.write("\r\2\u00d6\u00db\5\32\16\2\u00d7\u00db\5\34\17\2\u00d8")
        buf.write("\u00db\5\36\20\2\u00d9\u00db\5 \21\2\u00da\u00cf\3\2\2")
        buf.write("\2\u00da\u00d0\3\2\2\2\u00da\u00d1\3\2\2\2\u00da\u00d2")
        buf.write("\3\2\2\2\u00da\u00d3\3\2\2\2\u00da\u00d4\3\2\2\2\u00da")
        buf.write("\u00d5\3\2\2\2\u00da\u00d6\3\2\2\2\u00da\u00d7\3\2\2\2")
        buf.write("\u00da\u00d8\3\2\2\2\u00da\u00d9\3\2\2\2\u00db#\3\2\2")
        buf.write("\2\u00dc\u00dd\5\"\22\2\u00dd%\3\2\2\2\u00de\u00e3\5(")
        buf.write("\25\2\u00df\u00e0\7\35\2\2\u00e0\u00e2\5(\25\2\u00e1\u00df")
        buf.write("\3\2\2\2\u00e2\u00e5\3\2\2\2\u00e3\u00e1\3\2\2\2\u00e3")
        buf.write("\u00e4\3\2\2\2\u00e4\'\3\2\2\2\u00e5\u00e3\3\2\2\2\u00e6")
        buf.write("\u00eb\5*\26\2\u00e7\u00e8\7\36\2\2\u00e8\u00ea\5*\26")
        buf.write("\2\u00e9\u00e7\3\2\2\2\u00ea\u00ed\3\2\2\2\u00eb\u00e9")
        buf.write("\3\2\2\2\u00eb\u00ec\3\2\2\2\u00ec)\3\2\2\2\u00ed\u00eb")
        buf.write("\3\2\2\2\u00ee\u00f3\5,\27\2\u00ef\u00f0\7\37\2\2\u00f0")
        buf.write("\u00f2\5,\27\2\u00f1\u00ef\3\2\2\2\u00f2\u00f5\3\2\2\2")
        buf.write("\u00f3\u00f1\3\2\2\2\u00f3\u00f4\3\2\2\2\u00f4+\3\2\2")
        buf.write("\2\u00f5\u00f3\3\2\2\2\u00f6\u00fb\5.\30\2\u00f7\u00f8")
        buf.write("\7 \2\2\u00f8\u00fa\5.\30\2\u00f9\u00f7\3\2\2\2\u00fa")
        buf.write("\u00fd\3\2\2\2\u00fb\u00f9\3\2\2\2\u00fb\u00fc\3\2\2\2")
        buf.write("\u00fc-\3\2\2\2\u00fd\u00fb\3\2\2\2\u00fe\u0103\5\60\31")
        buf.write("\2\u00ff\u0100\7!\2\2\u0100\u0102\5\60\31\2\u0101\u00ff")
        buf.write("\3\2\2\2\u0102\u0105\3\2\2\2\u0103\u0101\3\2\2\2\u0103")
        buf.write("\u0104\3\2\2\2\u0104/\3\2\2\2\u0105\u0103\3\2\2\2\u0106")
        buf.write("\u010b\5\62\32\2\u0107\u0108\7\"\2\2\u0108\u010a\5\62")
        buf.write("\32\2\u0109\u0107\3\2\2\2\u010a\u010d\3\2\2\2\u010b\u0109")
        buf.write("\3\2\2\2\u010b\u010c\3\2\2\2\u010c\61\3\2\2\2\u010d\u010b")
        buf.write("\3\2\2\2\u010e\u0113\5\64\33\2\u010f\u0110\7#\2\2\u0110")
        buf.write("\u0112\5\64\33\2\u0111\u010f\3\2\2\2\u0112\u0115\3\2\2")
        buf.write("\2\u0113\u0111\3\2\2\2\u0113\u0114\3\2\2\2\u0114\63\3")
        buf.write("\2\2\2\u0115\u0113\3\2\2\2\u0116\u011b\5\66\34\2\u0117")
        buf.write("\u0118\7$\2\2\u0118\u011a\5\66\34\2\u0119\u0117\3\2\2")
        buf.write("\2\u011a\u011d\3\2\2\2\u011b\u0119\3\2\2\2\u011b\u011c")
        buf.write("\3\2\2\2\u011c\65\3\2\2\2\u011d\u011b\3\2\2\2\u011e\u0123")
        buf.write("\58\35\2\u011f\u0120\7%\2\2\u0120\u0122\58\35\2\u0121")
        buf.write("\u011f\3\2\2\2\u0122\u0125\3\2\2\2\u0123\u0121\3\2\2\2")
        buf.write("\u0123\u0124\3\2\2\2\u0124\67\3\2\2\2\u0125\u0123\3\2")
        buf.write("\2\2\u0126\u012b\5N(\2\u0127\u0128\7&\2\2\u0128\u012a")
        buf.write("\5N(\2\u0129\u0127\3\2\2\2\u012a\u012d\3\2\2\2\u012b\u0129")
        buf.write("\3\2\2\2\u012b\u012c\3\2\2\2\u012c9\3\2\2\2\u012d\u012b")
        buf.write("\3\2\2\2\u012e\u012f\t\7\2\2\u012f;\3\2\2\2\u0130\u0131")
        buf.write("\t\b\2\2\u0131=\3\2\2\2\u0132\u0139\5@!\2\u0133\u0134")
        buf.write("\7W\2\2\u0134\u0135\5@!\2\u0135\u0136\7W\2\2\u0136\u0139")
        buf.write("\3\2\2\2\u0137\u0139\7X\2\2\u0138\u0132\3\2\2\2\u0138")
        buf.write("\u0133\3\2\2\2\u0138\u0137\3\2\2\2\u0139?\3\2\2\2\u013a")
        buf.write("\u0148\7X\2\2\u013b\u0148\5:\36\2\u013c\u0143\5\"\22\2")
        buf.write("\u013d\u0143\7\n\2\2\u013e\u0143\7\13\2\2\u013f\u0143")
        buf.write("\7\16\2\2\u0140\u0143\7\17\2\2\u0141\u0143\7\27\2\2\u0142")
        buf.write("\u013c\3\2\2\2\u0142\u013d\3\2\2\2\u0142\u013e\3\2\2\2")
        buf.write("\u0142\u013f\3\2\2\2\u0142\u0140\3\2\2\2\u0142\u0141\3")
        buf.write("\2\2\2\u0143\u0146\3\2\2\2\u0144\u0142\3\2\2\2\u0144\u0145")
        buf.write("\3\2\2\2\u0145\u0148\3\2\2\2\u0146\u0144\3\2\2\2\u0147")
        buf.write("\u013a\3\2\2\2\u0147\u013b\3\2\2\2\u0147\u0144\3\2\2\2")
        buf.write("\u0148A\3\2\2\2\u0149\u014c\5~@\2\u014a\u014c\5&\24\2")
        buf.write("\u014b\u0149\3\2\2\2\u014b\u014a\3\2\2\2\u014c\u0153\3")
        buf.write("\2\2\2\u014d\u0154\7\25\2\2\u014e\u0151\7\27\2\2\u014f")
        buf.write("\u0152\5~@\2\u0150\u0152\5&\24\2\u0151\u014f\3\2\2\2\u0151")
        buf.write("\u0150\3\2\2\2\u0152\u0154\3\2\2\2\u0153\u014d\3\2\2\2")
        buf.write("\u0153\u014e\3\2\2\2\u0153\u0154\3\2\2\2\u0154C\3\2\2")
        buf.write("\2\u0155\u0156\7\16\2\2\u0156\u015b\5B\"\2\u0157\u0158")
        buf.write("\7\b\2\2\u0158\u015a\5B\"\2\u0159\u0157\3\2\2\2\u015a")
        buf.write("\u015d\3\2\2\2\u015b\u0159\3\2\2\2\u015b\u015c\3\2\2\2")
        buf.write("\u015c\u015e\3\2\2\2\u015d\u015b\3\2\2\2\u015e\u015f\7")
        buf.write("\17\2\2\u015fE\3\2\2\2\u0160\u0161\7\n\2\2\u0161\u0166")
        buf.write("\5B\"\2\u0162\u0163\7\b\2\2\u0163\u0165\5B\"\2\u0164\u0162")
        buf.write("\3\2\2\2\u0165\u0168\3\2\2\2\u0166\u0164\3\2\2\2\u0166")
        buf.write("\u0167\3\2\2\2\u0167\u0169\3\2\2\2\u0168\u0166\3\2\2\2")
        buf.write("\u0169\u016a\7\13\2\2\u016aG\3\2\2\2\u016b\u0171\5<\37")
        buf.write("\2\u016c\u0171\5> \2\u016d\u0171\5:\36\2\u016e\u0171\5")
        buf.write("R*\2\u016f\u0171\5D#\2\u0170\u016b\3\2\2\2\u0170\u016c")
        buf.write("\3\2\2\2\u0170\u016d\3\2\2\2\u0170\u016e\3\2\2\2\u0170")
        buf.write("\u016f\3\2\2\2\u0171I\3\2\2\2\u0172\u0177\5<\37\2\u0173")
        buf.write("\u0177\5> \2\u0174\u0177\5R*\2\u0175\u0177\5D#\2\u0176")
        buf.write("\u0172\3\2\2\2\u0176\u0173\3\2\2\2\u0176\u0174\3\2\2\2")
        buf.write("\u0176\u0175\3\2\2\2\u0177K\3\2\2\2\u0178\u0179\7\n\2")
        buf.write("\2\u0179\u017e\5B\"\2\u017a\u017b\7\b\2\2\u017b\u017d")
        buf.write("\5B\"\2\u017c\u017a\3\2\2\2\u017d\u0180\3\2\2\2\u017e")
        buf.write("\u017c\3\2\2\2\u017e\u017f\3\2\2\2\u017f\u0181\3\2\2\2")
        buf.write("\u0180\u017e\3\2\2\2\u0181\u0182\7\13\2\2\u0182\u019c")
        buf.write("\3\2\2\2\u0183\u0184\7\26\2\2\u0184\u0186\5> \2\u0185")
        buf.write("\u0187\5<\37\2\u0186\u0185\3\2\2\2\u0186\u0187\3\2\2\2")
        buf.write("\u0187\u019c\3\2\2\2\u0188\u018b\7\16\2\2\u0189\u018c")
        buf.write("\5&\24\2\u018a\u018c\5~@\2\u018b\u0189\3\2\2\2\u018b\u018a")
        buf.write("\3\2\2\2\u018c\u0194\3\2\2\2\u018d\u0190\7\b\2\2\u018e")
        buf.write("\u0191\5&\24\2\u018f\u0191\5~@\2\u0190\u018e\3\2\2\2\u0190")
        buf.write("\u018f\3\2\2\2\u0191\u0193\3\2\2\2\u0192\u018d\3\2\2\2")
        buf.write("\u0193\u0196\3\2\2\2\u0194\u0192\3\2\2\2\u0194\u0195\3")
        buf.write("\2\2\2\u0195\u0197\3\2\2\2\u0196\u0194\3\2\2\2\u0197\u0198")
        buf.write("\7\17\2\2\u0198\u019c\3\2\2\2\u0199\u019a\6\'\2\2\u019a")
        buf.write("\u019c\5~@\2\u019b\u0178\3\2\2\2\u019b\u0183\3\2\2\2\u019b")
        buf.write("\u0188\3\2\2\2\u019b\u0199\3\2\2\2\u019cM\3\2\2\2\u019d")
        buf.write("\u019e\5\b\5\2\u019e\u019f\5&\24\2\u019f\u01b5\3\2\2\2")
        buf.write("\u01a0\u01a2\5$\23\2\u01a1\u01a0\3\2\2\2\u01a2\u01a5\3")
        buf.write("\2\2\2\u01a3\u01a1\3\2\2\2\u01a3\u01a4\3\2\2\2\u01a4\u01b2")
        buf.write("\3\2\2\2\u01a5\u01a3\3\2\2\2\u01a6\u01aa\5H%\2\u01a7\u01a9")
        buf.write("\5L\'\2\u01a8\u01a7\3\2\2\2\u01a9\u01ac\3\2\2\2\u01aa")
        buf.write("\u01a8\3\2\2\2\u01aa\u01ab\3\2\2\2\u01ab\u01b3\3\2\2\2")
        buf.write("\u01ac\u01aa\3\2\2\2\u01ad\u01af\5L\'\2\u01ae\u01ad\3")
        buf.write("\2\2\2\u01af\u01b0\3\2\2\2\u01b0\u01ae\3\2\2\2\u01b0\u01b1")
        buf.write("\3\2\2\2\u01b1\u01b3\3\2\2\2\u01b2\u01a6\3\2\2\2\u01b2")
        buf.write("\u01ae\3\2\2\2\u01b3\u01b5\3\2\2\2\u01b4\u019d\3\2\2\2")
        buf.write("\u01b4\u01a3\3\2\2\2\u01b5O\3\2\2\2\u01b6\u01b7\6)\3\2")
        buf.write("\u01b7\u01ba\5\u0094K\2\u01b8\u01b9\7\t\2\2\u01b9\u01bb")
        buf.write("\5\u0094K\2\u01ba\u01b8\3\2\2\2\u01ba\u01bb\3\2\2\2\u01bb")
        buf.write("\u01d1\3\2\2\2\u01bc\u01d1\5~@\2\u01bd\u01c1\7\25\2\2")
        buf.write("\u01be\u01bf\7\27\2\2\u01bf\u01c1\5~@\2\u01c0\u01bd\3")
        buf.write("\2\2\2\u01c0\u01be\3\2\2\2\u01c1\u01ce\3\2\2\2\u01c2\u01c3")
        buf.write("\7\b\2\2\u01c3\u01c5\5B\"\2\u01c4\u01c2\3\2\2\2\u01c5")
        buf.write("\u01c6\3\2\2\2\u01c6\u01c4\3\2\2\2\u01c6\u01c7\3\2\2\2")
        buf.write("\u01c7\u01cf\3\2\2\2\u01c8\u01ca\7\t\2\2\u01c9\u01cb\5")
        buf.write("\u0094K\2\u01ca\u01c9\3\2\2\2\u01cb\u01cc\3\2\2\2\u01cc")
        buf.write("\u01ca\3\2\2\2\u01cc\u01cd\3\2\2\2\u01cd\u01cf\3\2\2\2")
        buf.write("\u01ce\u01c4\3\2\2\2\u01ce\u01c8\3\2\2\2\u01cf\u01d1\3")
        buf.write("\2\2\2\u01d0\u01b6\3\2\2\2\u01d0\u01bc\3\2\2\2\u01d0\u01c0")
        buf.write("\3\2\2\2\u01d1Q\3\2\2\2\u01d2\u01d3\7\n\2\2\u01d3\u01d4")
        buf.write("\5P)\2\u01d4\u01d5\7\13\2\2\u01d5\u01d8\3\2\2\2\u01d6")
        buf.write("\u01d8\5P)\2\u01d7\u01d2\3\2\2\2\u01d7\u01d6\3\2\2\2\u01d8")
        buf.write("S\3\2\2\2\u01d9\u01da\7G\2\2\u01da\u01df\7X\2\2\u01db")
        buf.write("\u01dc\7\b\2\2\u01dc\u01de\7X\2\2\u01dd\u01db\3\2\2\2")
        buf.write("\u01de\u01e1\3\2\2\2\u01df\u01dd\3\2\2\2\u01df\u01e0\3")
        buf.write("\2\2\2\u01e0U\3\2\2\2\u01e1\u01df\3\2\2\2\u01e2\u01e3")
        buf.write("\7H\2\2\u01e3\u01e4\7X\2\2\u01e4\u01e5\5T+\2\u01e5W\3")
        buf.write("\2\2\2\u01e6\u01e8\7O\2\2\u01e7\u01e9\5> \2\u01e8\u01e7")
        buf.write("\3\2\2\2\u01e8\u01e9\3\2\2\2\u01e9\u01ea\3\2\2\2\u01ea")
        buf.write("\u01eb\7\25\2\2\u01eb\u01ec\5\u00a0Q\2\u01ecY\3\2\2\2")
        buf.write("\u01ed\u01ee\5t;\2\u01ee[\3\2\2\2\u01ef\u01f2\5&\24\2")
        buf.write("\u01f0\u01f2\5~@\2\u01f1\u01ef\3\2\2\2\u01f1\u01f0\3\2")
        buf.write("\2\2\u01f2]\3\2\2\2\u01f3\u01f6\5&\24\2\u01f4\u01f6\5")
        buf.write("~@\2\u01f5\u01f3\3\2\2\2\u01f5\u01f4\3\2\2\2\u01f6\u0206")
        buf.write("\3\2\2\2\u01f7\u01fa\79\2\2\u01f8\u01fb\5~@\2\u01f9\u01fb")
        buf.write("\5&\24\2\u01fa\u01f8\3\2\2\2\u01fa\u01f9\3\2\2\2\u01fb")
        buf.write("\u01fc\3\2\2\2\u01fc\u0202\7\25\2\2\u01fd\u01fe\5\2\2")
        buf.write("\2\u01fe\u01ff\5\\/\2\u01ff\u0200\5\6\4\2\u0200\u0203")
        buf.write("\3\2\2\2\u0201\u0203\5\\/\2\u0202\u01fd\3\2\2\2\u0202")
        buf.write("\u0201\3\2\2\2\u0203\u0205\3\2\2\2\u0204\u01f7\3\2\2\2")
        buf.write("\u0205\u0208\3\2\2\2\u0206\u0204\3\2\2\2\u0206\u0207\3")
        buf.write("\2\2\2\u0207\u0209\3\2\2\2\u0208\u0206\3\2\2\2\u0209\u020a")
        buf.write("\7:\2\2\u020a\u0210\7\25\2\2\u020b\u020c\5\2\2\2\u020c")
        buf.write("\u020d\5,\27\2\u020d\u020e\5\6\4\2\u020e\u0211\3\2\2\2")
        buf.write("\u020f\u0211\5\\/\2\u0210\u020b\3\2\2\2\u0210\u020f\3")
        buf.write("\2\2\2\u0211_\3\2\2\2\u0212\u0215\5&\24\2\u0213\u0215")
        buf.write("\5~@\2\u0214\u0212\3\2\2\2\u0214\u0213\3\2\2\2\u0215\u0216")
        buf.write("\3\2\2\2\u0216\u021c\7\25\2\2\u0217\u0218\5\2\2\2\u0218")
        buf.write("\u0219\5^\60\2\u0219\u021a\5\6\4\2\u021a\u021d\3\2\2\2")
        buf.write("\u021b\u021d\5^\60\2\u021c\u0217\3\2\2\2\u021c\u021b\3")
        buf.write("\2\2\2\u021da\3\2\2\2\u021e\u0221\7\67\2\2\u021f\u0222")
        buf.write("\5&\24\2\u0220\u0222\5~@\2\u0221\u021f\3\2\2\2\u0221\u0220")
        buf.write("\3\2\2\2\u0222\u0228\3\2\2\2\u0223\u0224\5\2\2\2\u0224")
        buf.write("\u0225\5l\67\2\u0225\u0226\5\6\4\2\u0226\u0229\3\2\2\2")
        buf.write("\u0227\u0229\5l\67\2\u0228\u0223\3\2\2\2\u0228\u0227\3")
        buf.write("\2\2\2\u0229c\3\2\2\2\u022a\u022b\7D\2\2\u022b\u022c\5")
        buf.write("`\61\2\u022ce\3\2\2\2\u022d\u022f\78\2\2\u022e\u0230\7")
        buf.write("\32\2\2\u022f\u022e\3\2\2\2\u022f\u0230\3\2\2\2\u0230")
        buf.write("\u0231\3\2\2\2\u0231\u0232\5`\61\2\u0232g\3\2\2\2\u0233")
        buf.write("\u0236\5&\24\2\u0234\u0236\5~@\2\u0235\u0233\3\2\2\2\u0235")
        buf.write("\u0234\3\2\2\2\u0236\u023e\3\2\2\2\u0237\u023a\7\b\2\2")
        buf.write("\u0238\u023b\5&\24\2\u0239\u023b\5~@\2\u023a\u0238\3\2")
        buf.write("\2\2\u023a\u0239\3\2\2\2\u023b\u023d\3\2\2\2\u023c\u0237")
        buf.write("\3\2\2\2\u023d\u0240\3\2\2\2\u023e\u023c\3\2\2\2\u023e")
        buf.write("\u023f\3\2\2\2\u023fi\3\2\2\2\u0240\u023e\3\2\2\2\u0241")
        buf.write("\u0242\7\31\2\2\u0242\u0243\5h\65\2\u0243\u0251\7\25\2")
        buf.write("\2\u0244\u0247\5\2\2\2\u0245\u0248\5\u009cO\2\u0246\u0248")
        buf.write("\5\u00a0Q\2\u0247\u0245\3\2\2\2\u0247\u0246\3\2\2\2\u0248")
        buf.write("\u0249\3\2\2\2\u0249\u0247\3\2\2\2\u0249\u024a\3\2\2\2")
        buf.write("\u024a\u024b\3\2\2\2\u024b\u024c\5\6\4\2\u024c\u0252\3")
        buf.write("\2\2\2\u024d\u0250\5\u009cO\2\u024e\u0250\5\u00a0Q\2\u024f")
        buf.write("\u024d\3\2\2\2\u024f\u024e\3\2\2\2\u0250\u0252\3\2\2\2")
        buf.write("\u0251\u0244\3\2\2\2\u0251\u024f\3\2\2\2\u0252k\3\2\2")
        buf.write("\2\u0253\u0255\5j\66\2\u0254\u0253\3\2\2\2\u0255\u0256")
        buf.write("\3\2\2\2\u0256\u0254\3\2\2\2\u0256\u0257\3\2\2\2\u0257")
        buf.write("\u0269\3\2\2\2\u0258\u0259\7:\2\2\u0259\u0267\7\25\2\2")
        buf.write("\u025a\u025d\5\2\2\2\u025b\u025e\5\u009cO\2\u025c\u025e")
        buf.write("\5\u00a0Q\2\u025d\u025b\3\2\2\2\u025d\u025c\3\2\2\2\u025e")
        buf.write("\u025f\3\2\2\2\u025f\u025d\3\2\2\2\u025f\u0260\3\2\2\2")
        buf.write("\u0260\u0261\3\2\2\2\u0261\u0262\5\6\4\2\u0262\u0268\3")
        buf.write("\2\2\2\u0263\u0266\5\u009cO\2\u0264\u0266\5\u00a0Q\2\u0265")
        buf.write("\u0263\3\2\2\2\u0265\u0264\3\2\2\2\u0266\u0268\3\2\2\2")
        buf.write("\u0267\u025a\3\2\2\2\u0267\u0265\3\2\2\2\u0268\u026a\3")
        buf.write("\2\2\2\u0269\u0258\3\2\2\2\u0269\u026a\3\2\2\2\u026am")
        buf.write("\3\2\2\2\u026b\u026e\7\67\2\2\u026c\u026f\5&\24\2\u026d")
        buf.write("\u026f\5~@\2\u026e\u026c\3\2\2\2\u026e\u026d\3\2\2\2\u026f")
        buf.write("\u0275\3\2\2\2\u0270\u0271\5\2\2\2\u0271\u0272\5l\67\2")
        buf.write("\u0272\u0273\5\6\4\2\u0273\u0276\3\2\2\2\u0274\u0276\5")
        buf.write("l\67\2\u0275\u0270\3\2\2\2\u0275\u0274\3\2\2\2\u0276o")
        buf.write("\3\2\2\2\u0277\u0279\78\2\2\u0278\u027a\7\32\2\2\u0279")
        buf.write("\u0278\3\2\2\2\u0279\u027a\3\2\2\2\u027a\u027b\3\2\2\2")
        buf.write("\u027b\u027c\5x=\2\u027cq\3\2\2\2\u027d\u027f\7D\2\2\u027e")
        buf.write("\u0280\7\32\2\2\u027f\u027e\3\2\2\2\u027f\u0280\3\2\2")
        buf.write("\2\u0280\u0281\3\2\2\2\u0281\u0282\5x=\2\u0282s\3\2\2")
        buf.write("\2\u0283\u0284\7>\2\2\u0284\u0289\7X\2\2\u0285\u0286\7")
        buf.write("\b\2\2\u0286\u0288\7X\2\2\u0287\u0285\3\2\2\2\u0288\u028b")
        buf.write("\3\2\2\2\u0289\u0287\3\2\2\2\u0289\u028a\3\2\2\2\u028a")
        buf.write("\u028c\3\2\2\2\u028b\u0289\3\2\2\2\u028c\u028d\7\30\2")
        buf.write("\2\u028d\u028e\5&\24\2\u028e\u029c\7\25\2\2\u028f\u0292")
        buf.write("\5\2\2\2\u0290\u0293\5\u00a0Q\2\u0291\u0293\5\u009cO\2")
        buf.write("\u0292\u0290\3\2\2\2\u0292\u0291\3\2\2\2\u0293\u0294\3")
        buf.write("\2\2\2\u0294\u0292\3\2\2\2\u0294\u0295\3\2\2\2\u0295\u0296")
        buf.write("\3\2\2\2\u0296\u0297\5\6\4\2\u0297\u029d\3\2\2\2\u0298")
        buf.write("\u029b\5\u00a0Q\2\u0299\u029b\5\u009cO\2\u029a\u0298\3")
        buf.write("\2\2\2\u029a\u0299\3\2\2\2\u029b\u029d\3\2\2\2\u029c\u028f")
        buf.write("\3\2\2\2\u029c\u029a\3\2\2\2\u029du\3\2\2\2\u029e\u02a1")
        buf.write("\5\u009cO\2\u029f\u02a1\5\u009eP\2\u02a0\u029e\3\2\2\2")
        buf.write("\u02a0\u029f\3\2\2\2\u02a1\u02bf\3\2\2\2\u02a2\u02a5\7")
        buf.write("9\2\2\u02a3\u02a6\5&\24\2\u02a4\u02a6\5~@\2\u02a5\u02a3")
        buf.write("\3\2\2\2\u02a5\u02a4\3\2\2\2\u02a6\u02a7\3\2\2\2\u02a7")
        buf.write("\u02bb\7\25\2\2\u02a8\u02af\5\2\2\2\u02a9\u02ab\5\u009c")
        buf.write("O\2\u02aa\u02a9\3\2\2\2\u02ab\u02ac\3\2\2\2\u02ac\u02aa")
        buf.write("\3\2\2\2\u02ac\u02ad\3\2\2\2\u02ad\u02b0\3\2\2\2\u02ae")
        buf.write("\u02b0\5\u009eP\2\u02af\u02aa\3\2\2\2\u02af\u02ae\3\2")
        buf.write("\2\2\u02b0\u02b1\3\2\2\2\u02b1\u02b2\5\6\4\2\u02b2\u02bc")
        buf.write("\3\2\2\2\u02b3\u02b5\5\u009cO\2\u02b4\u02b3\3\2\2\2\u02b5")
        buf.write("\u02b6\3\2\2\2\u02b6\u02b4\3\2\2\2\u02b6\u02b7\3\2\2\2")
        buf.write("\u02b7\u02ba\3\2\2\2\u02b8\u02ba\5\u009eP\2\u02b9\u02b4")
        buf.write("\3\2\2\2\u02b9\u02b8\3\2\2\2\u02ba\u02bc\3\2\2\2\u02bb")
        buf.write("\u02a8\3\2\2\2\u02bb\u02b9\3\2\2\2\u02bc\u02be\3\2\2\2")
        buf.write("\u02bd\u02a2\3\2\2\2\u02be\u02c1\3\2\2\2\u02bf\u02bd\3")
        buf.write("\2\2\2\u02bf\u02c0\3\2\2\2\u02c0\u02d9\3\2\2\2\u02c1\u02bf")
        buf.write("\3\2\2\2\u02c2\u02c3\7:\2\2\u02c3\u02d7\7\25\2\2\u02c4")
        buf.write("\u02cb\5\2\2\2\u02c5\u02c7\5\u009cO\2\u02c6\u02c5\3\2")
        buf.write("\2\2\u02c7\u02c8\3\2\2\2\u02c8\u02c6\3\2\2\2\u02c8\u02c9")
        buf.write("\3\2\2\2\u02c9\u02cc\3\2\2\2\u02ca\u02cc\5\u009eP\2\u02cb")
        buf.write("\u02c6\3\2\2\2\u02cb\u02ca\3\2\2\2\u02cc\u02cd\3\2\2\2")
        buf.write("\u02cd\u02ce\5\6\4\2\u02ce\u02d8\3\2\2\2\u02cf\u02d1\5")
        buf.write("\u009cO\2\u02d0\u02cf\3\2\2\2\u02d1\u02d2\3\2\2\2\u02d2")
        buf.write("\u02d0\3\2\2\2\u02d2\u02d3\3\2\2\2\u02d3\u02d6\3\2\2\2")
        buf.write("\u02d4\u02d6\5\u009eP\2\u02d5\u02d0\3\2\2\2\u02d5\u02d4")
        buf.write("\3\2\2\2\u02d6\u02d8\3\2\2\2\u02d7\u02c4\3\2\2\2\u02d7")
        buf.write("\u02d5\3\2\2\2\u02d8\u02da\3\2\2\2\u02d9\u02c2\3\2\2\2")
        buf.write("\u02d9\u02da\3\2\2\2\u02daw\3\2\2\2\u02db\u02de\5&\24")
        buf.write("\2\u02dc\u02de\5~@\2\u02dd\u02db\3\2\2\2\u02dd\u02dc\3")
        buf.write("\2\2\2\u02de\u02df\3\2\2\2\u02df\u02e5\7\25\2\2\u02e0")
        buf.write("\u02e1\5\2\2\2\u02e1\u02e2\5v<\2\u02e2\u02e3\5\6\4\2\u02e3")
        buf.write("\u02e6\3\2\2\2\u02e4\u02e6\5v<\2\u02e5\u02e0\3\2\2\2\u02e5")
        buf.write("\u02e4\3\2\2\2\u02e6y\3\2\2\2\u02e7\u02e9\7O\2\2\u02e8")
        buf.write("\u02ea\5> \2\u02e9\u02e8\3\2\2\2\u02e9\u02ea\3\2\2\2\u02ea")
        buf.write("\u02eb\3\2\2\2\u02eb\u02f1\7\25\2\2\u02ec\u02ed\5\2\2")
        buf.write("\2\u02ed\u02ee\5\u00a0Q\2\u02ee\u02ef\5\6\4\2\u02ef\u02f2")
        buf.write("\3\2\2\2\u02f0\u02f2\5\u00a0Q\2\u02f1\u02ec\3\2\2\2\u02f1")
        buf.write("\u02f0\3\2\2\2\u02f2{\3\2\2\2\u02f3\u02f4\5\u0080A\2\u02f4")
        buf.write("}\3\2\2\2\u02f5\u02fa\5X-\2\u02f6\u02fa\5Z.\2\u02f7\u02fa")
        buf.write("\5f\64\2\u02f8\u02fa\5d\63\2\u02f9\u02f5\3\2\2\2\u02f9")
        buf.write("\u02f6\3\2\2\2\u02f9\u02f7\3\2\2\2\u02f9\u02f8\3\2\2\2")
        buf.write("\u02fa\177\3\2\2\2\u02fb\u02fc\7\f\2\2\u02fc\u02fd\7\26")
        buf.write("\2\2\u02fd\u02ff\7X\2\2\u02fe\u0300\7\26\2\2\u02ff\u02fe")
        buf.write("\3\2\2\2\u02ff\u0300\3\2\2\2\u0300\u0301\3\2\2\2\u0301")
        buf.write("\u0302\7\r\2\2\u0302\u0081\3\2\2\2\u0303\u0308\5R*\2\u0304")
        buf.write("\u0305\7\25\2\2\u0305\u0307\5\u009eP\2\u0306\u0304\3\2")
        buf.write("\2\2\u0307\u030a\3\2\2\2\u0308\u0306\3\2\2\2\u0308\u0309")
        buf.write("\3\2\2\2\u0309\u0083\3\2\2\2\u030a\u0308\3\2\2\2\u030b")
        buf.write("\u030c\7\f\2\2\u030c\u0085\3\2\2\2\u030d\u030f\5\u0090")
        buf.write("I\2\u030e\u030d\3\2\2\2\u030f\u0310\3\2\2\2\u0310\u030e")
        buf.write("\3\2\2\2\u0310\u0311\3\2\2\2\u0311\u031b\3\2\2\2\u0312")
        buf.write("\u0314\5\2\2\2\u0313\u0315\5\u0090I\2\u0314\u0313\3\2")
        buf.write("\2\2\u0315\u0316\3\2\2\2\u0316\u0314\3\2\2\2\u0316\u0317")
        buf.write("\3\2\2\2\u0317\u0318\3\2\2\2\u0318\u0319\5\6\4\2\u0319")
        buf.write("\u031b\3\2\2\2\u031a\u030e\3\2\2\2\u031a\u0312\3\2\2\2")
        buf.write("\u031b\u0087\3\2\2\2\u031c\u031e\5\u008eH\2\u031d\u031c")
        buf.write("\3\2\2\2\u031e\u031f\3\2\2\2\u031f\u031d\3\2\2\2\u031f")
        buf.write("\u0320\3\2\2\2\u0320\u032a\3\2\2\2\u0321\u0323\5\2\2\2")
        buf.write("\u0322\u0324\5\u008eH\2\u0323\u0322\3\2\2\2\u0324\u0325")
        buf.write("\3\2\2\2\u0325\u0323\3\2\2\2\u0325\u0326\3\2\2\2\u0326")
        buf.write("\u0327\3\2\2\2\u0327\u0328\5\6\4\2\u0328\u032a\3\2\2\2")
        buf.write("\u0329\u031d\3\2\2\2\u0329\u0321\3\2\2\2\u032a\u0089\3")
        buf.write("\2\2\2\u032b\u032d\5> \2\u032c\u032e\5\"\22\2\u032d\u032c")
        buf.write("\3\2\2\2\u032d\u032e\3\2\2\2\u032e\u008b\3\2\2\2\u032f")
        buf.write("\u0330\7\f\2\2\u0330\u0335\5\u008aF\2\u0331\u0332\7\b")
        buf.write("\2\2\u0332\u0334\5\u008aF\2\u0333\u0331\3\2\2\2\u0334")
        buf.write("\u0337\3\2\2\2\u0335\u0333\3\2\2\2\u0335\u0336\3\2\2\2")
        buf.write("\u0336\u033d\3\2\2\2\u0337\u0335\3\2\2\2\u0338\u0339\5")
        buf.write("\2\2\2\u0339\u033a\7\r\2\2\u033a\u033b\5\6\4\2\u033b\u033e")
        buf.write("\3\2\2\2\u033c\u033e\7\r\2\2\u033d\u0338\3\2\2\2\u033d")
        buf.write("\u033c\3\2\2\2\u033e\u033f\3\2\2\2\u033f\u0341\7\27\2")
        buf.write("\2\u0340\u0342\5\6\4\2\u0341\u0340\3\2\2\2\u0341\u0342")
        buf.write("\3\2\2\2\u0342\u034c\3\2\2\2\u0343\u0346\5\2\2\2\u0344")
        buf.write("\u0347\5&\24\2\u0345\u0347\5~@\2\u0346\u0344\3\2\2\2\u0346")
        buf.write("\u0345\3\2\2\2\u0347\u034d\3\2\2\2\u0348\u034b\5&\24\2")
        buf.write("\u0349\u034b\5~@\2\u034a\u0348\3\2\2\2\u034a\u0349\3\2")
        buf.write("\2\2\u034b\u034d\3\2\2\2\u034c\u0343\3\2\2\2\u034c\u034a")
        buf.write("\3\2\2\2\u034d\u008d\3\2\2\2\u034e\u0353\7X\2\2\u034f")
        buf.write("\u0350\7\b\2\2\u0350\u0352\7X\2\2\u0351\u034f\3\2\2\2")
        buf.write("\u0352\u0355\3\2\2\2\u0353\u0351\3\2\2\2\u0353\u0354\3")
        buf.write("\2\2\2\u0354\u0358\3\2\2\2\u0355\u0353\3\2\2\2\u0356\u0357")
        buf.write("\7\25\2\2\u0357\u0359\5&\24\2\u0358\u0356\3\2\2\2\u0358")
        buf.write("\u0359\3\2\2\2\u0359\u035a\3\2\2\2\u035a\u0360\7\27\2")
        buf.write("\2\u035b\u035c\5\2\2\2\u035c\u035d\5~@\2\u035d\u035e\5")
        buf.write("\6\4\2\u035e\u0361\3\2\2\2\u035f\u0361\5~@\2\u0360\u035b")
        buf.write("\3\2\2\2\u0360\u035f\3\2\2\2\u0361\u008f\3\2\2\2\u0362")
        buf.write("\u0364\5\u0092J\2\u0363\u0365\5\u009aN\2\u0364\u0363\3")
        buf.write("\2\2\2\u0364\u0365\3\2\2\2\u0365\u0366\3\2\2\2\u0366\u0367")
        buf.write("\5\4\3\2\u0367\u0091\3\2\2\2\u0368\u036d\7X\2\2\u0369")
        buf.write("\u036a\7\b\2\2\u036a\u036c\7X\2\2\u036b\u0369\3\2\2\2")
        buf.write("\u036c\u036f\3\2\2\2\u036d\u036b\3\2\2\2\u036d\u036e\3")
        buf.write("\2\2\2\u036e\u0371\3\2\2\2\u036f\u036d\3\2\2\2\u0370\u0372")
        buf.write("\7\b\2\2\u0371\u0370\3\2\2\2\u0371\u0372\3\2\2\2\u0372")
        buf.write("\u037b\3\2\2\2\u0373\u0379\7\25\2\2\u0374\u0375\5\2\2")
        buf.write("\2\u0375\u0376\5&\24\2\u0376\u0377\5\6\4\2\u0377\u037a")
        buf.write("\3\2\2\2\u0378\u037a\5&\24\2\u0379\u0374\3\2\2\2\u0379")
        buf.write("\u0378\3\2\2\2\u037a\u037c\3\2\2\2\u037b\u0373\3\2\2\2")
        buf.write("\u037b\u037c\3\2\2\2\u037c\u0388\3\2\2\2\u037d\u0386\7")
        buf.write("\27\2\2\u037e\u0381\5\2\2\2\u037f\u0382\5~@\2\u0380\u0382")
        buf.write("\5&\24\2\u0381\u037f\3\2\2\2\u0381\u0380\3\2\2\2\u0382")
        buf.write("\u0383\3\2\2\2\u0383\u0384\5\6\4\2\u0384\u0387\3\2\2\2")
        buf.write("\u0385\u0387\5\\/\2\u0386\u037e\3\2\2\2\u0386\u0385\3")
        buf.write("\2\2\2\u0387\u0389\3\2\2\2\u0388\u037d\3\2\2\2\u0388\u0389")
        buf.write("\3\2\2\2\u0389\u0093\3\2\2\2\u038a\u038d\5\u0096L\2\u038b")
        buf.write("\u038d\5\u0098M\2\u038c\u038a\3\2\2\2\u038c\u038b\3\2")
        buf.write("\2\2\u038d\u0095\3\2\2\2\u038e\u0392\5T+\2\u038f\u0392")
        buf.write("\5V,\2\u0390\u0392\5|?\2\u0391\u038e\3\2\2\2\u0391\u038f")
        buf.write("\3\2\2\2\u0391\u0390\3\2\2\2\u0392\u0097\3\2\2\2\u0393")
        buf.write("\u03a0\5t;\2\u0394\u03a0\5p9\2\u0395\u03a0\5z>\2\u0396")
        buf.write("\u03a0\5r:\2\u0397\u0398\t\t\2\2\u0398\u03a0\5\u0082B")
        buf.write("\2\u0399\u039a\7\24\2\2\u039a\u03a0\5\u0084C\2\u039b\u039c")
        buf.write("\7)\2\2\u039c\u03a0\5\u0088E\2\u039d\u039e\t\n\2\2\u039e")
        buf.write("\u03a0\5\u0086D\2\u039f\u0393\3\2\2\2\u039f\u0394\3\2")
        buf.write("\2\2\u039f\u0395\3\2\2\2\u039f\u0396\3\2\2\2\u039f\u0397")
        buf.write("\3\2\2\2\u039f\u0399\3\2\2\2\u039f\u039b\3\2\2\2\u039f")
        buf.write("\u039d\3\2\2\2\u03a0\u0099\3\2\2\2\u03a1\u03a2\7\25\2")
        buf.write("\2\u03a2\u03a3\5\u009eP\2\u03a3\u009b\3\2\2\2\u03a4\u03a5")
        buf.write("\5&\24\2\u03a5\u03a8\7\27\2\2\u03a6\u03a9\5~@\2\u03a7")
        buf.write("\u03a9\5&\24\2\u03a8\u03a6\3\2\2\2\u03a8\u03a7\3\2\2\2")
        buf.write("\u03a9\u03ab\3\2\2\2\u03aa\u03ac\5\u009aN\2\u03ab\u03aa")
        buf.write("\3\2\2\2\u03ab\u03ac\3\2\2\2\u03ac\u009d\3\2\2\2\u03ad")
        buf.write("\u03ae\5\2\2\2\u03ae\u03b5\5\u0094K\2\u03af\u03b1\7\t")
        buf.write("\2\2\u03b0\u03af\3\2\2\2\u03b0\u03b1\3\2\2\2\u03b1\u03b2")
        buf.write("\3\2\2\2\u03b2\u03b4\5\u0094K\2\u03b3\u03b0\3\2\2\2\u03b4")
        buf.write("\u03b7\3\2\2\2\u03b5\u03b3\3\2\2\2\u03b5\u03b6\3\2\2\2")
        buf.write("\u03b6\u03b8\3\2\2\2\u03b7\u03b5\3\2\2\2\u03b8\u03b9\5")
        buf.write("\6\4\2\u03b9\u03bc\3\2\2\2\u03ba\u03bc\5\u0094K\2\u03bb")
        buf.write("\u03ad\3\2\2\2\u03bb\u03ba\3\2\2\2\u03bc\u009f\3\2\2\2")
        buf.write("\u03bd\u03c4\5\u0094K\2\u03be\u03c0\7\t\2\2\u03bf\u03be")
        buf.write("\3\2\2\2\u03bf\u03c0\3\2\2\2\u03c0\u03c1\3\2\2\2\u03c1")
        buf.write("\u03c3\5\u0094K\2\u03c2\u03bf\3\2\2\2\u03c3\u03c6\3\2")
        buf.write("\2\2\u03c4\u03c2\3\2\2\2\u03c4\u03c5\3\2\2\2\u03c5\u00a1")
        buf.write("\3\2\2\2\u03c6\u03c4\3\2\2\2\u03c7\u03c9\5\u00a0Q\2\u03c8")
        buf.write("\u03c7\3\2\2\2\u03c9\u03ca\3\2\2\2\u03ca\u03c8\3\2\2\2")
        buf.write("\u03ca\u03cb\3\2\2\2\u03cb\u00a3\3\2\2\2\u03cc\u03cd\5")
        buf.write("\u00a2R\2\u03cd\u00a5\3\2\2\2\u0088\u00a9\u00b9\u00c5")
        buf.write("\u00da\u00e3\u00eb\u00f3\u00fb\u0103\u010b\u0113\u011b")
        buf.write("\u0123\u012b\u0138\u0142\u0144\u0147\u014b\u0151\u0153")
        buf.write("\u015b\u0166\u0170\u0176\u017e\u0186\u018b\u0190\u0194")
        buf.write("\u019b\u01a3\u01aa\u01b0\u01b2\u01b4\u01ba\u01c0\u01c6")
        buf.write("\u01cc\u01ce\u01d0\u01d7\u01df\u01e8\u01f1\u01f5\u01fa")
        buf.write("\u0202\u0206\u0210\u0214\u021c\u0221\u0228\u022f\u0235")
        buf.write("\u023a\u023e\u0247\u0249\u024f\u0251\u0256\u025d\u025f")
        buf.write("\u0265\u0267\u0269\u026e\u0275\u0279\u027f\u0289\u0292")
        buf.write("\u0294\u029a\u029c\u02a0\u02a5\u02ac\u02af\u02b6\u02b9")
        buf.write("\u02bb\u02bf\u02c8\u02cb\u02d2\u02d5\u02d7\u02d9\u02dd")
        buf.write("\u02e5\u02e9\u02f1\u02f9\u02ff\u0308\u0310\u0316\u031a")
        buf.write("\u031f\u0325\u0329\u032d\u0335\u033d\u0341\u0346\u034a")
        buf.write("\u034c\u0353\u0358\u0360\u0364\u036d\u0371\u0379\u037b")
        buf.write("\u0381\u0386\u0388\u038c\u0391\u039f\u03a8\u03ab\u03b0")
        buf.write("\u03b5\u03bb\u03bf\u03c4\u03ca")
=======
        buf.write("\'\3\'\3\'\5\'\u0188\n\'\3\'\3\'\3\'\5\'\u018d\n\'\3\'")
        buf.write("\3\'\3\'\5\'\u0192\n\'\7\'\u0194\n\'\f\'\16\'\u0197\13")
        buf.write("\'\3\'\3\'\3\'\3\'\5\'\u019d\n\'\3(\3(\3(\3(\7(\u01a3")
        buf.write("\n(\f(\16(\u01a6\13(\3(\3(\7(\u01aa\n(\f(\16(\u01ad\13")
        buf.write("(\3(\6(\u01b0\n(\r(\16(\u01b1\5(\u01b4\n(\5(\u01b6\n(")
        buf.write("\3)\3)\3)\3)\5)\u01bc\n)\3)\3)\3)\3)\5)\u01c2\n)\3)\3")
        buf.write(")\6)\u01c6\n)\r)\16)\u01c7\3)\3)\6)\u01cc\n)\r)\16)\u01cd")
        buf.write("\5)\u01d0\n)\5)\u01d2\n)\3*\3*\3*\3*\3*\5*\u01d9\n*\3")
        buf.write("+\3+\5+\u01dd\n+\3+\3+\3+\3+\3+\3+\5+\u01e5\n+\3,\3,\3")
        buf.write("-\3-\5-\u01eb\n-\3-\3-\3-\3-\5-\u01f1\n-\3-\5-\u01f4\n")
        buf.write("-\3-\3-\3-\5-\u01f9\n-\3-\3-\3-\3-\5-\u01ff\n-\3-\5-\u0202")
        buf.write("\n-\7-\u0204\n-\f-\16-\u0207\13-\3-\3-\3-\3-\3-\5-\u020e")
        buf.write("\n-\3-\5-\u0211\n-\3.\3.\3.\5.\u0216\n.\3.\3.\3.\3.\3")
        buf.write(".\5.\u021d\n.\3/\3/\3/\3\60\3\60\5\60\u0224\n\60\3\60")
        buf.write("\3\60\3\61\3\61\5\61\u022a\n\61\3\61\3\61\3\61\5\61\u022f")
        buf.write("\n\61\7\61\u0231\n\61\f\61\16\61\u0234\13\61\3\62\3\62")
        buf.write("\3\62\3\62\3\62\3\62\3\62\3\62\3\62\3\62\5\62\u0240\n")
        buf.write("\62\6\62\u0242\n\62\r\62\16\62\u0243\3\62\5\62\u0247\n")
        buf.write("\62\3\63\6\63\u024a\n\63\r\63\16\63\u024b\3\63\3\63\3")
        buf.write("\63\3\63\3\63\3\63\3\63\3\63\3\63\5\63\u0257\n\63\6\63")
        buf.write("\u0259\n\63\r\63\16\63\u025a\3\63\5\63\u025e\n\63\5\63")
        buf.write("\u0260\n\63\3\64\3\64\3\64\5\64\u0265\n\64\3\64\3\64\3")
        buf.write("\64\3\64\3\64\5\64\u026c\n\64\3\65\3\65\5\65\u0270\n\65")
        buf.write("\3\65\3\65\3\66\3\66\5\66\u0276\n\66\3\66\3\66\3\67\3")
        buf.write("\67\3\67\3\67\7\67\u027e\n\67\f\67\16\67\u0281\13\67\3")
        buf.write("\67\3\67\3\67\3\67\3\67\3\67\3\67\3\67\3\67\5\67\u028c")
        buf.write("\n\67\3\67\6\67\u028f\n\67\r\67\16\67\u0290\38\38\58\u0295")
        buf.write("\n8\38\38\38\38\38\38\38\38\58\u029f\n8\68\u02a1\n8\r")
        buf.write("8\168\u02a2\38\58\u02a6\n8\38\38\38\58\u02ab\n8\38\38")
        buf.write("\38\38\38\38\38\38\58\u02b5\n8\68\u02b7\n8\r8\168\u02b8")
        buf.write("\38\58\u02bc\n8\78\u02be\n8\f8\168\u02c1\138\38\38\38")
        buf.write("\38\38\38\38\38\38\58\u02cc\n8\68\u02ce\n8\r8\168\u02cf")
        buf.write("\38\58\u02d3\n8\58\u02d5\n8\39\39\39\59\u02da\n9\39\3")
        buf.write("9\39\39\39\39\39\39\59\u02e4\n9\59\u02e6\n9\39\59\u02e9")
        buf.write("\n9\3:\3:\3:\3:\3:\3:\3:\7:\u02f2\n:\f:\16:\u02f5\13:")
        buf.write("\3:\5:\u02f8\n:\3;\3;\3;\3;\3;\3;\5;\u0300\n;\3<\3<\5")
        buf.write("<\u0304\n<\3=\3=\5=\u0308\n=\3>\3>\5>\u030c\n>\3?\3?\5")
        buf.write("?\u0310\n?\3?\3?\3?\3?\3?\3?\3?\5?\u0319\n?\3?\5?\u031c")
        buf.write("\n?\3@\3@\3A\3A\3A\3A\3A\5A\u0325\nA\3B\3B\3B\3B\5B\u032b")
        buf.write("\nB\3B\3B\3C\3C\3C\7C\u0332\nC\fC\16C\u0335\13C\3D\3D")
        buf.write("\3E\6E\u033a\nE\rE\16E\u033b\3E\3E\6E\u0340\nE\rE\16E")
        buf.write("\u0341\3E\3E\5E\u0346\nE\3F\6F\u0349\nF\rF\16F\u034a\3")
        buf.write("F\3F\6F\u034f\nF\rF\16F\u0350\3F\3F\5F\u0355\nF\3G\3G")
        buf.write("\5G\u0359\nG\3H\3H\3H\3H\7H\u035f\nH\fH\16H\u0362\13H")
        buf.write("\3H\3H\3H\5H\u0367\nH\3H\3H\5H\u036b\nH\3H\3H\3H\5H\u0370")
        buf.write("\nH\3I\3I\3I\7I\u0375\nI\fI\16I\u0378\13I\3I\3I\5I\u037c")
        buf.write("\nI\3I\3I\3I\3I\5I\u0382\nI\3J\3J\3K\3K\3K\7K\u0389\n")
        buf.write("K\fK\16K\u038c\13K\3K\5K\u038f\nK\3K\3K\3K\3K\5K\u0395")
        buf.write("\nK\5K\u0397\nK\3K\3K\3K\3K\5K\u039d\nK\3K\5K\u03a0\n")
        buf.write("K\5K\u03a2\nK\3L\3L\5L\u03a6\nL\3M\3M\3M\3M\3M\3M\5M\u03ae")
        buf.write("\nM\3N\3N\3N\3N\3N\3N\3N\3N\3N\3N\3N\3N\3N\5N\u03bd\n")
        buf.write("N\3O\3O\3O\3P\3P\3P\3P\5P\u03c6\nP\3P\5P\u03c9\nP\3Q\3")
        buf.write("Q\5Q\u03cd\nQ\3Q\7Q\u03d0\nQ\fQ\16Q\u03d3\13Q\3Q\3Q\3")
        buf.write("Q\5Q\u03d8\nQ\3Q\7Q\u03db\nQ\fQ\16Q\u03de\13Q\3Q\3Q\3")
        buf.write("Q\5Q\u03e3\nQ\3R\6R\u03e6\nR\rR\16R\u03e7\3S\3S\3S\2\2")
        buf.write("T\2\4\6\b\n\f\16\20\22\24\26\30\32\34\36 \"$&(*,.\60\62")
        buf.write("\64\668:<>@BDFHJLNPRTVXZ\\^`bdfhjlnprtvxz|~\u0080\u0082")
        buf.write("\u0084\u0086\u0088\u008a\u008c\u008e\u0090\u0092\u0094")
        buf.write("\u0096\u0098\u009a\u009c\u009e\u00a0\u00a2\u00a4\2\13")
        buf.write("\3\3mm\5\2\'\'++KK\t\2\')\678<<>>DDOOUU\4\2\27\27\35\35")
        buf.write("\4\2\30\32!!\5\2QQYbdj\3\2kl\5\2++AAPP\3\2\'(\2\u0450")
        buf.write("\2\u00a6\3\2\2\2\4\u00a9\3\2\2\2\6\u00ab\3\2\2\2\b\u00ad")
        buf.write("\3\2\2\2\n\u00af\3\2\2\2\f\u00b1\3\2\2\2\16\u00b3\3\2")
        buf.write("\2\2\20\u00b9\3\2\2\2\22\u00bb\3\2\2\2\24\u00bd\3\2\2")
        buf.write("\2\26\u00bf\3\2\2\2\30\u00c5\3\2\2\2\32\u00c7\3\2\2\2")
        buf.write("\34\u00c9\3\2\2\2\36\u00cb\3\2\2\2 \u00cd\3\2\2\2\"\u00da")
        buf.write("\3\2\2\2$\u00dc\3\2\2\2&\u00de\3\2\2\2(\u00e6\3\2\2\2")
        buf.write("*\u00ee\3\2\2\2,\u00f6\3\2\2\2.\u00fe\3\2\2\2\60\u0106")
        buf.write("\3\2\2\2\62\u010e\3\2\2\2\64\u0116\3\2\2\2\66\u011e\3")
        buf.write("\2\2\28\u0126\3\2\2\2:\u012e\3\2\2\2<\u0130\3\2\2\2>\u0138")
        buf.write("\3\2\2\2@\u0147\3\2\2\2B\u014b\3\2\2\2D\u0155\3\2\2\2")
        buf.write("F\u0160\3\2\2\2H\u0170\3\2\2\2J\u0176\3\2\2\2L\u019c\3")
        buf.write("\2\2\2N\u01b5\3\2\2\2P\u01d1\3\2\2\2R\u01d8\3\2\2\2T\u01da")
        buf.write("\3\2\2\2V\u01e6\3\2\2\2X\u01ea\3\2\2\2Z\u0212\3\2\2\2")
        buf.write("\\\u021e\3\2\2\2^\u0221\3\2\2\2`\u0229\3\2\2\2b\u0235")
        buf.write("\3\2\2\2d\u0249\3\2\2\2f\u0261\3\2\2\2h\u026d\3\2\2\2")
        buf.write("j\u0273\3\2\2\2l\u0279\3\2\2\2n\u0294\3\2\2\2p\u02d6\3")
        buf.write("\2\2\2r\u02ea\3\2\2\2t\u02f9\3\2\2\2v\u0301\3\2\2\2x\u0305")
        buf.write("\3\2\2\2z\u0309\3\2\2\2|\u030d\3\2\2\2~\u031d\3\2\2\2")
        buf.write("\u0080\u0324\3\2\2\2\u0082\u0326\3\2\2\2\u0084\u032e\3")
        buf.write("\2\2\2\u0086\u0336\3\2\2\2\u0088\u0345\3\2\2\2\u008a\u0354")
        buf.write("\3\2\2\2\u008c\u0356\3\2\2\2\u008e\u035a\3\2\2\2\u0090")
        buf.write("\u0371\3\2\2\2\u0092\u0383\3\2\2\2\u0094\u0385\3\2\2\2")
        buf.write("\u0096\u03a5\3\2\2\2\u0098\u03ad\3\2\2\2\u009a\u03bc\3")
        buf.write("\2\2\2\u009c\u03be\3\2\2\2\u009e\u03c1\3\2\2\2\u00a0\u03e2")
        buf.write("\3\2\2\2\u00a2\u03e5\3\2\2\2\u00a4\u03e9\3\2\2\2\u00a6")
        buf.write("\u00a7\7q\2\2\u00a7\3\3\2\2\2\u00a8\u00aa\5\2\2\2\u00a9")
        buf.write("\u00a8\3\2\2\2\u00a9\u00aa\3\2\2\2\u00aa\5\3\2\2\2\u00ab")
        buf.write("\u00ac\t\2\2\2\u00ac\7\3\2\2\2\u00ad\u00ae\t\3\2\2\u00ae")
        buf.write("\t\3\2\2\2\u00af\u00b0\t\4\2\2\u00b0\13\3\2\2\2\u00b1")
        buf.write("\u00b2\7\34\2\2\u00b2\r\3\2\2\2\u00b3\u00b4\t\5\2\2\u00b4")
        buf.write("\17\3\2\2\2\u00b5\u00ba\7\36\2\2\u00b6\u00b7\7\25\2\2")
        buf.write("\u00b7\u00ba\7\25\2\2\u00b8\u00ba\7\25\2\2\u00b9\u00b5")
        buf.write("\3\2\2\2\u00b9\u00b6\3\2\2\2\u00b9\u00b8\3\2\2\2\u00ba")
        buf.write("\21\3\2\2\2\u00bb\u00bc\7\37\2\2\u00bc\23\3\2\2\2\u00bd")
        buf.write("\u00be\7 \2\2\u00be\25\3\2\2\2\u00bf\u00c0\t\6\2\2\u00c0")
        buf.write("\27\3\2\2\2\u00c1\u00c6\7\"\2\2\u00c2\u00c3\7\26\2\2\u00c3")
        buf.write("\u00c6\7\26\2\2\u00c4\u00c6\7\26\2\2\u00c5\u00c1\3\2\2")
        buf.write("\2\u00c5\u00c2\3\2\2\2\u00c5\u00c4\3\2\2\2\u00c6\31\3")
        buf.write("\2\2\2\u00c7\u00c8\7#\2\2\u00c8\33\3\2\2\2\u00c9\u00ca")
        buf.write("\7$\2\2\u00ca\35\3\2\2\2\u00cb\u00cc\7%\2\2\u00cc\37\3")
        buf.write("\2\2\2\u00cd\u00ce\7&\2\2\u00ce!\3\2\2\2\u00cf\u00db\5")
        buf.write("\f\7\2\u00d0\u00db\5\16\b\2\u00d1\u00db\5\20\t\2\u00d2")
        buf.write("\u00db\5\22\n\2\u00d3\u00db\5\24\13\2\u00d4\u00db\5\26")
        buf.write("\f\2\u00d5\u00db\5\30\r\2\u00d6\u00db\5\32\16\2\u00d7")
        buf.write("\u00db\5\34\17\2\u00d8\u00db\5\36\20\2\u00d9\u00db\5 ")
        buf.write("\21\2\u00da\u00cf\3\2\2\2\u00da\u00d0\3\2\2\2\u00da\u00d1")
        buf.write("\3\2\2\2\u00da\u00d2\3\2\2\2\u00da\u00d3\3\2\2\2\u00da")
        buf.write("\u00d4\3\2\2\2\u00da\u00d5\3\2\2\2\u00da\u00d6\3\2\2\2")
        buf.write("\u00da\u00d7\3\2\2\2\u00da\u00d8\3\2\2\2\u00da\u00d9\3")
        buf.write("\2\2\2\u00db#\3\2\2\2\u00dc\u00dd\5\"\22\2\u00dd%\3\2")
        buf.write("\2\2\u00de\u00e3\5(\25\2\u00df\u00e0\7\35\2\2\u00e0\u00e2")
        buf.write("\5(\25\2\u00e1\u00df\3\2\2\2\u00e2\u00e5\3\2\2\2\u00e3")
        buf.write("\u00e1\3\2\2\2\u00e3\u00e4\3\2\2\2\u00e4\'\3\2\2\2\u00e5")
        buf.write("\u00e3\3\2\2\2\u00e6\u00eb\5*\26\2\u00e7\u00e8\7\36\2")
        buf.write("\2\u00e8\u00ea\5*\26\2\u00e9\u00e7\3\2\2\2\u00ea\u00ed")
        buf.write("\3\2\2\2\u00eb\u00e9\3\2\2\2\u00eb\u00ec\3\2\2\2\u00ec")
        buf.write(")\3\2\2\2\u00ed\u00eb\3\2\2\2\u00ee\u00f3\5,\27\2\u00ef")
        buf.write("\u00f0\7\37\2\2\u00f0\u00f2\5,\27\2\u00f1\u00ef\3\2\2")
        buf.write("\2\u00f2\u00f5\3\2\2\2\u00f3\u00f1\3\2\2\2\u00f3\u00f4")
        buf.write("\3\2\2\2\u00f4+\3\2\2\2\u00f5\u00f3\3\2\2\2\u00f6\u00fb")
        buf.write("\5.\30\2\u00f7\u00f8\7 \2\2\u00f8\u00fa\5.\30\2\u00f9")
        buf.write("\u00f7\3\2\2\2\u00fa\u00fd\3\2\2\2\u00fb\u00f9\3\2\2\2")
        buf.write("\u00fb\u00fc\3\2\2\2\u00fc-\3\2\2\2\u00fd\u00fb\3\2\2")
        buf.write("\2\u00fe\u0103\5\60\31\2\u00ff\u0100\7!\2\2\u0100\u0102")
        buf.write("\5\60\31\2\u0101\u00ff\3\2\2\2\u0102\u0105\3\2\2\2\u0103")
        buf.write("\u0101\3\2\2\2\u0103\u0104\3\2\2\2\u0104/\3\2\2\2\u0105")
        buf.write("\u0103\3\2\2\2\u0106\u010b\5\62\32\2\u0107\u0108\7\"\2")
        buf.write("\2\u0108\u010a\5\62\32\2\u0109\u0107\3\2\2\2\u010a\u010d")
        buf.write("\3\2\2\2\u010b\u0109\3\2\2\2\u010b\u010c\3\2\2\2\u010c")
        buf.write("\61\3\2\2\2\u010d\u010b\3\2\2\2\u010e\u0113\5\64\33\2")
        buf.write("\u010f\u0110\7#\2\2\u0110\u0112\5\64\33\2\u0111\u010f")
        buf.write("\3\2\2\2\u0112\u0115\3\2\2\2\u0113\u0111\3\2\2\2\u0113")
        buf.write("\u0114\3\2\2\2\u0114\63\3\2\2\2\u0115\u0113\3\2\2\2\u0116")
        buf.write("\u011b\5\66\34\2\u0117\u0118\7$\2\2\u0118\u011a\5\66\34")
        buf.write("\2\u0119\u0117\3\2\2\2\u011a\u011d\3\2\2\2\u011b\u0119")
        buf.write("\3\2\2\2\u011b\u011c\3\2\2\2\u011c\65\3\2\2\2\u011d\u011b")
        buf.write("\3\2\2\2\u011e\u0123\58\35\2\u011f\u0120\7%\2\2\u0120")
        buf.write("\u0122\58\35\2\u0121\u011f\3\2\2\2\u0122\u0125\3\2\2\2")
        buf.write("\u0123\u0121\3\2\2\2\u0123\u0124\3\2\2\2\u0124\67\3\2")
        buf.write("\2\2\u0125\u0123\3\2\2\2\u0126\u012b\5N(\2\u0127\u0128")
        buf.write("\7&\2\2\u0128\u012a\5N(\2\u0129\u0127\3\2\2\2\u012a\u012d")
        buf.write("\3\2\2\2\u012b\u0129\3\2\2\2\u012b\u012c\3\2\2\2\u012c")
        buf.write("9\3\2\2\2\u012d\u012b\3\2\2\2\u012e\u012f\t\7\2\2\u012f")
        buf.write(";\3\2\2\2\u0130\u0131\t\b\2\2\u0131=\3\2\2\2\u0132\u0139")
        buf.write("\5@!\2\u0133\u0134\7W\2\2\u0134\u0135\5@!\2\u0135\u0136")
        buf.write("\7W\2\2\u0136\u0139\3\2\2\2\u0137\u0139\7X\2\2\u0138\u0132")
        buf.write("\3\2\2\2\u0138\u0133\3\2\2\2\u0138\u0137\3\2\2\2\u0139")
        buf.write("?\3\2\2\2\u013a\u0148\7X\2\2\u013b\u0148\5:\36\2\u013c")
        buf.write("\u0143\5\"\22\2\u013d\u0143\7\n\2\2\u013e\u0143\7\13\2")
        buf.write("\2\u013f\u0143\7\16\2\2\u0140\u0143\7\17\2\2\u0141\u0143")
        buf.write("\7\27\2\2\u0142\u013c\3\2\2\2\u0142\u013d\3\2\2\2\u0142")
        buf.write("\u013e\3\2\2\2\u0142\u013f\3\2\2\2\u0142\u0140\3\2\2\2")
        buf.write("\u0142\u0141\3\2\2\2\u0143\u0146\3\2\2\2\u0144\u0142\3")
        buf.write("\2\2\2\u0144\u0145\3\2\2\2\u0145\u0148\3\2\2\2\u0146\u0144")
        buf.write("\3\2\2\2\u0147\u013a\3\2\2\2\u0147\u013b\3\2\2\2\u0147")
        buf.write("\u0144\3\2\2\2\u0148A\3\2\2\2\u0149\u014c\5\u0080A\2\u014a")
        buf.write("\u014c\5&\24\2\u014b\u0149\3\2\2\2\u014b\u014a\3\2\2\2")
        buf.write("\u014c\u0153\3\2\2\2\u014d\u0154\7\25\2\2\u014e\u0151")
        buf.write("\7\27\2\2\u014f\u0152\5\u0080A\2\u0150\u0152\5&\24\2\u0151")
        buf.write("\u014f\3\2\2\2\u0151\u0150\3\2\2\2\u0152\u0154\3\2\2\2")
        buf.write("\u0153\u014d\3\2\2\2\u0153\u014e\3\2\2\2\u0153\u0154\3")
        buf.write("\2\2\2\u0154C\3\2\2\2\u0155\u0156\7\16\2\2\u0156\u015b")
        buf.write("\5B\"\2\u0157\u0158\7\b\2\2\u0158\u015a\5B\"\2\u0159\u0157")
        buf.write("\3\2\2\2\u015a\u015d\3\2\2\2\u015b\u0159\3\2\2\2\u015b")
        buf.write("\u015c\3\2\2\2\u015c\u015e\3\2\2\2\u015d\u015b\3\2\2\2")
        buf.write("\u015e\u015f\7\17\2\2\u015fE\3\2\2\2\u0160\u0161\7\n\2")
        buf.write("\2\u0161\u0166\5B\"\2\u0162\u0163\7\b\2\2\u0163\u0165")
        buf.write("\5B\"\2\u0164\u0162\3\2\2\2\u0165\u0168\3\2\2\2\u0166")
        buf.write("\u0164\3\2\2\2\u0166\u0167\3\2\2\2\u0167\u0169\3\2\2\2")
        buf.write("\u0168\u0166\3\2\2\2\u0169\u016a\7\13\2\2\u016aG\3\2\2")
        buf.write("\2\u016b\u0171\5<\37\2\u016c\u0171\5> \2\u016d\u0171\5")
        buf.write(":\36\2\u016e\u0171\5R*\2\u016f\u0171\5D#\2\u0170\u016b")
        buf.write("\3\2\2\2\u0170\u016c\3\2\2\2\u0170\u016d\3\2\2\2\u0170")
        buf.write("\u016e\3\2\2\2\u0170\u016f\3\2\2\2\u0171I\3\2\2\2\u0172")
        buf.write("\u0177\5<\37\2\u0173\u0177\5> \2\u0174\u0177\5R*\2\u0175")
        buf.write("\u0177\5D#\2\u0176\u0172\3\2\2\2\u0176\u0173\3\2\2\2\u0176")
        buf.write("\u0174\3\2\2\2\u0176\u0175\3\2\2\2\u0177K\3\2\2\2\u0178")
        buf.write("\u0179\7\n\2\2\u0179\u017e\5B\"\2\u017a\u017b\7\b\2\2")
        buf.write("\u017b\u017d\5B\"\2\u017c\u017a\3\2\2\2\u017d\u0180\3")
        buf.write("\2\2\2\u017e\u017c\3\2\2\2\u017e\u017f\3\2\2\2\u017f\u0181")
        buf.write("\3\2\2\2\u0180\u017e\3\2\2\2\u0181\u0182\7\13\2\2\u0182")
        buf.write("\u019d\3\2\2\2\u0183\u0184\7\26\2\2\u0184\u0185\5\4\3")
        buf.write("\2\u0185\u0187\5> \2\u0186\u0188\5<\37\2\u0187\u0186\3")
        buf.write("\2\2\2\u0187\u0188\3\2\2\2\u0188\u019d\3\2\2\2\u0189\u018c")
        buf.write("\7\16\2\2\u018a\u018d\5&\24\2\u018b\u018d\5\u0080A\2\u018c")
        buf.write("\u018a\3\2\2\2\u018c\u018b\3\2\2\2\u018d\u0195\3\2\2\2")
        buf.write("\u018e\u0191\7\b\2\2\u018f\u0192\5&\24\2\u0190\u0192\5")
        buf.write("\u0080A\2\u0191\u018f\3\2\2\2\u0191\u0190\3\2\2\2\u0192")
        buf.write("\u0194\3\2\2\2\u0193\u018e\3\2\2\2\u0194\u0197\3\2\2\2")
        buf.write("\u0195\u0193\3\2\2\2\u0195\u0196\3\2\2\2\u0196\u0198\3")
        buf.write("\2\2\2\u0197\u0195\3\2\2\2\u0198\u0199\7\17\2\2\u0199")
        buf.write("\u019d\3\2\2\2\u019a\u019b\6\'\2\2\u019b\u019d\5\u0080")
        buf.write("A\2\u019c\u0178\3\2\2\2\u019c\u0183\3\2\2\2\u019c\u0189")
        buf.write("\3\2\2\2\u019c\u019a\3\2\2\2\u019dM\3\2\2\2\u019e\u019f")
        buf.write("\5\b\5\2\u019f\u01a0\5&\24\2\u01a0\u01b6\3\2\2\2\u01a1")
        buf.write("\u01a3\5$\23\2\u01a2\u01a1\3\2\2\2\u01a3\u01a6\3\2\2\2")
        buf.write("\u01a4\u01a2\3\2\2\2\u01a4\u01a5\3\2\2\2\u01a5\u01b3\3")
        buf.write("\2\2\2\u01a6\u01a4\3\2\2\2\u01a7\u01ab\5H%\2\u01a8\u01aa")
        buf.write("\5L\'\2\u01a9\u01a8\3\2\2\2\u01aa\u01ad\3\2\2\2\u01ab")
        buf.write("\u01a9\3\2\2\2\u01ab\u01ac\3\2\2\2\u01ac\u01b4\3\2\2\2")
        buf.write("\u01ad\u01ab\3\2\2\2\u01ae\u01b0\5L\'\2\u01af\u01ae\3")
        buf.write("\2\2\2\u01b0\u01b1\3\2\2\2\u01b1\u01af\3\2\2\2\u01b1\u01b2")
        buf.write("\3\2\2\2\u01b2\u01b4\3\2\2\2\u01b3\u01a7\3\2\2\2\u01b3")
        buf.write("\u01af\3\2\2\2\u01b4\u01b6\3\2\2\2\u01b5\u019e\3\2\2\2")
        buf.write("\u01b5\u01a4\3\2\2\2\u01b6O\3\2\2\2\u01b7\u01b8\6)\3\2")
        buf.write("\u01b8\u01bb\5\u0096L\2\u01b9\u01ba\7\t\2\2\u01ba\u01bc")
        buf.write("\5\u0096L\2\u01bb\u01b9\3\2\2\2\u01bb\u01bc\3\2\2\2\u01bc")
        buf.write("\u01d2\3\2\2\2\u01bd\u01d2\5\u0080A\2\u01be\u01c2\7\25")
        buf.write("\2\2\u01bf\u01c0\7\27\2\2\u01c0\u01c2\5\u0080A\2\u01c1")
        buf.write("\u01be\3\2\2\2\u01c1\u01bf\3\2\2\2\u01c2\u01cf\3\2\2\2")
        buf.write("\u01c3\u01c4\7\b\2\2\u01c4\u01c6\5B\"\2\u01c5\u01c3\3")
        buf.write("\2\2\2\u01c6\u01c7\3\2\2\2\u01c7\u01c5\3\2\2\2\u01c7\u01c8")
        buf.write("\3\2\2\2\u01c8\u01d0\3\2\2\2\u01c9\u01cb\7\t\2\2\u01ca")
        buf.write("\u01cc\5\u0096L\2\u01cb\u01ca\3\2\2\2\u01cc\u01cd\3\2")
        buf.write("\2\2\u01cd\u01cb\3\2\2\2\u01cd\u01ce\3\2\2\2\u01ce\u01d0")
        buf.write("\3\2\2\2\u01cf\u01c5\3\2\2\2\u01cf\u01c9\3\2\2\2\u01d0")
        buf.write("\u01d2\3\2\2\2\u01d1\u01b7\3\2\2\2\u01d1\u01bd\3\2\2\2")
        buf.write("\u01d1\u01c1\3\2\2\2\u01d2Q\3\2\2\2\u01d3\u01d4\7\n\2")
        buf.write("\2\u01d4\u01d5\5P)\2\u01d5\u01d6\7\13\2\2\u01d6\u01d9")
        buf.write("\3\2\2\2\u01d7\u01d9\5P)\2\u01d8\u01d3\3\2\2\2\u01d8\u01d7")
        buf.write("\3\2\2\2\u01d9S\3\2\2\2\u01da\u01dc\7O\2\2\u01db\u01dd")
        buf.write("\5> \2\u01dc\u01db\3\2\2\2\u01dc\u01dd\3\2\2\2\u01dd\u01de")
        buf.write("\3\2\2\2\u01de\u01e4\7\25\2\2\u01df\u01e5\5\u00a0Q\2\u01e0")
        buf.write("\u01e1\5\2\2\2\u01e1\u01e2\5\u00a0Q\2\u01e2\u01e3\5\6")
        buf.write("\4\2\u01e3\u01e5\3\2\2\2\u01e4\u01df\3\2\2\2\u01e4\u01e0")
        buf.write("\3\2\2\2\u01e5U\3\2\2\2\u01e6\u01e7\5l\67\2\u01e7W\3\2")
        buf.write("\2\2\u01e8\u01eb\5&\24\2\u01e9\u01eb\5\u0080A\2\u01ea")
        buf.write("\u01e8\3\2\2\2\u01ea\u01e9\3\2\2\2\u01eb\u01ec\3\2\2\2")
        buf.write("\u01ec\u01ed\7\25\2\2\u01ed\u01f0\5\4\3\2\u01ee\u01f1")
        buf.write("\5&\24\2\u01ef\u01f1\5\u0080A\2\u01f0\u01ee\3\2\2\2\u01f0")
        buf.write("\u01ef\3\2\2\2\u01f1\u01f3\3\2\2\2\u01f2\u01f4\5\6\4\2")
        buf.write("\u01f3\u01f2\3\2\2\2\u01f3\u01f4\3\2\2\2\u01f4\u0205\3")
        buf.write("\2\2\2\u01f5\u01f8\79\2\2\u01f6\u01f9\5\u0080A\2\u01f7")
        buf.write("\u01f9\5&\24\2\u01f8\u01f6\3\2\2\2\u01f8\u01f7\3\2\2\2")
        buf.write("\u01f9\u01fa\3\2\2\2\u01fa\u01fb\7\25\2\2\u01fb\u01fe")
        buf.write("\5\4\3\2\u01fc\u01ff\5&\24\2\u01fd\u01ff\5\u0080A\2\u01fe")
        buf.write("\u01fc\3\2\2\2\u01fe\u01fd\3\2\2\2\u01ff\u0201\3\2\2\2")
        buf.write("\u0200\u0202\5\6\4\2\u0201\u0200\3\2\2\2\u0201\u0202\3")
        buf.write("\2\2\2\u0202\u0204\3\2\2\2\u0203\u01f5\3\2\2\2\u0204\u0207")
        buf.write("\3\2\2\2\u0205\u0203\3\2\2\2\u0205\u0206\3\2\2\2\u0206")
        buf.write("\u0208\3\2\2\2\u0207\u0205\3\2\2\2\u0208\u0209\7:\2\2")
        buf.write("\u0209\u020a\7\25\2\2\u020a\u020d\5\4\3\2\u020b\u020e")
        buf.write("\5&\24\2\u020c\u020e\5\u0080A\2\u020d\u020b\3\2\2\2\u020d")
        buf.write("\u020c\3\2\2\2\u020e\u0210\3\2\2\2\u020f\u0211\5\6\4\2")
        buf.write("\u0210\u020f\3\2\2\2\u0210\u0211\3\2\2\2\u0211Y\3\2\2")
        buf.write("\2\u0212\u0215\7\67\2\2\u0213\u0216\5&\24\2\u0214\u0216")
        buf.write("\5\u0080A\2\u0215\u0213\3\2\2\2\u0215\u0214\3\2\2\2\u0216")
        buf.write("\u021c\3\2\2\2\u0217\u0218\5\2\2\2\u0218\u0219\5d\63\2")
        buf.write("\u0219\u021a\5\6\4\2\u021a\u021d\3\2\2\2\u021b\u021d\5")
        buf.write("d\63\2\u021c\u0217\3\2\2\2\u021c\u021b\3\2\2\2\u021d[")
        buf.write("\3\2\2\2\u021e\u021f\7D\2\2\u021f\u0220\5X-\2\u0220]\3")
        buf.write("\2\2\2\u0221\u0223\78\2\2\u0222\u0224\7\32\2\2\u0223\u0222")
        buf.write("\3\2\2\2\u0223\u0224\3\2\2\2\u0224\u0225\3\2\2\2\u0225")
        buf.write("\u0226\5X-\2\u0226_\3\2\2\2\u0227\u022a\5&\24\2\u0228")
        buf.write("\u022a\5\u0080A\2\u0229\u0227\3\2\2\2\u0229\u0228\3\2")
        buf.write("\2\2\u022a\u0232\3\2\2\2\u022b\u022e\7\b\2\2\u022c\u022f")
        buf.write("\5&\24\2\u022d\u022f\5\u0080A\2\u022e\u022c\3\2\2\2\u022e")
        buf.write("\u022d\3\2\2\2\u022f\u0231\3\2\2\2\u0230\u022b\3\2\2\2")
        buf.write("\u0231\u0234\3\2\2\2\u0232\u0230\3\2\2\2\u0232\u0233\3")
        buf.write("\2\2\2\u0233a\3\2\2\2\u0234\u0232\3\2\2\2\u0235\u0236")
        buf.write("\7\31\2\2\u0236\u0237\5`\61\2\u0237\u0238\7\25\2\2\u0238")
        buf.write("\u0241\5\4\3\2\u0239\u0242\5\u009eP\2\u023a\u0240\5\u00a0")
        buf.write("Q\2\u023b\u023c\5\2\2\2\u023c\u023d\5\u00a0Q\2\u023d\u023e")
        buf.write("\5\6\4\2\u023e\u0240\3\2\2\2\u023f\u023a\3\2\2\2\u023f")
        buf.write("\u023b\3\2\2\2\u0240\u0242\3\2\2\2\u0241\u0239\3\2\2\2")
        buf.write("\u0241\u023f\3\2\2\2\u0242\u0243\3\2\2\2\u0243\u0241\3")
        buf.write("\2\2\2\u0243\u0244\3\2\2\2\u0244\u0246\3\2\2\2\u0245\u0247")
        buf.write("\5\6\4\2\u0246\u0245\3\2\2\2\u0246\u0247\3\2\2\2\u0247")
        buf.write("c\3\2\2\2\u0248\u024a\5b\62\2\u0249\u0248\3\2\2\2\u024a")
        buf.write("\u024b\3\2\2\2\u024b\u0249\3\2\2\2\u024b\u024c\3\2\2\2")
        buf.write("\u024c\u025f\3\2\2\2\u024d\u024e\7:\2\2\u024e\u024f\7")
        buf.write("\25\2\2\u024f\u0258\5\4\3\2\u0250\u0259\5\u009eP\2\u0251")
        buf.write("\u0257\5\u00a0Q\2\u0252\u0253\5\2\2\2\u0253\u0254\5\u00a0")
        buf.write("Q\2\u0254\u0255\5\6\4\2\u0255\u0257\3\2\2\2\u0256\u0251")
        buf.write("\3\2\2\2\u0256\u0252\3\2\2\2\u0257\u0259\3\2\2\2\u0258")
        buf.write("\u0250\3\2\2\2\u0258\u0256\3\2\2\2\u0259\u025a\3\2\2\2")
        buf.write("\u025a\u0258\3\2\2\2\u025a\u025b\3\2\2\2\u025b\u025d\3")
        buf.write("\2\2\2\u025c\u025e\5\6\4\2\u025d\u025c\3\2\2\2\u025d\u025e")
        buf.write("\3\2\2\2\u025e\u0260\3\2\2\2\u025f\u024d\3\2\2\2\u025f")
        buf.write("\u0260\3\2\2\2\u0260e\3\2\2\2\u0261\u0264\7\67\2\2\u0262")
        buf.write("\u0265\5&\24\2\u0263\u0265\5\u0080A\2\u0264\u0262\3\2")
        buf.write("\2\2\u0264\u0263\3\2\2\2\u0265\u026b\3\2\2\2\u0266\u0267")
        buf.write("\5\2\2\2\u0267\u0268\5d\63\2\u0268\u0269\5\6\4\2\u0269")
        buf.write("\u026c\3\2\2\2\u026a\u026c\5d\63\2\u026b\u0266\3\2\2\2")
        buf.write("\u026b\u026a\3\2\2\2\u026cg\3\2\2\2\u026d\u026f\78\2\2")
        buf.write("\u026e\u0270\7\32\2\2\u026f\u026e\3\2\2\2\u026f\u0270")
        buf.write("\3\2\2\2\u0270\u0271\3\2\2\2\u0271\u0272\5n8\2\u0272i")
        buf.write("\3\2\2\2\u0273\u0275\7D\2\2\u0274\u0276\7\32\2\2\u0275")
        buf.write("\u0274\3\2\2\2\u0275\u0276\3\2\2\2\u0276\u0277\3\2\2\2")
        buf.write("\u0277\u0278\5n8\2\u0278k\3\2\2\2\u0279\u027a\7>\2\2\u027a")
        buf.write("\u027f\7X\2\2\u027b\u027c\7\b\2\2\u027c\u027e\7X\2\2\u027d")
        buf.write("\u027b\3\2\2\2\u027e\u0281\3\2\2\2\u027f\u027d\3\2\2\2")
        buf.write("\u027f\u0280\3\2\2\2\u0280\u0282\3\2\2\2\u0281\u027f\3")
        buf.write("\2\2\2\u0282\u0283\7\30\2\2\u0283\u0284\5&\24\2\u0284")
        buf.write("\u0285\7\25\2\2\u0285\u028e\5\4\3\2\u0286\u028c\5\u00a0")
        buf.write("Q\2\u0287\u0288\5\2\2\2\u0288\u0289\5\u00a0Q\2\u0289\u028a")
        buf.write("\5\6\4\2\u028a\u028c\3\2\2\2\u028b\u0286\3\2\2\2\u028b")
        buf.write("\u0287\3\2\2\2\u028c\u028f\3\2\2\2\u028d\u028f\5\u009e")
        buf.write("P\2\u028e\u028b\3\2\2\2\u028e\u028d\3\2\2\2\u028f\u0290")
        buf.write("\3\2\2\2\u0290\u028e\3\2\2\2\u0290\u0291\3\2\2\2\u0291")
        buf.write("m\3\2\2\2\u0292\u0295\5&\24\2\u0293\u0295\5\u0080A\2\u0294")
        buf.write("\u0292\3\2\2\2\u0294\u0293\3\2\2\2\u0295\u0296\3\2\2\2")
        buf.write("\u0296\u0297\7\25\2\2\u0297\u02a0\5\4\3\2\u0298\u02a1")
        buf.write("\5\u009eP\2\u0299\u029f\5\u00a0Q\2\u029a\u029b\5\2\2\2")
        buf.write("\u029b\u029c\5\u00a0Q\2\u029c\u029d\5\6\4\2\u029d\u029f")
        buf.write("\3\2\2\2\u029e\u0299\3\2\2\2\u029e\u029a\3\2\2\2\u029f")
        buf.write("\u02a1\3\2\2\2\u02a0\u0298\3\2\2\2\u02a0\u029e\3\2\2\2")
        buf.write("\u02a1\u02a2\3\2\2\2\u02a2\u02a0\3\2\2\2\u02a2\u02a3\3")
        buf.write("\2\2\2\u02a3\u02a5\3\2\2\2\u02a4\u02a6\5\6\4\2\u02a5\u02a4")
        buf.write("\3\2\2\2\u02a5\u02a6\3\2\2\2\u02a6\u02bf\3\2\2\2\u02a7")
        buf.write("\u02aa\79\2\2\u02a8\u02ab\5&\24\2\u02a9\u02ab\5\u0080")
        buf.write("A\2\u02aa\u02a8\3\2\2\2\u02aa\u02a9\3\2\2\2\u02ab\u02ac")
        buf.write("\3\2\2\2\u02ac\u02ad\7\25\2\2\u02ad\u02b6\5\4\3\2\u02ae")
        buf.write("\u02b7\5\u009eP\2\u02af\u02b5\5\u00a0Q\2\u02b0\u02b1\5")
        buf.write("\2\2\2\u02b1\u02b2\5\u00a0Q\2\u02b2\u02b3\5\6\4\2\u02b3")
        buf.write("\u02b5\3\2\2\2\u02b4\u02af\3\2\2\2\u02b4\u02b0\3\2\2\2")
        buf.write("\u02b5\u02b7\3\2\2\2\u02b6\u02ae\3\2\2\2\u02b6\u02b4\3")
        buf.write("\2\2\2\u02b7\u02b8\3\2\2\2\u02b8\u02b6\3\2\2\2\u02b8\u02b9")
        buf.write("\3\2\2\2\u02b9\u02bb\3\2\2\2\u02ba\u02bc\5\6\4\2\u02bb")
        buf.write("\u02ba\3\2\2\2\u02bb\u02bc\3\2\2\2\u02bc\u02be\3\2\2\2")
        buf.write("\u02bd\u02a7\3\2\2\2\u02be\u02c1\3\2\2\2\u02bf\u02bd\3")
        buf.write("\2\2\2\u02bf\u02c0\3\2\2\2\u02c0\u02d4\3\2\2\2\u02c1\u02bf")
        buf.write("\3\2\2\2\u02c2\u02c3\7:\2\2\u02c3\u02c4\7\25\2\2\u02c4")
        buf.write("\u02cd\5\4\3\2\u02c5\u02ce\5\u009eP\2\u02c6\u02cc\5\u00a0")
        buf.write("Q\2\u02c7\u02c8\5\2\2\2\u02c8\u02c9\5\u00a0Q\2\u02c9\u02ca")
        buf.write("\5\6\4\2\u02ca\u02cc\3\2\2\2\u02cb\u02c6\3\2\2\2\u02cb")
        buf.write("\u02c7\3\2\2\2\u02cc\u02ce\3\2\2\2\u02cd\u02c5\3\2\2\2")
        buf.write("\u02cd\u02cb\3\2\2\2\u02ce\u02cf\3\2\2\2\u02cf\u02cd\3")
        buf.write("\2\2\2\u02cf\u02d0\3\2\2\2\u02d0\u02d2\3\2\2\2\u02d1\u02d3")
        buf.write("\5\6\4\2\u02d2\u02d1\3\2\2\2\u02d2\u02d3\3\2\2\2\u02d3")
        buf.write("\u02d5\3\2\2\2\u02d4\u02c2\3\2\2\2\u02d4\u02d5\3\2\2\2")
        buf.write("\u02d5o\3\2\2\2\u02d6\u02d9\7<\2\2\u02d7\u02da\5&\24\2")
        buf.write("\u02d8\u02da\5\u0080A\2\u02d9\u02d7\3\2\2\2\u02d9\u02d8")
        buf.write("\3\2\2\2\u02da\u02db\3\2\2\2\u02db\u02dc\7\25\2\2\u02dc")
        buf.write("\u02e5\5\4\3\2\u02dd\u02e6\5\u009eP\2\u02de\u02e4\5\u00a0")
        buf.write("Q\2\u02df\u02e0\5\2\2\2\u02e0\u02e1\5\u00a0Q\2\u02e1\u02e2")
        buf.write("\5\6\4\2\u02e2\u02e4\3\2\2\2\u02e3\u02de\3\2\2\2\u02e3")
        buf.write("\u02df\3\2\2\2\u02e4\u02e6\3\2\2\2\u02e5\u02dd\3\2\2\2")
        buf.write("\u02e5\u02e3\3\2\2\2\u02e6\u02e8\3\2\2\2\u02e7\u02e9\5")
        buf.write("\6\4\2\u02e8\u02e7\3\2\2\2\u02e8\u02e9\3\2\2\2\u02e9q")
        buf.write("\3\2\2\2\u02ea\u02eb\7G\2\2\u02eb\u02ec\5\4\3\2\u02ec")
        buf.write("\u02f3\7X\2\2\u02ed\u02ee\7\b\2\2\u02ee\u02ef\5\4\3\2")
        buf.write("\u02ef\u02f0\7X\2\2\u02f0\u02f2\3\2\2\2\u02f1\u02ed\3")
        buf.write("\2\2\2\u02f2\u02f5\3\2\2\2\u02f3\u02f1\3\2\2\2\u02f3\u02f4")
        buf.write("\3\2\2\2\u02f4\u02f7\3\2\2\2\u02f5\u02f3\3\2\2\2\u02f6")
        buf.write("\u02f8\5\6\4\2\u02f7\u02f6\3\2\2\2\u02f7\u02f8\3\2\2\2")
        buf.write("\u02f8s\3\2\2\2\u02f9\u02fa\7H\2\2\u02fa\u02fb\5\4\3\2")
        buf.write("\u02fb\u02fc\7X\2\2\u02fc\u02fd\5\4\3\2\u02fd\u02ff\5")
        buf.write("r:\2\u02fe\u0300\5\6\4\2\u02ff\u02fe\3\2\2\2\u02ff\u0300")
        buf.write("\3\2\2\2\u0300u\3\2\2\2\u0301\u0303\7U\2\2\u0302\u0304")
        buf.write("\5&\24\2\u0303\u0302\3\2\2\2\u0303\u0304\3\2\2\2\u0304")
        buf.write("w\3\2\2\2\u0305\u0307\7\62\2\2\u0306\u0308\5&\24\2\u0307")
        buf.write("\u0306\3\2\2\2\u0307\u0308\3\2\2\2\u0308y\3\2\2\2\u0309")
        buf.write("\u030b\7@\2\2\u030a\u030c\5&\24\2\u030b\u030a\3\2\2\2")
        buf.write("\u030b\u030c\3\2\2\2\u030c{\3\2\2\2\u030d\u030f\7O\2\2")
        buf.write("\u030e\u0310\5> \2\u030f\u030e\3\2\2\2\u030f\u0310\3\2")
        buf.write("\2\2\u0310\u0311\3\2\2\2\u0311\u0312\7\25\2\2\u0312\u0318")
        buf.write("\5\4\3\2\u0313\u0319\5\u00a0Q\2\u0314\u0315\5\2\2\2\u0315")
        buf.write("\u0316\5\u00a0Q\2\u0316\u0317\5\6\4\2\u0317\u0319\3\2")
        buf.write("\2\2\u0318\u0313\3\2\2\2\u0318\u0314\3\2\2\2\u0319\u031b")
        buf.write("\3\2\2\2\u031a\u031c\5\6\4\2\u031b\u031a\3\2\2\2\u031b")
        buf.write("\u031c\3\2\2\2\u031c}\3\2\2\2\u031d\u031e\5\u0082B\2\u031e")
        buf.write("\177\3\2\2\2\u031f\u0325\5T+\2\u0320\u0325\5V,\2\u0321")
        buf.write("\u0325\5^\60\2\u0322\u0325\5\\/\2\u0323\u0325\5Z.\2\u0324")
        buf.write("\u031f\3\2\2\2\u0324\u0320\3\2\2\2\u0324\u0321\3\2\2\2")
        buf.write("\u0324\u0322\3\2\2\2\u0324\u0323\3\2\2\2\u0325\u0081\3")
        buf.write("\2\2\2\u0326\u0327\7\f\2\2\u0327\u0328\7\26\2\2\u0328")
        buf.write("\u032a\7X\2\2\u0329\u032b\7\26\2\2\u032a\u0329\3\2\2\2")
        buf.write("\u032a\u032b\3\2\2\2\u032b\u032c\3\2\2\2\u032c\u032d\7")
        buf.write("\r\2\2\u032d\u0083\3\2\2\2\u032e\u0333\5R*\2\u032f\u0330")
        buf.write("\7\25\2\2\u0330\u0332\5\u00a0Q\2\u0331\u032f\3\2\2\2\u0332")
        buf.write("\u0335\3\2\2\2\u0333\u0331\3\2\2\2\u0333\u0334\3\2\2\2")
        buf.write("\u0334\u0085\3\2\2\2\u0335\u0333\3\2\2\2\u0336\u0337\7")
        buf.write("\f\2\2\u0337\u0087\3\2\2\2\u0338\u033a\5\u0092J\2\u0339")
        buf.write("\u0338\3\2\2\2\u033a\u033b\3\2\2\2\u033b\u0339\3\2\2\2")
        buf.write("\u033b\u033c\3\2\2\2\u033c\u0346\3\2\2\2\u033d\u033f\5")
        buf.write("\2\2\2\u033e\u0340\5\u0092J\2\u033f\u033e\3\2\2\2\u0340")
        buf.write("\u0341\3\2\2\2\u0341\u033f\3\2\2\2\u0341\u0342\3\2\2\2")
        buf.write("\u0342\u0343\3\2\2\2\u0343\u0344\5\6\4\2\u0344\u0346\3")
        buf.write("\2\2\2\u0345\u0339\3\2\2\2\u0345\u033d\3\2\2\2\u0346\u0089")
        buf.write("\3\2\2\2\u0347\u0349\5\u0090I\2\u0348\u0347\3\2\2\2\u0349")
        buf.write("\u034a\3\2\2\2\u034a\u0348\3\2\2\2\u034a\u034b\3\2\2\2")
        buf.write("\u034b\u0355\3\2\2\2\u034c\u034e\5\2\2\2\u034d\u034f\5")
        buf.write("\u0090I\2\u034e\u034d\3\2\2\2\u034f\u0350\3\2\2\2\u0350")
        buf.write("\u034e\3\2\2\2\u0350\u0351\3\2\2\2\u0351\u0352\3\2\2\2")
        buf.write("\u0352\u0353\5\6\4\2\u0353\u0355\3\2\2\2\u0354\u0348\3")
        buf.write("\2\2\2\u0354\u034c\3\2\2\2\u0355\u008b\3\2\2\2\u0356\u0358")
        buf.write("\5> \2\u0357\u0359\5\"\22\2\u0358\u0357\3\2\2\2\u0358")
        buf.write("\u0359\3\2\2\2\u0359\u008d\3\2\2\2\u035a\u035b\7\f\2\2")
        buf.write("\u035b\u0360\5\u008cG\2\u035c\u035d\7\b\2\2\u035d\u035f")
        buf.write("\5\u008cG\2\u035e\u035c\3\2\2\2\u035f\u0362\3\2\2\2\u0360")
        buf.write("\u035e\3\2\2\2\u0360\u0361\3\2\2\2\u0361\u0363\3\2\2\2")
        buf.write("\u0362\u0360\3\2\2\2\u0363\u0364\5\4\3\2\u0364\u0366\7")
        buf.write("\r\2\2\u0365\u0367\5\6\4\2\u0366\u0365\3\2\2\2\u0366\u0367")
        buf.write("\3\2\2\2\u0367\u0368\3\2\2\2\u0368\u036a\7\27\2\2\u0369")
        buf.write("\u036b\5\6\4\2\u036a\u0369\3\2\2\2\u036a\u036b\3\2\2\2")
        buf.write("\u036b\u036c\3\2\2\2\u036c\u036f\5\4\3\2\u036d\u0370\5")
        buf.write("&\24\2\u036e\u0370\5\u0080A\2\u036f\u036d\3\2\2\2\u036f")
        buf.write("\u036e\3\2\2\2\u0370\u008f\3\2\2\2\u0371\u0376\7X\2\2")
        buf.write("\u0372\u0373\7\b\2\2\u0373\u0375\7X\2\2\u0374\u0372\3")
        buf.write("\2\2\2\u0375\u0378\3\2\2\2\u0376\u0374\3\2\2\2\u0376\u0377")
        buf.write("\3\2\2\2\u0377\u037b\3\2\2\2\u0378\u0376\3\2\2\2\u0379")
        buf.write("\u037a\7\25\2\2\u037a\u037c\5&\24\2\u037b\u0379\3\2\2")
        buf.write("\2\u037b\u037c\3\2\2\2\u037c\u037d\3\2\2\2\u037d\u037e")
        buf.write("\7\27\2\2\u037e\u037f\5\4\3\2\u037f\u0381\5\u0080A\2\u0380")
        buf.write("\u0382\5\6\4\2\u0381\u0380\3\2\2\2\u0381\u0382\3\2\2\2")
        buf.write("\u0382\u0091\3\2\2\2\u0383\u0384\5\u0094K\2\u0384\u0093")
        buf.write("\3\2\2\2\u0385\u038a\7X\2\2\u0386\u0387\7\b\2\2\u0387")
        buf.write("\u0389\7X\2\2\u0388\u0386\3\2\2\2\u0389\u038c\3\2\2\2")
        buf.write("\u038a\u0388\3\2\2\2\u038a\u038b\3\2\2\2\u038b\u038e\3")
        buf.write("\2\2\2\u038c\u038a\3\2\2\2\u038d\u038f\7\b\2\2\u038e\u038d")
        buf.write("\3\2\2\2\u038e\u038f\3\2\2\2\u038f\u0396\3\2\2\2\u0390")
        buf.write("\u0391\7\25\2\2\u0391\u0392\5\4\3\2\u0392\u0394\5&\24")
        buf.write("\2\u0393\u0395\5\6\4\2\u0394\u0393\3\2\2\2\u0394\u0395")
        buf.write("\3\2\2\2\u0395\u0397\3\2\2\2\u0396\u0390\3\2\2\2\u0396")
        buf.write("\u0397\3\2\2\2\u0397\u03a1\3\2\2\2\u0398\u0399\7\27\2")
        buf.write("\2\u0399\u039c\5\4\3\2\u039a\u039d\5\u0080A\2\u039b\u039d")
        buf.write("\5&\24\2\u039c\u039a\3\2\2\2\u039c\u039b\3\2\2\2\u039d")
        buf.write("\u039f\3\2\2\2\u039e\u03a0\5\6\4\2\u039f\u039e\3\2\2\2")
        buf.write("\u039f\u03a0\3\2\2\2\u03a0\u03a2\3\2\2\2\u03a1\u0398\3")
        buf.write("\2\2\2\u03a1\u03a2\3\2\2\2\u03a2\u0095\3\2\2\2\u03a3\u03a6")
        buf.write("\5\u0098M\2\u03a4\u03a6\5\u009aN\2\u03a5\u03a3\3\2\2\2")
        buf.write("\u03a5\u03a4\3\2\2\2\u03a6\u0097\3\2\2\2\u03a7\u03ae\5")
        buf.write("r:\2\u03a8\u03ae\5t;\2\u03a9\u03ae\5v<\2\u03aa\u03ae\5")
        buf.write("x=\2\u03ab\u03ae\5z>\2\u03ac\u03ae\5~@\2\u03ad\u03a7\3")
        buf.write("\2\2\2\u03ad\u03a8\3\2\2\2\u03ad\u03a9\3\2\2\2\u03ad\u03aa")
        buf.write("\3\2\2\2\u03ad\u03ab\3\2\2\2\u03ad\u03ac\3\2\2\2\u03ae")
        buf.write("\u0099\3\2\2\2\u03af\u03bd\5l\67\2\u03b0\u03bd\5h\65\2")
        buf.write("\u03b1\u03bd\5|?\2\u03b2\u03bd\5p9\2\u03b3\u03bd\5j\66")
        buf.write("\2\u03b4\u03b5\t\t\2\2\u03b5\u03bd\5\u0084C\2\u03b6\u03b7")
        buf.write("\7\24\2\2\u03b7\u03bd\5\u0086D\2\u03b8\u03b9\7)\2\2\u03b9")
        buf.write("\u03bd\5\u008aF\2\u03ba\u03bb\t\n\2\2\u03bb\u03bd\5\u0088")
        buf.write("E\2\u03bc\u03af\3\2\2\2\u03bc\u03b0\3\2\2\2\u03bc\u03b1")
        buf.write("\3\2\2\2\u03bc\u03b2\3\2\2\2\u03bc\u03b3\3\2\2\2\u03bc")
        buf.write("\u03b4\3\2\2\2\u03bc\u03b6\3\2\2\2\u03bc\u03b8\3\2\2\2")
        buf.write("\u03bc\u03ba\3\2\2\2\u03bd\u009b\3\2\2\2\u03be\u03bf\7")
        buf.write("\25\2\2\u03bf\u03c0\5\u00a0Q\2\u03c0\u009d\3\2\2\2\u03c1")
        buf.write("\u03c2\5&\24\2\u03c2\u03c5\7\27\2\2\u03c3\u03c6\5\u0080")
        buf.write("A\2\u03c4\u03c6\5&\24\2\u03c5\u03c3\3\2\2\2\u03c5\u03c4")
        buf.write("\3\2\2\2\u03c6\u03c8\3\2\2\2\u03c7\u03c9\5\u009cO\2\u03c8")
        buf.write("\u03c7\3\2\2\2\u03c8\u03c9\3\2\2\2\u03c9\u009f\3\2\2\2")
        buf.write("\u03ca\u03d1\5\u0096L\2\u03cb\u03cd\7\t\2\2\u03cc\u03cb")
        buf.write("\3\2\2\2\u03cc\u03cd\3\2\2\2\u03cd\u03ce\3\2\2\2\u03ce")
        buf.write("\u03d0\5\u0096L\2\u03cf\u03cc\3\2\2\2\u03d0\u03d3\3\2")
        buf.write("\2\2\u03d1\u03cf\3\2\2\2\u03d1\u03d2\3\2\2\2\u03d2\u03e3")
        buf.write("\3\2\2\2\u03d3\u03d1\3\2\2\2\u03d4\u03d5\5\2\2\2\u03d5")
        buf.write("\u03dc\5\u0098M\2\u03d6\u03d8\7\t\2\2\u03d7\u03d6\3\2")
        buf.write("\2\2\u03d7\u03d8\3\2\2\2\u03d8\u03d9\3\2\2\2\u03d9\u03db")
        buf.write("\5\u0098M\2\u03da\u03d7\3\2\2\2\u03db\u03de\3\2\2\2\u03dc")
        buf.write("\u03da\3\2\2\2\u03dc\u03dd\3\2\2\2\u03dd\u03df\3\2\2\2")
        buf.write("\u03de\u03dc\3\2\2\2\u03df\u03e0\5\6\4\2\u03e0\u03e3\3")
        buf.write("\2\2\2\u03e1\u03e3\5\u0098M\2\u03e2\u03ca\3\2\2\2\u03e2")
        buf.write("\u03d4\3\2\2\2\u03e2\u03e1\3\2\2\2\u03e3\u00a1\3\2\2\2")
        buf.write("\u03e4\u03e6\5\u00a0Q\2\u03e5\u03e4\3\2\2\2\u03e6\u03e7")
        buf.write("\3\2\2\2\u03e7\u03e5\3\2\2\2\u03e7\u03e8\3\2\2\2\u03e8")
        buf.write("\u00a3\3\2\2\2\u03e9\u03ea\5\u00a2R\2\u03ea\u00a5\3\2")
        buf.write("\2\2\u0090\u00a9\u00b9\u00c5\u00da\u00e3\u00eb\u00f3\u00fb")
        buf.write("\u0103\u010b\u0113\u011b\u0123\u012b\u0138\u0142\u0144")
        buf.write("\u0147\u014b\u0151\u0153\u015b\u0166\u0170\u0176\u017e")
        buf.write("\u0187\u018c\u0191\u0195\u019c\u01a4\u01ab\u01b1\u01b3")
        buf.write("\u01b5\u01bb\u01c1\u01c7\u01cd\u01cf\u01d1\u01d8\u01dc")
        buf.write("\u01e4\u01ea\u01f0\u01f3\u01f8\u01fe\u0201\u0205\u020d")
        buf.write("\u0210\u0215\u021c\u0223\u0229\u022e\u0232\u023f\u0241")
        buf.write("\u0243\u0246\u024b\u0256\u0258\u025a\u025d\u025f\u0264")
        buf.write("\u026b\u026f\u0275\u027f\u028b\u028e\u0290\u0294\u029e")
        buf.write("\u02a0\u02a2\u02a5\u02aa\u02b4\u02b6\u02b8\u02bb\u02bf")
        buf.write("\u02cb\u02cd\u02cf\u02d2\u02d4\u02d9\u02e3\u02e5\u02e8")
        buf.write("\u02f3\u02f7\u02ff\u0303\u0307\u030b\u030f\u0318\u031b")
        buf.write("\u0324\u032a\u0333\u033b\u0341\u0345\u034a\u0350\u0354")
        buf.write("\u0358\u0360\u0366\u036a\u036f\u0376\u037b\u0381\u038a")
        buf.write("\u038e\u0394\u0396\u039c\u039f\u03a1\u03a5\u03ad\u03bc")
        buf.write("\u03c5\u03c8\u03cc\u03d1\u03d7\u03dc\u03e2\u03e7")
>>>>>>> rev1
        return buf.getvalue()


class nim_Parser ( Parser ):

    grammarFileName = "nim_Parser.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "' '", "','", "';'", "'('", "')'", "'{'", 
                     "'}'", "'['", "']'", "'interface'", "'enum'", "'object'", 
                     "'concept'", "'type'", "':'", "'.'", "'='", "'in'", 
                     "'of'", "'not'", "'$'", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "'var'", "'let'", "'const'", "'bind'", "'proc'", "'static'", 
                     "'method'", "'func'", "'mixin'", "'end'", "'except'", 
                     "'return'", "'try'", "'raise'", "'finally'", "'out'", 
                     "'case'", "'if'", "'elif'", "'else'", "'do'", "'while'", 
                     "'iterator'", "'for'", "'continue'", "'break'", "'template'", 
                     "'tuple'", "'using'", "'when'", "'yield'", "'include'", 
                     "'import'", "'from'", "'as'", "'export'", "'ref'", 
                     "'ptr'", "'addr'", "'asm'", "'block'", "'macro'", "'nil'", 
                     "'cast'", "'converter'", "'defer'", "'discard'", "'distinct'", 
                     "'`'" ]

    symbolicNames = [ "<INVALID>", "DOCUMENTATION_COMMENT", "MULTILINE_COMMENT", 
                      "COMMENT", "UNCONDITIONAL_NEWLINE", "WS", "COMMA", 
                      "SEMI_COLON", "OPEN_PAREN", "CLOSE_PAREN", "OPEN_BRACE", 
                      "CLOSE_BRACE", "OPEN_BRACK", "CLOSE_BRACK", "INTERFACE", 
                      "ENUM", "OBJECT", "CONCEPT", "TYPE", "COLON", "DOT", 
                      "EQUALS", "IN", "OF", "NOT", "DOLLAR_SIGN", "OP0", 
                      "OP1", "OP2", "OP3", "OP4", "OP5", "OP6", "OP7", "OP8", 
                      "OP9", "OP10", "VARIABLE", "LET", "CONST", "BIND", 
                      "PROC", "STATIC", "METHOD", "FUNC", "MIXIN", "END", 
                      "EXCEPT", "RETURN", "TRY", "RAISE", "FINALLY", "OUT", 
                      "CASE", "IF", "ELIF", "ELSE", "DO", "WHILE", "ITERATOR", 
                      "FOR", "CONTINUE", "BREAK", "TEMPLATE", "TUPLE", "USING", 
                      "WHEN", "YIELD", "INCLUDE", "IMPORT", "FROM", "AS", 
                      "EXPORT", "REF", "PTR", "ADDR", "ASM", "BLOCK", "MACRO", 
                      "NIL", "CAST", "CONVERTER", "DEFER", "DISCARD", "DISTINCT", 
                      "SYM_HEADER", "IDENTIFIER", "INT_LIT", "INT8_LIT", 
                      "INT16_LIT", "INT32_LIT", "INT64_LIT", "UINT_LIT", 
                      "UINT8_LIT", "UINT16_LIT", "UINT32_LIT", "UINT64_LIT", 
                      "EXP", "FLOAT_LIT", "FLOAT32_LIT", "FLOAT64_LIT", 
                      "CHAR_LIT", "STR_LIT", "TRIPLESTR_LIT", "RSTR_LIT", 
                      "GENERALIZED_STR_LIT", "GENERALIZED_TRIPLESTR_LIT", 
                      "DEDENT", "EXIT", "USELESS_LINE", "USELSSS_INDENTS", 
                      "INDENT", "INDENTS_PASS", "ERROR_INDENT" ]

    RULE_ind = 0
    RULE_optInd = 1
    RULE_ded = 2
    RULE_typeKeyw = 3
    RULE_parKeyw = 4
    RULE_op0 = 5
    RULE_op1 = 6
    RULE_op2 = 7
    RULE_op3 = 8
    RULE_op4 = 9
    RULE_op5 = 10
    RULE_op6 = 11
    RULE_op7 = 12
    RULE_op8 = 13
    RULE_op9 = 14
    RULE_op10 = 15
    RULE_operator = 16
    RULE_prefixOperator = 17
    RULE_simpleExpr = 18
    RULE_assignExpr = 19
    RULE_orExpr = 20
    RULE_andExpr = 21
    RULE_cmpExpr = 22
    RULE_sliceExpr = 23
    RULE_ampExpr = 24
    RULE_plusExpr = 25
    RULE_mulExpr = 26
    RULE_dollarExpr = 27
    RULE_literal = 28
    RULE_generalizedLit = 29
    RULE_symbol = 30
    RULE_symbolBody = 31
    RULE_exprColonEqExpr = 32
    RULE_arrayConstr = 33
    RULE_tupleConstr = 34
    RULE_identOrLiteral = 35
    RULE_identGeneral = 36
    RULE_primarySuffix = 37
    RULE_primary = 38
    RULE_parBody = 39
    RULE_par = 40
<<<<<<< HEAD
    RULE_importStmt = 41
    RULE_fromStmt = 42
    RULE_blockExpr = 43
    RULE_forExpr = 44
    RULE_anyExpr = 45
    RULE_condExprBody = 46
    RULE_condExpr = 47
    RULE_caseExpr = 48
    RULE_whenExpr = 49
    RULE_ifExpr = 50
    RULE_exprList = 51
    RULE_ofBranch = 52
    RULE_ofBranches = 53
    RULE_caseStmt = 54
    RULE_ifStmt = 55
    RULE_whenStmt = 56
    RULE_forStmt = 57
    RULE_condStmtBody = 58
    RULE_condStmt = 59
    RULE_blockStmt = 60
    RULE_pragmaStmt = 61
    RULE_expr = 62
    RULE_pragma = 63
    RULE_routine = 64
    RULE_typeSection = 65
    RULE_variableSection = 66
    RULE_constantSection = 67
    RULE_identVis = 68
    RULE_varTuple = 69
    RULE_constant = 70
    RULE_variable = 71
    RULE_idColonEq = 72
    RULE_simple_complexStmt = 73
    RULE_simpleStmt = 74
    RULE_complexStmt = 75
    RULE_colonBody = 76
    RULE_exprStmt = 77
    RULE_substmt = 78
=======
    RULE_blockExpr = 41
    RULE_forExpr = 42
    RULE_condExpr = 43
    RULE_caseExpr = 44
    RULE_whenExpr = 45
    RULE_ifExpr = 46
    RULE_exprList = 47
    RULE_ofBranch = 48
    RULE_ofBranches = 49
    RULE_caseStmt = 50
    RULE_ifStmt = 51
    RULE_whenStmt = 52
    RULE_forStmt = 53
    RULE_condStmt = 54
    RULE_whileStmt = 55
    RULE_importStmt = 56
    RULE_fromStmt = 57
    RULE_discardStmt = 58
    RULE_returnStmt = 59
    RULE_breakStmt = 60
    RULE_blockStmt = 61
    RULE_pragmaStmt = 62
    RULE_expr = 63
    RULE_pragma = 64
    RULE_routine = 65
    RULE_typeSection = 66
    RULE_variableSection = 67
    RULE_constantSection = 68
    RULE_identVis = 69
    RULE_varTuple = 70
    RULE_constant = 71
    RULE_variable = 72
    RULE_idColonEq = 73
    RULE_simple_complexStmt = 74
    RULE_simpleStmt = 75
    RULE_complexStmt = 76
    RULE_colonBody = 77
    RULE_exprStmt = 78
>>>>>>> rev1
    RULE_stmt = 79
    RULE_module = 80
    RULE_start = 81

    ruleNames =  [ "ind", "optInd", "ded", "typeKeyw", "parKeyw", "op0", 
                   "op1", "op2", "op3", "op4", "op5", "op6", "op7", "op8", 
                   "op9", "op10", "operator", "prefixOperator", "simpleExpr", 
                   "assignExpr", "orExpr", "andExpr", "cmpExpr", "sliceExpr", 
                   "ampExpr", "plusExpr", "mulExpr", "dollarExpr", "literal", 
                   "generalizedLit", "symbol", "symbolBody", "exprColonEqExpr", 
                   "arrayConstr", "tupleConstr", "identOrLiteral", "identGeneral", 
<<<<<<< HEAD
                   "primarySuffix", "primary", "parBody", "par", "importStmt", 
                   "fromStmt", "blockExpr", "forExpr", "anyExpr", "condExprBody", 
                   "condExpr", "caseExpr", "whenExpr", "ifExpr", "exprList", 
                   "ofBranch", "ofBranches", "caseStmt", "ifStmt", "whenStmt", 
                   "forStmt", "condStmtBody", "condStmt", "blockStmt", "pragmaStmt", 
                   "expr", "pragma", "routine", "typeSection", "variableSection", 
                   "constantSection", "identVis", "varTuple", "constant", 
                   "variable", "idColonEq", "simple_complexStmt", "simpleStmt", 
                   "complexStmt", "colonBody", "exprStmt", "substmt", "stmt", 
                   "module", "start" ]
=======
                   "primarySuffix", "primary", "parBody", "par", "blockExpr", 
                   "forExpr", "condExpr", "caseExpr", "whenExpr", "ifExpr", 
                   "exprList", "ofBranch", "ofBranches", "caseStmt", "ifStmt", 
                   "whenStmt", "forStmt", "condStmt", "whileStmt", "importStmt", 
                   "fromStmt", "discardStmt", "returnStmt", "breakStmt", 
                   "blockStmt", "pragmaStmt", "expr", "pragma", "routine", 
                   "typeSection", "variableSection", "constantSection", 
                   "identVis", "varTuple", "constant", "variable", "idColonEq", 
                   "simple_complexStmt", "simpleStmt", "complexStmt", "colonBody", 
                   "exprStmt", "stmt", "module", "start" ]
>>>>>>> rev1

    EOF = Token.EOF
    DOCUMENTATION_COMMENT=1
    MULTILINE_COMMENT=2
    COMMENT=3
    UNCONDITIONAL_NEWLINE=4
    WS=5
    COMMA=6
    SEMI_COLON=7
    OPEN_PAREN=8
    CLOSE_PAREN=9
    OPEN_BRACE=10
    CLOSE_BRACE=11
    OPEN_BRACK=12
    CLOSE_BRACK=13
    INTERFACE=14
    ENUM=15
    OBJECT=16
    CONCEPT=17
    TYPE=18
    COLON=19
    DOT=20
    EQUALS=21
    IN=22
    OF=23
    NOT=24
    DOLLAR_SIGN=25
    OP0=26
    OP1=27
    OP2=28
    OP3=29
    OP4=30
    OP5=31
    OP6=32
    OP7=33
    OP8=34
    OP9=35
    OP10=36
    VARIABLE=37
    LET=38
    CONST=39
    BIND=40
    PROC=41
    STATIC=42
    METHOD=43
    FUNC=44
    MIXIN=45
    END=46
    EXCEPT=47
    RETURN=48
    TRY=49
    RAISE=50
    FINALLY=51
    OUT=52
    CASE=53
    IF=54
    ELIF=55
    ELSE=56
    DO=57
    WHILE=58
    ITERATOR=59
    FOR=60
    CONTINUE=61
    BREAK=62
    TEMPLATE=63
    TUPLE=64
    USING=65
    WHEN=66
    YIELD=67
    INCLUDE=68
    IMPORT=69
    FROM=70
    AS=71
    EXPORT=72
    REF=73
    PTR=74
    ADDR=75
    ASM=76
    BLOCK=77
    MACRO=78
    NIL=79
    CAST=80
    CONVERTER=81
    DEFER=82
    DISCARD=83
    DISTINCT=84
    SYM_HEADER=85
    IDENTIFIER=86
    INT_LIT=87
    INT8_LIT=88
    INT16_LIT=89
    INT32_LIT=90
    INT64_LIT=91
    UINT_LIT=92
    UINT8_LIT=93
    UINT16_LIT=94
    UINT32_LIT=95
    UINT64_LIT=96
    EXP=97
    FLOAT_LIT=98
    FLOAT32_LIT=99
    FLOAT64_LIT=100
    CHAR_LIT=101
    STR_LIT=102
    TRIPLESTR_LIT=103
    RSTR_LIT=104
    GENERALIZED_STR_LIT=105
    GENERALIZED_TRIPLESTR_LIT=106
    DEDENT=107
    EXIT=108
    USELESS_LINE=109
    USELSSS_INDENTS=110
    INDENT=111
    INDENTS_PASS=112
    ERROR_INDENT=113

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.7.1")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None



    parKeyWList = [IF, WHILE, CASE, FOR, BLOCK, CONST, LET, WHEN, VARIABLE]
    literals = [INT_LIT, INT8_LIT, INT16_LIT , INT32_LIT , INT64_LIT, UINT_LIT , UINT8_LIT , 
    UINT16_LIT , UINT32_LIT , UINT64_LIT, FLOAT_LIT , FLOAT32_LIT , FLOAT64_LIT, STR_LIT, 
    RSTR_LIT , TRIPLESTR_LIT, CHAR_LIT, NIL ]
    primarySuffixList = [SYM_HEADER, IDENTIFIER, TYPE] + literals


    class IndContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INDENT(self):
            return self.getToken(nim_Parser.INDENT, 0)

        def getRuleIndex(self):
            return nim_Parser.RULE_ind

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInd" ):
                listener.enterInd(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInd" ):
                listener.exitInd(self)




    def ind(self):

        localctx = nim_Parser.IndContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_ind)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 164
            self.match(nim_Parser.INDENT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class OptIndContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ind(self):
            return self.getTypedRuleContext(nim_Parser.IndContext,0)


        def getRuleIndex(self):
            return nim_Parser.RULE_optInd

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOptInd" ):
                listener.enterOptInd(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOptInd" ):
                listener.exitOptInd(self)




    def optInd(self):

        localctx = nim_Parser.OptIndContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_optInd)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 167
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,0,self._ctx)
            if la_ == 1:
                self.state = 166
                self.ind()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class DedContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DEDENT(self):
            return self.getToken(nim_Parser.DEDENT, 0)

        def EOF(self):
            return self.getToken(nim_Parser.EOF, 0)

        def getRuleIndex(self):
            return nim_Parser.RULE_ded

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDed" ):
                listener.enterDed(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDed" ):
                listener.exitDed(self)




    def ded(self):

        localctx = nim_Parser.DedContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_ded)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 169
            _la = self._input.LA(1)
            if not(_la==nim_Parser.EOF or _la==nim_Parser.DEDENT):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class TypeKeywContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def VARIABLE(self):
            return self.getToken(nim_Parser.VARIABLE, 0)

        def REF(self):
            return self.getToken(nim_Parser.REF, 0)

        def PROC(self):
            return self.getToken(nim_Parser.PROC, 0)

        def getRuleIndex(self):
            return nim_Parser.RULE_typeKeyw

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTypeKeyw" ):
                listener.enterTypeKeyw(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTypeKeyw" ):
                listener.exitTypeKeyw(self)




    def typeKeyw(self):

        localctx = nim_Parser.TypeKeywContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_typeKeyw)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 171
            _la = self._input.LA(1)
            if not(((((_la - 37)) & ~0x3f) == 0 and ((1 << (_la - 37)) & ((1 << (nim_Parser.VARIABLE - 37)) | (1 << (nim_Parser.PROC - 37)) | (1 << (nim_Parser.REF - 37)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ParKeywContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DISCARD(self):
            return self.getToken(nim_Parser.DISCARD, 0)

        def IF(self):
            return self.getToken(nim_Parser.IF, 0)

        def WHILE(self):
            return self.getToken(nim_Parser.WHILE, 0)

        def CASE(self):
            return self.getToken(nim_Parser.CASE, 0)

        def FOR(self):
            return self.getToken(nim_Parser.FOR, 0)

        def BLOCK(self):
            return self.getToken(nim_Parser.BLOCK, 0)

        def CONST(self):
            return self.getToken(nim_Parser.CONST, 0)

        def LET(self):
            return self.getToken(nim_Parser.LET, 0)

        def WHEN(self):
            return self.getToken(nim_Parser.WHEN, 0)

        def VARIABLE(self):
            return self.getToken(nim_Parser.VARIABLE, 0)

        def getRuleIndex(self):
            return nim_Parser.RULE_parKeyw

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParKeyw" ):
                listener.enterParKeyw(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParKeyw" ):
                listener.exitParKeyw(self)




    def parKeyw(self):

        localctx = nim_Parser.ParKeywContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_parKeyw)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 173
            _la = self._input.LA(1)
            if not(((((_la - 37)) & ~0x3f) == 0 and ((1 << (_la - 37)) & ((1 << (nim_Parser.VARIABLE - 37)) | (1 << (nim_Parser.LET - 37)) | (1 << (nim_Parser.CONST - 37)) | (1 << (nim_Parser.CASE - 37)) | (1 << (nim_Parser.IF - 37)) | (1 << (nim_Parser.WHILE - 37)) | (1 << (nim_Parser.FOR - 37)) | (1 << (nim_Parser.WHEN - 37)) | (1 << (nim_Parser.BLOCK - 37)) | (1 << (nim_Parser.DISCARD - 37)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Op0Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OP0(self):
            return self.getToken(nim_Parser.OP0, 0)

        def getRuleIndex(self):
            return nim_Parser.RULE_op0

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOp0" ):
                listener.enterOp0(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOp0" ):
                listener.exitOp0(self)




    def op0(self):

        localctx = nim_Parser.Op0Context(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_op0)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 175
            self.match(nim_Parser.OP0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Op1Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OP1(self):
            return self.getToken(nim_Parser.OP1, 0)

        def EQUALS(self):
            return self.getToken(nim_Parser.EQUALS, 0)

        def getRuleIndex(self):
            return nim_Parser.RULE_op1

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOp1" ):
                listener.enterOp1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOp1" ):
                listener.exitOp1(self)




    def op1(self):

        localctx = nim_Parser.Op1Context(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_op1)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 177
            _la = self._input.LA(1)
            if not(_la==nim_Parser.EQUALS or _la==nim_Parser.OP1):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Op2Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OP2(self):
            return self.getToken(nim_Parser.OP2, 0)

        def COLON(self, i:int=None):
            if i is None:
                return self.getTokens(nim_Parser.COLON)
            else:
                return self.getToken(nim_Parser.COLON, i)

        def getRuleIndex(self):
            return nim_Parser.RULE_op2

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOp2" ):
                listener.enterOp2(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOp2" ):
                listener.exitOp2(self)




    def op2(self):

        localctx = nim_Parser.Op2Context(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_op2)
        try:
            self.state = 183
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 179
                self.match(nim_Parser.OP2)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 180
                self.match(nim_Parser.COLON)
                self.state = 181
                self.match(nim_Parser.COLON)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 182
                self.match(nim_Parser.COLON)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Op3Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OP3(self):
            return self.getToken(nim_Parser.OP3, 0)

        def getRuleIndex(self):
            return nim_Parser.RULE_op3

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOp3" ):
                listener.enterOp3(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOp3" ):
                listener.exitOp3(self)




    def op3(self):

        localctx = nim_Parser.Op3Context(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_op3)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 185
            self.match(nim_Parser.OP3)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Op4Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OP4(self):
            return self.getToken(nim_Parser.OP4, 0)

        def getRuleIndex(self):
            return nim_Parser.RULE_op4

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOp4" ):
                listener.enterOp4(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOp4" ):
                listener.exitOp4(self)




    def op4(self):

        localctx = nim_Parser.Op4Context(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_op4)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 187
            self.match(nim_Parser.OP4)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Op5Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OP5(self):
            return self.getToken(nim_Parser.OP5, 0)

        def IN(self):
            return self.getToken(nim_Parser.IN, 0)

        def OF(self):
            return self.getToken(nim_Parser.OF, 0)

        def NOT(self):
            return self.getToken(nim_Parser.NOT, 0)

        def getRuleIndex(self):
            return nim_Parser.RULE_op5

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOp5" ):
                listener.enterOp5(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOp5" ):
                listener.exitOp5(self)




    def op5(self):

        localctx = nim_Parser.Op5Context(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_op5)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 189
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << nim_Parser.IN) | (1 << nim_Parser.OF) | (1 << nim_Parser.NOT) | (1 << nim_Parser.OP5))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Op6Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OP6(self):
            return self.getToken(nim_Parser.OP6, 0)

        def DOT(self, i:int=None):
            if i is None:
                return self.getTokens(nim_Parser.DOT)
            else:
                return self.getToken(nim_Parser.DOT, i)

        def getRuleIndex(self):
            return nim_Parser.RULE_op6

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOp6" ):
                listener.enterOp6(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOp6" ):
                listener.exitOp6(self)




    def op6(self):

        localctx = nim_Parser.Op6Context(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_op6)
        try:
            self.state = 195
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,2,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 191
                self.match(nim_Parser.OP6)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 192
                self.match(nim_Parser.DOT)
                self.state = 193
                self.match(nim_Parser.DOT)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 194
                self.match(nim_Parser.DOT)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Op7Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OP7(self):
            return self.getToken(nim_Parser.OP7, 0)

        def getRuleIndex(self):
            return nim_Parser.RULE_op7

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOp7" ):
                listener.enterOp7(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOp7" ):
                listener.exitOp7(self)




    def op7(self):

        localctx = nim_Parser.Op7Context(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_op7)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 197
            self.match(nim_Parser.OP7)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Op8Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OP8(self):
            return self.getToken(nim_Parser.OP8, 0)

        def getRuleIndex(self):
            return nim_Parser.RULE_op8

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOp8" ):
                listener.enterOp8(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOp8" ):
                listener.exitOp8(self)




    def op8(self):

        localctx = nim_Parser.Op8Context(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_op8)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 199
            self.match(nim_Parser.OP8)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Op9Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OP9(self):
            return self.getToken(nim_Parser.OP9, 0)

        def getRuleIndex(self):
            return nim_Parser.RULE_op9

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOp9" ):
                listener.enterOp9(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOp9" ):
                listener.exitOp9(self)




    def op9(self):

        localctx = nim_Parser.Op9Context(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_op9)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 201
            self.match(nim_Parser.OP9)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Op10Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OP10(self):
            return self.getToken(nim_Parser.OP10, 0)

        def getRuleIndex(self):
            return nim_Parser.RULE_op10

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOp10" ):
                listener.enterOp10(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOp10" ):
                listener.exitOp10(self)




    def op10(self):

        localctx = nim_Parser.Op10Context(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_op10)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 203
            self.match(nim_Parser.OP10)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class OperatorContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def op0(self):
            return self.getTypedRuleContext(nim_Parser.Op0Context,0)


        def op1(self):
            return self.getTypedRuleContext(nim_Parser.Op1Context,0)


        def op2(self):
            return self.getTypedRuleContext(nim_Parser.Op2Context,0)


        def op3(self):
            return self.getTypedRuleContext(nim_Parser.Op3Context,0)


        def op4(self):
            return self.getTypedRuleContext(nim_Parser.Op4Context,0)


        def op5(self):
            return self.getTypedRuleContext(nim_Parser.Op5Context,0)


        def op6(self):
            return self.getTypedRuleContext(nim_Parser.Op6Context,0)


        def op7(self):
            return self.getTypedRuleContext(nim_Parser.Op7Context,0)


        def op8(self):
            return self.getTypedRuleContext(nim_Parser.Op8Context,0)


        def op9(self):
            return self.getTypedRuleContext(nim_Parser.Op9Context,0)


        def op10(self):
            return self.getTypedRuleContext(nim_Parser.Op10Context,0)


        def getRuleIndex(self):
            return nim_Parser.RULE_operator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOperator" ):
                listener.enterOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOperator" ):
                listener.exitOperator(self)




    def operator(self):

        localctx = nim_Parser.OperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_operator)
        try:
            self.state = 216
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [nim_Parser.OP0]:
                self.enterOuterAlt(localctx, 1)
                self.state = 205
                self.op0()
                pass
            elif token in [nim_Parser.EQUALS, nim_Parser.OP1]:
                self.enterOuterAlt(localctx, 2)
                self.state = 206
                self.op1()
                pass
            elif token in [nim_Parser.COLON, nim_Parser.OP2]:
                self.enterOuterAlt(localctx, 3)
                self.state = 207
                self.op2()
                pass
            elif token in [nim_Parser.OP3]:
                self.enterOuterAlt(localctx, 4)
                self.state = 208
                self.op3()
                pass
            elif token in [nim_Parser.OP4]:
                self.enterOuterAlt(localctx, 5)
                self.state = 209
                self.op4()
                pass
            elif token in [nim_Parser.IN, nim_Parser.OF, nim_Parser.NOT, nim_Parser.OP5]:
                self.enterOuterAlt(localctx, 6)
                self.state = 210
                self.op5()
                pass
            elif token in [nim_Parser.DOT, nim_Parser.OP6]:
                self.enterOuterAlt(localctx, 7)
                self.state = 211
                self.op6()
                pass
            elif token in [nim_Parser.OP7]:
                self.enterOuterAlt(localctx, 8)
                self.state = 212
                self.op7()
                pass
            elif token in [nim_Parser.OP8]:
                self.enterOuterAlt(localctx, 9)
                self.state = 213
                self.op8()
                pass
            elif token in [nim_Parser.OP9]:
                self.enterOuterAlt(localctx, 10)
                self.state = 214
                self.op9()
                pass
            elif token in [nim_Parser.OP10]:
                self.enterOuterAlt(localctx, 11)
                self.state = 215
                self.op10()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PrefixOperatorContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def operator(self):
            return self.getTypedRuleContext(nim_Parser.OperatorContext,0)


        def getRuleIndex(self):
            return nim_Parser.RULE_prefixOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPrefixOperator" ):
                listener.enterPrefixOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPrefixOperator" ):
                listener.exitPrefixOperator(self)




    def prefixOperator(self):

        localctx = nim_Parser.PrefixOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_prefixOperator)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 218
            self.operator()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class SimpleExprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def assignExpr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nim_Parser.AssignExprContext)
            else:
                return self.getTypedRuleContext(nim_Parser.AssignExprContext,i)


        def OP1(self, i:int=None):
            if i is None:
                return self.getTokens(nim_Parser.OP1)
            else:
                return self.getToken(nim_Parser.OP1, i)

        def getRuleIndex(self):
            return nim_Parser.RULE_simpleExpr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimpleExpr" ):
                listener.enterSimpleExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimpleExpr" ):
                listener.exitSimpleExpr(self)




    def simpleExpr(self):

        localctx = nim_Parser.SimpleExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_simpleExpr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 220
            self.assignExpr()
            self.state = 225
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,4,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 221
                    self.match(nim_Parser.OP1)
                    self.state = 222
                    self.assignExpr() 
                self.state = 227
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,4,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class AssignExprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def orExpr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nim_Parser.OrExprContext)
            else:
                return self.getTypedRuleContext(nim_Parser.OrExprContext,i)


        def OP2(self, i:int=None):
            if i is None:
                return self.getTokens(nim_Parser.OP2)
            else:
                return self.getToken(nim_Parser.OP2, i)

        def getRuleIndex(self):
            return nim_Parser.RULE_assignExpr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssignExpr" ):
                listener.enterAssignExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssignExpr" ):
                listener.exitAssignExpr(self)




    def assignExpr(self):

        localctx = nim_Parser.AssignExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_assignExpr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 228
            self.orExpr()
            self.state = 233
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,5,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 229
                    self.match(nim_Parser.OP2)
                    self.state = 230
                    self.orExpr() 
                self.state = 235
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,5,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class OrExprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def andExpr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nim_Parser.AndExprContext)
            else:
                return self.getTypedRuleContext(nim_Parser.AndExprContext,i)


        def OP3(self, i:int=None):
            if i is None:
                return self.getTokens(nim_Parser.OP3)
            else:
                return self.getToken(nim_Parser.OP3, i)

        def getRuleIndex(self):
            return nim_Parser.RULE_orExpr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOrExpr" ):
                listener.enterOrExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOrExpr" ):
                listener.exitOrExpr(self)




    def orExpr(self):

        localctx = nim_Parser.OrExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_orExpr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 236
            self.andExpr()
            self.state = 241
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,6,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 237
                    self.match(nim_Parser.OP3)
                    self.state = 238
                    self.andExpr() 
                self.state = 243
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,6,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class AndExprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def cmpExpr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nim_Parser.CmpExprContext)
            else:
                return self.getTypedRuleContext(nim_Parser.CmpExprContext,i)


        def OP4(self, i:int=None):
            if i is None:
                return self.getTokens(nim_Parser.OP4)
            else:
                return self.getToken(nim_Parser.OP4, i)

        def getRuleIndex(self):
            return nim_Parser.RULE_andExpr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAndExpr" ):
                listener.enterAndExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAndExpr" ):
                listener.exitAndExpr(self)




    def andExpr(self):

        localctx = nim_Parser.AndExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_andExpr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 244
            self.cmpExpr()
            self.state = 249
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,7,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 245
                    self.match(nim_Parser.OP4)
                    self.state = 246
                    self.cmpExpr() 
                self.state = 251
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,7,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class CmpExprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def sliceExpr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nim_Parser.SliceExprContext)
            else:
                return self.getTypedRuleContext(nim_Parser.SliceExprContext,i)


        def OP5(self, i:int=None):
            if i is None:
                return self.getTokens(nim_Parser.OP5)
            else:
                return self.getToken(nim_Parser.OP5, i)

        def getRuleIndex(self):
            return nim_Parser.RULE_cmpExpr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCmpExpr" ):
                listener.enterCmpExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCmpExpr" ):
                listener.exitCmpExpr(self)




    def cmpExpr(self):

        localctx = nim_Parser.CmpExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_cmpExpr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 252
            self.sliceExpr()
            self.state = 257
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,8,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 253
                    self.match(nim_Parser.OP5)
                    self.state = 254
                    self.sliceExpr() 
                self.state = 259
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,8,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class SliceExprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ampExpr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nim_Parser.AmpExprContext)
            else:
                return self.getTypedRuleContext(nim_Parser.AmpExprContext,i)


        def OP6(self, i:int=None):
            if i is None:
                return self.getTokens(nim_Parser.OP6)
            else:
                return self.getToken(nim_Parser.OP6, i)

        def getRuleIndex(self):
            return nim_Parser.RULE_sliceExpr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSliceExpr" ):
                listener.enterSliceExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSliceExpr" ):
                listener.exitSliceExpr(self)




    def sliceExpr(self):

        localctx = nim_Parser.SliceExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_sliceExpr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 260
            self.ampExpr()
            self.state = 265
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,9,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 261
                    self.match(nim_Parser.OP6)
                    self.state = 262
                    self.ampExpr() 
                self.state = 267
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,9,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class AmpExprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def plusExpr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nim_Parser.PlusExprContext)
            else:
                return self.getTypedRuleContext(nim_Parser.PlusExprContext,i)


        def OP7(self, i:int=None):
            if i is None:
                return self.getTokens(nim_Parser.OP7)
            else:
                return self.getToken(nim_Parser.OP7, i)

        def getRuleIndex(self):
            return nim_Parser.RULE_ampExpr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAmpExpr" ):
                listener.enterAmpExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAmpExpr" ):
                listener.exitAmpExpr(self)




    def ampExpr(self):

        localctx = nim_Parser.AmpExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_ampExpr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 268
            self.plusExpr()
            self.state = 273
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,10,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 269
                    self.match(nim_Parser.OP7)
                    self.state = 270
                    self.plusExpr() 
                self.state = 275
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,10,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PlusExprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def mulExpr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nim_Parser.MulExprContext)
            else:
                return self.getTypedRuleContext(nim_Parser.MulExprContext,i)


        def OP8(self, i:int=None):
            if i is None:
                return self.getTokens(nim_Parser.OP8)
            else:
                return self.getToken(nim_Parser.OP8, i)

        def getRuleIndex(self):
            return nim_Parser.RULE_plusExpr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPlusExpr" ):
                listener.enterPlusExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPlusExpr" ):
                listener.exitPlusExpr(self)




    def plusExpr(self):

        localctx = nim_Parser.PlusExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_plusExpr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 276
            self.mulExpr()
            self.state = 281
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,11,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 277
                    self.match(nim_Parser.OP8)
                    self.state = 278
                    self.mulExpr() 
                self.state = 283
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,11,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class MulExprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def dollarExpr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nim_Parser.DollarExprContext)
            else:
                return self.getTypedRuleContext(nim_Parser.DollarExprContext,i)


        def OP9(self, i:int=None):
            if i is None:
                return self.getTokens(nim_Parser.OP9)
            else:
                return self.getToken(nim_Parser.OP9, i)

        def getRuleIndex(self):
            return nim_Parser.RULE_mulExpr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMulExpr" ):
                listener.enterMulExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMulExpr" ):
                listener.exitMulExpr(self)




    def mulExpr(self):

        localctx = nim_Parser.MulExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_mulExpr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 284
            self.dollarExpr()
            self.state = 289
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,12,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 285
                    self.match(nim_Parser.OP9)
                    self.state = 286
                    self.dollarExpr() 
                self.state = 291
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,12,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class DollarExprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def primary(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nim_Parser.PrimaryContext)
            else:
                return self.getTypedRuleContext(nim_Parser.PrimaryContext,i)


        def OP10(self, i:int=None):
            if i is None:
                return self.getTokens(nim_Parser.OP10)
            else:
                return self.getToken(nim_Parser.OP10, i)

        def getRuleIndex(self):
            return nim_Parser.RULE_dollarExpr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDollarExpr" ):
                listener.enterDollarExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDollarExpr" ):
                listener.exitDollarExpr(self)




    def dollarExpr(self):

        localctx = nim_Parser.DollarExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_dollarExpr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 292
            self.primary()
            self.state = 297
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,13,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 293
                    self.match(nim_Parser.OP10)
                    self.state = 294
                    self.primary() 
                self.state = 299
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,13,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class LiteralContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INT_LIT(self):
            return self.getToken(nim_Parser.INT_LIT, 0)

        def INT8_LIT(self):
            return self.getToken(nim_Parser.INT8_LIT, 0)

        def INT16_LIT(self):
            return self.getToken(nim_Parser.INT16_LIT, 0)

        def INT32_LIT(self):
            return self.getToken(nim_Parser.INT32_LIT, 0)

        def INT64_LIT(self):
            return self.getToken(nim_Parser.INT64_LIT, 0)

        def UINT_LIT(self):
            return self.getToken(nim_Parser.UINT_LIT, 0)

        def UINT8_LIT(self):
            return self.getToken(nim_Parser.UINT8_LIT, 0)

        def UINT16_LIT(self):
            return self.getToken(nim_Parser.UINT16_LIT, 0)

        def UINT32_LIT(self):
            return self.getToken(nim_Parser.UINT32_LIT, 0)

        def UINT64_LIT(self):
            return self.getToken(nim_Parser.UINT64_LIT, 0)

        def FLOAT_LIT(self):
            return self.getToken(nim_Parser.FLOAT_LIT, 0)

        def FLOAT32_LIT(self):
            return self.getToken(nim_Parser.FLOAT32_LIT, 0)

        def FLOAT64_LIT(self):
            return self.getToken(nim_Parser.FLOAT64_LIT, 0)

        def STR_LIT(self):
            return self.getToken(nim_Parser.STR_LIT, 0)

        def RSTR_LIT(self):
            return self.getToken(nim_Parser.RSTR_LIT, 0)

        def TRIPLESTR_LIT(self):
            return self.getToken(nim_Parser.TRIPLESTR_LIT, 0)

        def CHAR_LIT(self):
            return self.getToken(nim_Parser.CHAR_LIT, 0)

        def NIL(self):
            return self.getToken(nim_Parser.NIL, 0)

        def getRuleIndex(self):
            return nim_Parser.RULE_literal

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLiteral" ):
                listener.enterLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLiteral" ):
                listener.exitLiteral(self)




    def literal(self):

        localctx = nim_Parser.LiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_literal)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 300
            _la = self._input.LA(1)
            if not(((((_la - 79)) & ~0x3f) == 0 and ((1 << (_la - 79)) & ((1 << (nim_Parser.NIL - 79)) | (1 << (nim_Parser.INT_LIT - 79)) | (1 << (nim_Parser.INT8_LIT - 79)) | (1 << (nim_Parser.INT16_LIT - 79)) | (1 << (nim_Parser.INT32_LIT - 79)) | (1 << (nim_Parser.INT64_LIT - 79)) | (1 << (nim_Parser.UINT_LIT - 79)) | (1 << (nim_Parser.UINT8_LIT - 79)) | (1 << (nim_Parser.UINT16_LIT - 79)) | (1 << (nim_Parser.UINT32_LIT - 79)) | (1 << (nim_Parser.UINT64_LIT - 79)) | (1 << (nim_Parser.FLOAT_LIT - 79)) | (1 << (nim_Parser.FLOAT32_LIT - 79)) | (1 << (nim_Parser.FLOAT64_LIT - 79)) | (1 << (nim_Parser.CHAR_LIT - 79)) | (1 << (nim_Parser.STR_LIT - 79)) | (1 << (nim_Parser.TRIPLESTR_LIT - 79)) | (1 << (nim_Parser.RSTR_LIT - 79)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class GeneralizedLitContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GENERALIZED_STR_LIT(self):
            return self.getToken(nim_Parser.GENERALIZED_STR_LIT, 0)

        def GENERALIZED_TRIPLESTR_LIT(self):
            return self.getToken(nim_Parser.GENERALIZED_TRIPLESTR_LIT, 0)

        def getRuleIndex(self):
            return nim_Parser.RULE_generalizedLit

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGeneralizedLit" ):
                listener.enterGeneralizedLit(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGeneralizedLit" ):
                listener.exitGeneralizedLit(self)




    def generalizedLit(self):

        localctx = nim_Parser.GeneralizedLitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_generalizedLit)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 302
            _la = self._input.LA(1)
            if not(_la==nim_Parser.GENERALIZED_STR_LIT or _la==nim_Parser.GENERALIZED_TRIPLESTR_LIT):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class SymbolContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def symbolBody(self):
            return self.getTypedRuleContext(nim_Parser.SymbolBodyContext,0)


        def SYM_HEADER(self, i:int=None):
            if i is None:
                return self.getTokens(nim_Parser.SYM_HEADER)
            else:
                return self.getToken(nim_Parser.SYM_HEADER, i)

        def IDENTIFIER(self):
            return self.getToken(nim_Parser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return nim_Parser.RULE_symbol

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSymbol" ):
                listener.enterSymbol(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSymbol" ):
                listener.exitSymbol(self)




    def symbol(self):

        localctx = nim_Parser.SymbolContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_symbol)
        try:
            self.state = 310
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,14,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 304
                self.symbolBody()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 305
                self.match(nim_Parser.SYM_HEADER)
                self.state = 306
                self.symbolBody()
                self.state = 307
                self.match(nim_Parser.SYM_HEADER)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 309
                self.match(nim_Parser.IDENTIFIER)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class SymbolBodyContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(nim_Parser.IDENTIFIER, 0)

        def literal(self):
            return self.getTypedRuleContext(nim_Parser.LiteralContext,0)


        def operator(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nim_Parser.OperatorContext)
            else:
                return self.getTypedRuleContext(nim_Parser.OperatorContext,i)


        def OPEN_PAREN(self, i:int=None):
            if i is None:
                return self.getTokens(nim_Parser.OPEN_PAREN)
            else:
                return self.getToken(nim_Parser.OPEN_PAREN, i)

        def CLOSE_PAREN(self, i:int=None):
            if i is None:
                return self.getTokens(nim_Parser.CLOSE_PAREN)
            else:
                return self.getToken(nim_Parser.CLOSE_PAREN, i)

        def OPEN_BRACK(self, i:int=None):
            if i is None:
                return self.getTokens(nim_Parser.OPEN_BRACK)
            else:
                return self.getToken(nim_Parser.OPEN_BRACK, i)

        def CLOSE_BRACK(self, i:int=None):
            if i is None:
                return self.getTokens(nim_Parser.CLOSE_BRACK)
            else:
                return self.getToken(nim_Parser.CLOSE_BRACK, i)

        def EQUALS(self, i:int=None):
            if i is None:
                return self.getTokens(nim_Parser.EQUALS)
            else:
                return self.getToken(nim_Parser.EQUALS, i)

        def getRuleIndex(self):
            return nim_Parser.RULE_symbolBody

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSymbolBody" ):
                listener.enterSymbolBody(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSymbolBody" ):
                listener.exitSymbolBody(self)




    def symbolBody(self):

        localctx = nim_Parser.SymbolBodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_symbolBody)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 325
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,17,self._ctx)
            if la_ == 1:
                self.state = 312
                self.match(nim_Parser.IDENTIFIER)
                pass

            elif la_ == 2:
                self.state = 313
                self.literal()
                pass

            elif la_ == 3:
                self.state = 322
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,16,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 320
                        self._errHandler.sync(self)
                        la_ = self._interp.adaptivePredict(self._input,15,self._ctx)
                        if la_ == 1:
                            self.state = 314
                            self.operator()
                            pass

                        elif la_ == 2:
                            self.state = 315
                            self.match(nim_Parser.OPEN_PAREN)
                            pass

                        elif la_ == 3:
                            self.state = 316
                            self.match(nim_Parser.CLOSE_PAREN)
                            pass

                        elif la_ == 4:
                            self.state = 317
                            self.match(nim_Parser.OPEN_BRACK)
                            pass

                        elif la_ == 5:
                            self.state = 318
                            self.match(nim_Parser.CLOSE_BRACK)
                            pass

                        elif la_ == 6:
                            self.state = 319
                            self.match(nim_Parser.EQUALS)
                            pass

                 
                    self.state = 324
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,16,self._ctx)

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ExprColonEqExprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nim_Parser.ExprContext)
            else:
                return self.getTypedRuleContext(nim_Parser.ExprContext,i)


        def simpleExpr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nim_Parser.SimpleExprContext)
            else:
                return self.getTypedRuleContext(nim_Parser.SimpleExprContext,i)


        def COLON(self):
            return self.getToken(nim_Parser.COLON, 0)

        def EQUALS(self):
            return self.getToken(nim_Parser.EQUALS, 0)

        def getRuleIndex(self):
            return nim_Parser.RULE_exprColonEqExpr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExprColonEqExpr" ):
                listener.enterExprColonEqExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExprColonEqExpr" ):
                listener.exitExprColonEqExpr(self)




    def exprColonEqExpr(self):

        localctx = nim_Parser.ExprColonEqExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_exprColonEqExpr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 329
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,18,self._ctx)
            if la_ == 1:
                self.state = 327
                self.expr()
                pass

            elif la_ == 2:
                self.state = 328
                self.simpleExpr()
                pass


            self.state = 337
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,20,self._ctx)
            if la_ == 1:
                self.state = 331
                self.match(nim_Parser.COLON)

            elif la_ == 2:
                self.state = 332
                self.match(nim_Parser.EQUALS)
                self.state = 335
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,19,self._ctx)
                if la_ == 1:
                    self.state = 333
                    self.expr()
                    pass

                elif la_ == 2:
                    self.state = 334
                    self.simpleExpr()
                    pass




        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ArrayConstrContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPEN_BRACK(self):
            return self.getToken(nim_Parser.OPEN_BRACK, 0)

        def exprColonEqExpr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nim_Parser.ExprColonEqExprContext)
            else:
                return self.getTypedRuleContext(nim_Parser.ExprColonEqExprContext,i)


        def CLOSE_BRACK(self):
            return self.getToken(nim_Parser.CLOSE_BRACK, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(nim_Parser.COMMA)
            else:
                return self.getToken(nim_Parser.COMMA, i)

        def getRuleIndex(self):
            return nim_Parser.RULE_arrayConstr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArrayConstr" ):
                listener.enterArrayConstr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArrayConstr" ):
                listener.exitArrayConstr(self)




    def arrayConstr(self):

        localctx = nim_Parser.ArrayConstrContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_arrayConstr)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 339
            self.match(nim_Parser.OPEN_BRACK)
            self.state = 340
            self.exprColonEqExpr()
            self.state = 345
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==nim_Parser.COMMA:
                self.state = 341
                self.match(nim_Parser.COMMA)
                self.state = 342
                self.exprColonEqExpr()
                self.state = 347
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 348
            self.match(nim_Parser.CLOSE_BRACK)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class TupleConstrContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPEN_PAREN(self):
            return self.getToken(nim_Parser.OPEN_PAREN, 0)

        def exprColonEqExpr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nim_Parser.ExprColonEqExprContext)
            else:
                return self.getTypedRuleContext(nim_Parser.ExprColonEqExprContext,i)


        def CLOSE_PAREN(self):
            return self.getToken(nim_Parser.CLOSE_PAREN, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(nim_Parser.COMMA)
            else:
                return self.getToken(nim_Parser.COMMA, i)

        def getRuleIndex(self):
            return nim_Parser.RULE_tupleConstr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTupleConstr" ):
                listener.enterTupleConstr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTupleConstr" ):
                listener.exitTupleConstr(self)




    def tupleConstr(self):

        localctx = nim_Parser.TupleConstrContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_tupleConstr)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 350
            self.match(nim_Parser.OPEN_PAREN)
            self.state = 351
            self.exprColonEqExpr()
            self.state = 356
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==nim_Parser.COMMA:
                self.state = 352
                self.match(nim_Parser.COMMA)
                self.state = 353
                self.exprColonEqExpr()
                self.state = 358
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 359
            self.match(nim_Parser.CLOSE_PAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class IdentOrLiteralContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def generalizedLit(self):
            return self.getTypedRuleContext(nim_Parser.GeneralizedLitContext,0)


        def symbol(self):
            return self.getTypedRuleContext(nim_Parser.SymbolContext,0)


        def literal(self):
            return self.getTypedRuleContext(nim_Parser.LiteralContext,0)


        def par(self):
            return self.getTypedRuleContext(nim_Parser.ParContext,0)


        def arrayConstr(self):
            return self.getTypedRuleContext(nim_Parser.ArrayConstrContext,0)


        def getRuleIndex(self):
            return nim_Parser.RULE_identOrLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdentOrLiteral" ):
                listener.enterIdentOrLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdentOrLiteral" ):
                listener.exitIdentOrLiteral(self)




    def identOrLiteral(self):

        localctx = nim_Parser.IdentOrLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_identOrLiteral)
        try:
            self.state = 366
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,23,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 361
                self.generalizedLit()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 362
                self.symbol()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 363
                self.literal()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 364
                self.par()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 365
                self.arrayConstr()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class IdentGeneralContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def generalizedLit(self):
            return self.getTypedRuleContext(nim_Parser.GeneralizedLitContext,0)


        def symbol(self):
            return self.getTypedRuleContext(nim_Parser.SymbolContext,0)


        def par(self):
            return self.getTypedRuleContext(nim_Parser.ParContext,0)


        def arrayConstr(self):
            return self.getTypedRuleContext(nim_Parser.ArrayConstrContext,0)


        def getRuleIndex(self):
            return nim_Parser.RULE_identGeneral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdentGeneral" ):
                listener.enterIdentGeneral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdentGeneral" ):
                listener.exitIdentGeneral(self)




    def identGeneral(self):

        localctx = nim_Parser.IdentGeneralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_identGeneral)
        try:
            self.state = 372
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,24,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 368
                self.generalizedLit()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 369
                self.symbol()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 370
                self.par()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 371
                self.arrayConstr()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PrimarySuffixContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPEN_PAREN(self):
            return self.getToken(nim_Parser.OPEN_PAREN, 0)

        def exprColonEqExpr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nim_Parser.ExprColonEqExprContext)
            else:
                return self.getTypedRuleContext(nim_Parser.ExprColonEqExprContext,i)


        def CLOSE_PAREN(self):
            return self.getToken(nim_Parser.CLOSE_PAREN, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(nim_Parser.COMMA)
            else:
                return self.getToken(nim_Parser.COMMA, i)

        def DOT(self):
            return self.getToken(nim_Parser.DOT, 0)

        def symbol(self):
            return self.getTypedRuleContext(nim_Parser.SymbolContext,0)


        def generalizedLit(self):
            return self.getTypedRuleContext(nim_Parser.GeneralizedLitContext,0)


        def OPEN_BRACK(self):
            return self.getToken(nim_Parser.OPEN_BRACK, 0)

        def CLOSE_BRACK(self):
            return self.getToken(nim_Parser.CLOSE_BRACK, 0)

        def simpleExpr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nim_Parser.SimpleExprContext)
            else:
                return self.getTypedRuleContext(nim_Parser.SimpleExprContext,i)


        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nim_Parser.ExprContext)
            else:
                return self.getTypedRuleContext(nim_Parser.ExprContext,i)


        def getRuleIndex(self):
            return nim_Parser.RULE_primarySuffix

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPrimarySuffix" ):
                listener.enterPrimarySuffix(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPrimarySuffix" ):
                listener.exitPrimarySuffix(self)




    def primarySuffix(self):

        localctx = nim_Parser.PrimarySuffixContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_primarySuffix)
        self._la = 0 # Token type
        try:
<<<<<<< HEAD
            self.state = 409
=======
            self.state = 410
>>>>>>> rev1
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,30,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 374
                self.match(nim_Parser.OPEN_PAREN)
                self.state = 375
                self.exprColonEqExpr()
                self.state = 380
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==nim_Parser.COMMA:
                    self.state = 376
                    self.match(nim_Parser.COMMA)
                    self.state = 377
                    self.exprColonEqExpr()
                    self.state = 382
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 383
                self.match(nim_Parser.CLOSE_PAREN)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 385
                self.match(nim_Parser.DOT)
                self.state = 386
<<<<<<< HEAD
                self.symbol()
                self.state = 388
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,26,self._ctx)
                if la_ == 1:
                    self.state = 387
=======
                self.optInd()
                self.state = 387
                self.symbol()
                self.state = 389
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,26,self._ctx)
                if la_ == 1:
                    self.state = 388
>>>>>>> rev1
                    self.generalizedLit()


                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
<<<<<<< HEAD
                self.state = 390
                self.match(nim_Parser.OPEN_BRACK)
                self.state = 393
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,27,self._ctx)
                if la_ == 1:
                    self.state = 391
=======
                self.state = 391
                self.match(nim_Parser.OPEN_BRACK)
                self.state = 394
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,27,self._ctx)
                if la_ == 1:
                    self.state = 392
>>>>>>> rev1
                    self.simpleExpr()
                    pass

                elif la_ == 2:
<<<<<<< HEAD
                    self.state = 392
=======
                    self.state = 393
>>>>>>> rev1
                    self.expr()
                    pass


<<<<<<< HEAD
                self.state = 402
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==nim_Parser.COMMA:
                    self.state = 395
                    self.match(nim_Parser.COMMA)
                    self.state = 398
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,28,self._ctx)
                    if la_ == 1:
                        self.state = 396
=======
                self.state = 403
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==nim_Parser.COMMA:
                    self.state = 396
                    self.match(nim_Parser.COMMA)
                    self.state = 399
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,28,self._ctx)
                    if la_ == 1:
                        self.state = 397
>>>>>>> rev1
                        self.simpleExpr()
                        pass

                    elif la_ == 2:
<<<<<<< HEAD
                        self.state = 397
=======
                        self.state = 398
>>>>>>> rev1
                        self.expr()
                        pass


<<<<<<< HEAD
                    self.state = 404
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 405
=======
                    self.state = 405
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 406
>>>>>>> rev1
                self.match(nim_Parser.CLOSE_BRACK)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
<<<<<<< HEAD
                self.state = 407
                if not self._input.LT(1).type in self.primarySuffixList:
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self._input.LT(1).type in self.primarySuffixList")
                self.state = 408
=======
                self.state = 408
                if not self._input.LT(1).type in self.primarySuffixList:
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self._input.LT(1).type in self.primarySuffixList")
                self.state = 409
>>>>>>> rev1
                self.expr()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PrimaryContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def simpleExpr(self):
            return self.getTypedRuleContext(nim_Parser.SimpleExprContext,0)


        def typeKeyw(self):
            return self.getTypedRuleContext(nim_Parser.TypeKeywContext,0)


        def prefixOperator(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nim_Parser.PrefixOperatorContext)
            else:
                return self.getTypedRuleContext(nim_Parser.PrefixOperatorContext,i)


        def identOrLiteral(self):
            return self.getTypedRuleContext(nim_Parser.IdentOrLiteralContext,0)


        def primarySuffix(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nim_Parser.PrimarySuffixContext)
            else:
                return self.getTypedRuleContext(nim_Parser.PrimarySuffixContext,i)


        def getRuleIndex(self):
            return nim_Parser.RULE_primary

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPrimary" ):
                listener.enterPrimary(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPrimary" ):
                listener.exitPrimary(self)




    def primary(self):

        localctx = nim_Parser.PrimaryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_primary)
        try:
            self.enterOuterAlt(localctx, 1)
<<<<<<< HEAD
            self.state = 434
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,35,self._ctx)
            if la_ == 1:
                self.state = 411
                self.typeKeyw()
                self.state = 412
=======
            self.state = 435
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,35,self._ctx)
            if la_ == 1:
                self.state = 412
                self.typeKeyw()
                self.state = 413
>>>>>>> rev1
                self.simpleExpr()
                pass

            elif la_ == 2:
<<<<<<< HEAD
                self.state = 417
=======
                self.state = 418
>>>>>>> rev1
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,31,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
<<<<<<< HEAD
                        self.state = 414
                        self.prefixOperator() 
                    self.state = 419
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,31,self._ctx)

                self.state = 432
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,34,self._ctx)
                if la_ == 1:
                    self.state = 420
                    self.identOrLiteral()
                    self.state = 424
=======
                        self.state = 415
                        self.prefixOperator() 
                    self.state = 420
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,31,self._ctx)

                self.state = 433
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,34,self._ctx)
                if la_ == 1:
                    self.state = 421
                    self.identOrLiteral()
                    self.state = 425
>>>>>>> rev1
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,32,self._ctx)
                    while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                        if _alt==1:
<<<<<<< HEAD
                            self.state = 421
                            self.primarySuffix() 
                        self.state = 426
=======
                            self.state = 422
                            self.primarySuffix() 
                        self.state = 427
>>>>>>> rev1
                        self._errHandler.sync(self)
                        _alt = self._interp.adaptivePredict(self._input,32,self._ctx)

                    pass

                elif la_ == 2:
<<<<<<< HEAD
                    self.state = 428 
=======
                    self.state = 429 
>>>>>>> rev1
                    self._errHandler.sync(self)
                    _alt = 1
                    while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                        if _alt == 1:
<<<<<<< HEAD
                            self.state = 427
=======
                            self.state = 428
>>>>>>> rev1
                            self.primarySuffix()

                        else:
                            raise NoViableAltException(self)
<<<<<<< HEAD
                        self.state = 430 
=======
                        self.state = 431 
>>>>>>> rev1
                        self._errHandler.sync(self)
                        _alt = self._interp.adaptivePredict(self._input,33,self._ctx)

                    pass


                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ParBodyContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def simple_complexStmt(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nim_Parser.Simple_complexStmtContext)
            else:
                return self.getTypedRuleContext(nim_Parser.Simple_complexStmtContext,i)


        def expr(self):
            return self.getTypedRuleContext(nim_Parser.ExprContext,0)


        def COLON(self):
            return self.getToken(nim_Parser.COLON, 0)

        def EQUALS(self):
            return self.getToken(nim_Parser.EQUALS, 0)

        def SEMI_COLON(self):
            return self.getToken(nim_Parser.SEMI_COLON, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(nim_Parser.COMMA)
            else:
                return self.getToken(nim_Parser.COMMA, i)

        def exprColonEqExpr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nim_Parser.ExprColonEqExprContext)
            else:
                return self.getTypedRuleContext(nim_Parser.ExprColonEqExprContext,i)


        def getRuleIndex(self):
            return nim_Parser.RULE_parBody

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParBody" ):
                listener.enterParBody(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParBody" ):
                listener.exitParBody(self)




    def parBody(self):

        localctx = nim_Parser.ParBodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_parBody)
        try:
            self.enterOuterAlt(localctx, 1)
<<<<<<< HEAD
            self.state = 462
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,41,self._ctx)
            if la_ == 1:
                self.state = 436
                if not self._input.LT(1).type in self.parKeyWList:
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self._input.LT(1).type in self.parKeyWList")
                self.state = 437
                self.simple_complexStmt()
                self.state = 440
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,36,self._ctx)
                if la_ == 1:
                    self.state = 438
                    self.match(nim_Parser.SEMI_COLON)
                    self.state = 439
=======
            self.state = 463
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,41,self._ctx)
            if la_ == 1:
                self.state = 437
                if not self._input.LT(1).type in self.parKeyWList:
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self._input.LT(1).type in self.parKeyWList")
                self.state = 438
                self.simple_complexStmt()
                self.state = 441
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,36,self._ctx)
                if la_ == 1:
                    self.state = 439
                    self.match(nim_Parser.SEMI_COLON)
                    self.state = 440
>>>>>>> rev1
                    self.simple_complexStmt()


                pass

            elif la_ == 2:
<<<<<<< HEAD
                self.state = 442
=======
                self.state = 443
>>>>>>> rev1
                self.expr()
                pass

            elif la_ == 3:
<<<<<<< HEAD
                self.state = 446
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [nim_Parser.COLON]:
                    self.state = 443
                    self.match(nim_Parser.COLON)
                    pass
                elif token in [nim_Parser.EQUALS]:
                    self.state = 444
                    self.match(nim_Parser.EQUALS)

                    self.state = 445
=======
                self.state = 447
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [nim_Parser.COLON]:
                    self.state = 444
                    self.match(nim_Parser.COLON)
                    pass
                elif token in [nim_Parser.EQUALS]:
                    self.state = 445
                    self.match(nim_Parser.EQUALS)

                    self.state = 446
>>>>>>> rev1
                    self.expr()
                    pass
                else:
                    raise NoViableAltException(self)

<<<<<<< HEAD
                self.state = 460
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [nim_Parser.COMMA]:
                    self.state = 450 
=======
                self.state = 461
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [nim_Parser.COMMA]:
                    self.state = 451 
>>>>>>> rev1
                    self._errHandler.sync(self)
                    _alt = 1
                    while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                        if _alt == 1:
<<<<<<< HEAD
                            self.state = 448
                            self.match(nim_Parser.COMMA)
                            self.state = 449
=======
                            self.state = 449
                            self.match(nim_Parser.COMMA)
                            self.state = 450
>>>>>>> rev1
                            self.exprColonEqExpr()

                        else:
                            raise NoViableAltException(self)
<<<<<<< HEAD
                        self.state = 452 
=======
                        self.state = 453 
>>>>>>> rev1
                        self._errHandler.sync(self)
                        _alt = self._interp.adaptivePredict(self._input,38,self._ctx)

                    pass
                elif token in [nim_Parser.SEMI_COLON]:
<<<<<<< HEAD
                    self.state = 454
                    self.match(nim_Parser.SEMI_COLON)
                    self.state = 456 
=======
                    self.state = 455
                    self.match(nim_Parser.SEMI_COLON)
                    self.state = 457 
>>>>>>> rev1
                    self._errHandler.sync(self)
                    _alt = 1
                    while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                        if _alt == 1:
<<<<<<< HEAD
                            self.state = 455
=======
                            self.state = 456
>>>>>>> rev1
                            self.simple_complexStmt()

                        else:
                            raise NoViableAltException(self)
<<<<<<< HEAD
                        self.state = 458 
=======
                        self.state = 459 
>>>>>>> rev1
                        self._errHandler.sync(self)
                        _alt = self._interp.adaptivePredict(self._input,39,self._ctx)

                    pass
                else:
                    raise NoViableAltException(self)

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ParContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPEN_PAREN(self):
            return self.getToken(nim_Parser.OPEN_PAREN, 0)

        def parBody(self):
            return self.getTypedRuleContext(nim_Parser.ParBodyContext,0)


        def CLOSE_PAREN(self):
            return self.getToken(nim_Parser.CLOSE_PAREN, 0)

        def getRuleIndex(self):
            return nim_Parser.RULE_par

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPar" ):
                listener.enterPar(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPar" ):
                listener.exitPar(self)




    def par(self):

        localctx = nim_Parser.ParContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_par)
        try:
<<<<<<< HEAD
            self.state = 469
=======
            self.state = 470
>>>>>>> rev1
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,42,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
<<<<<<< HEAD
                self.state = 464
                self.match(nim_Parser.OPEN_PAREN)
                self.state = 465
                self.parBody()
                self.state = 466
=======
                self.state = 465
                self.match(nim_Parser.OPEN_PAREN)
                self.state = 466
                self.parBody()
                self.state = 467
>>>>>>> rev1
                self.match(nim_Parser.CLOSE_PAREN)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
<<<<<<< HEAD
                self.state = 468
=======
                self.state = 469
>>>>>>> rev1
                self.parBody()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

<<<<<<< HEAD
    class ImportStmtContext(ParserRuleContext):
=======

    class BlockExprContext(ParserRuleContext):
>>>>>>> rev1

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

<<<<<<< HEAD
        def IMPORT(self):
            return self.getToken(nim_Parser.IMPORT, 0)

        def IDENTIFIER(self, i:int=None):
            if i is None:
                return self.getTokens(nim_Parser.IDENTIFIER)
            else:
                return self.getToken(nim_Parser.IDENTIFIER, i)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(nim_Parser.COMMA)
            else:
                return self.getToken(nim_Parser.COMMA, i)

        def getRuleIndex(self):
            return nim_Parser.RULE_importStmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterImportStmt" ):
                listener.enterImportStmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitImportStmt" ):
                listener.exitImportStmt(self)




    def importStmt(self):

        localctx = nim_Parser.ImportStmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_importStmt)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 471
            self.match(nim_Parser.IMPORT)
            self.state = 472
            self.match(nim_Parser.IDENTIFIER)
            self.state = 477
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,43,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 473
                    self.match(nim_Parser.COMMA)
                    self.state = 474
                    self.match(nim_Parser.IDENTIFIER) 
                self.state = 479
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,43,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class FromStmtContext(ParserRuleContext):
=======
        def BLOCK(self):
            return self.getToken(nim_Parser.BLOCK, 0)
>>>>>>> rev1

        def COLON(self):
            return self.getToken(nim_Parser.COLON, 0)

        def stmt(self):
            return self.getTypedRuleContext(nim_Parser.StmtContext,0)

<<<<<<< HEAD
        def IDENTIFIER(self):
            return self.getToken(nim_Parser.IDENTIFIER, 0)
=======

        def symbol(self):
            return self.getTypedRuleContext(nim_Parser.SymbolContext,0)

>>>>>>> rev1

        def ind(self):
            return self.getTypedRuleContext(nim_Parser.IndContext,0)


        def getRuleIndex(self):
            return nim_Parser.RULE_blockExpr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBlockExpr" ):
                listener.enterBlockExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBlockExpr" ):
                listener.exitBlockExpr(self)




    def blockExpr(self):

        localctx = nim_Parser.BlockExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_blockExpr)
        try:
            self.enterOuterAlt(localctx, 1)
<<<<<<< HEAD
            self.state = 480
            self.match(nim_Parser.FROM)
            self.state = 481
            self.match(nim_Parser.IDENTIFIER)
            self.state = 482
            self.importStmt()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class BlockExprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BLOCK(self):
            return self.getToken(nim_Parser.BLOCK, 0)

        def COLON(self):
            return self.getToken(nim_Parser.COLON, 0)

        def stmt(self):
            return self.getTypedRuleContext(nim_Parser.StmtContext,0)


        def symbol(self):
            return self.getTypedRuleContext(nim_Parser.SymbolContext,0)


        def getRuleIndex(self):
            return nim_Parser.RULE_blockExpr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBlockExpr" ):
                listener.enterBlockExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBlockExpr" ):
                listener.exitBlockExpr(self)




    def blockExpr(self):

        localctx = nim_Parser.BlockExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 86, self.RULE_blockExpr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 484
            self.match(nim_Parser.BLOCK)
            self.state = 486
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,44,self._ctx)
            if la_ == 1:
                self.state = 485
                self.symbol()
=======
            self.state = 472
            self.match(nim_Parser.BLOCK)
            self.state = 474
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,43,self._ctx)
            if la_ == 1:
                self.state = 473
                self.symbol()


            self.state = 476
            self.match(nim_Parser.COLON)
            self.state = 482
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,44,self._ctx)
            if la_ == 1:
                self.state = 477
                self.stmt()
                pass

            elif la_ == 2:
                self.state = 478
                self.ind()
                self.state = 479
                self.stmt()
                self.state = 480
                self.ded()
                pass
>>>>>>> rev1


            self.state = 488
            self.match(nim_Parser.COLON)
            self.state = 489
            self.stmt()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ForExprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def forStmt(self):
            return self.getTypedRuleContext(nim_Parser.ForStmtContext,0)


        def getRuleIndex(self):
            return nim_Parser.RULE_forExpr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterForExpr" ):
                listener.enterForExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitForExpr" ):
                listener.exitForExpr(self)




    def forExpr(self):

        localctx = nim_Parser.ForExprContext(self, self._ctx, self.state)
<<<<<<< HEAD
        self.enterRule(localctx, 88, self.RULE_forExpr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 491
=======
        self.enterRule(localctx, 84, self.RULE_forExpr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 484
>>>>>>> rev1
            self.forStmt()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class AnyExprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def simpleExpr(self):
            return self.getTypedRuleContext(nim_Parser.SimpleExprContext,0)


        def expr(self):
            return self.getTypedRuleContext(nim_Parser.ExprContext,0)


        def getRuleIndex(self):
            return nim_Parser.RULE_anyExpr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAnyExpr" ):
                listener.enterAnyExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAnyExpr" ):
                listener.exitAnyExpr(self)




    def anyExpr(self):

        localctx = nim_Parser.AnyExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 90, self.RULE_anyExpr)
        try:
            self.state = 495
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,45,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 493
                self.simpleExpr()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 494
                self.expr()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class CondExprBodyContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def simpleExpr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nim_Parser.SimpleExprContext)
            else:
                return self.getTypedRuleContext(nim_Parser.SimpleExprContext,i)


        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nim_Parser.ExprContext)
            else:
                return self.getTypedRuleContext(nim_Parser.ExprContext,i)


        def ELSE(self):
            return self.getToken(nim_Parser.ELSE, 0)

        def COLON(self, i:int=None):
            if i is None:
                return self.getTokens(nim_Parser.COLON)
            else:
                return self.getToken(nim_Parser.COLON, i)

        def ELIF(self, i:int=None):
            if i is None:
                return self.getTokens(nim_Parser.ELIF)
            else:
                return self.getToken(nim_Parser.ELIF, i)

        def ind(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nim_Parser.IndContext)
            else:
                return self.getTypedRuleContext(nim_Parser.IndContext,i)


        def andExpr(self):
            return self.getTypedRuleContext(nim_Parser.AndExprContext,0)


        def ded(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nim_Parser.DedContext)
            else:
                return self.getTypedRuleContext(nim_Parser.DedContext,i)


        def anyExpr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nim_Parser.AnyExprContext)
            else:
                return self.getTypedRuleContext(nim_Parser.AnyExprContext,i)


        def getRuleIndex(self):
            return nim_Parser.RULE_condExprBody

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCondExprBody" ):
                listener.enterCondExprBody(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCondExprBody" ):
                listener.exitCondExprBody(self)




    def condExprBody(self):

<<<<<<< HEAD
        localctx = nim_Parser.CondExprBodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 92, self.RULE_condExprBody)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 499
=======
        localctx = nim_Parser.CondExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 86, self.RULE_condExpr)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 488
>>>>>>> rev1
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,45,self._ctx)
            if la_ == 1:
<<<<<<< HEAD
                self.state = 497
=======
                self.state = 486
                self.simpleExpr()
                pass

            elif la_ == 2:
                self.state = 487
                self.expr()
                pass


            self.state = 490
            self.match(nim_Parser.COLON)
            self.state = 491
            self.optInd()
            self.state = 494
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,46,self._ctx)
            if la_ == 1:
                self.state = 492
>>>>>>> rev1
                self.simpleExpr()
                pass

            elif la_ == 2:
<<<<<<< HEAD
                self.state = 498
=======
                self.state = 493
>>>>>>> rev1
                self.expr()
                pass


<<<<<<< HEAD
            self.state = 516
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==nim_Parser.ELIF:
                self.state = 501
                self.match(nim_Parser.ELIF)
                self.state = 504
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,47,self._ctx)
                if la_ == 1:
                    self.state = 502
=======
            self.state = 497
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==nim_Parser.EOF or _la==nim_Parser.DEDENT:
                self.state = 496
                self.ded()


            self.state = 515
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==nim_Parser.ELIF:
                self.state = 499
                self.match(nim_Parser.ELIF)
                self.state = 502
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,48,self._ctx)
                if la_ == 1:
                    self.state = 500
>>>>>>> rev1
                    self.expr()
                    pass

                elif la_ == 2:
<<<<<<< HEAD
                    self.state = 503
=======
                    self.state = 501
>>>>>>> rev1
                    self.simpleExpr()
                    pass


<<<<<<< HEAD
                self.state = 506
                self.match(nim_Parser.COLON)
                self.state = 512
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,48,self._ctx)
                if la_ == 1:
                    self.state = 507
                    self.ind()
                    self.state = 508
                    self.anyExpr()
                    self.state = 509
                    self.ded()
                    pass

                elif la_ == 2:
                    self.state = 511
                    self.anyExpr()
                    pass


                self.state = 518
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 519
            self.match(nim_Parser.ELSE)
            self.state = 520
            self.match(nim_Parser.COLON)
            self.state = 526
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,50,self._ctx)
            if la_ == 1:
                self.state = 521
                self.ind()
                self.state = 522
                self.andExpr()
                self.state = 523
                self.ded()
                pass

            elif la_ == 2:
                self.state = 525
                self.anyExpr()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class CondExprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COLON(self):
            return self.getToken(nim_Parser.COLON, 0)

        def simpleExpr(self):
            return self.getTypedRuleContext(nim_Parser.SimpleExprContext,0)


        def expr(self):
            return self.getTypedRuleContext(nim_Parser.ExprContext,0)


        def ind(self):
            return self.getTypedRuleContext(nim_Parser.IndContext,0)


        def condExprBody(self):
            return self.getTypedRuleContext(nim_Parser.CondExprBodyContext,0)


        def ded(self):
            return self.getTypedRuleContext(nim_Parser.DedContext,0)


        def getRuleIndex(self):
            return nim_Parser.RULE_condExpr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCondExpr" ):
                listener.enterCondExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCondExpr" ):
                listener.exitCondExpr(self)




    def condExpr(self):

        localctx = nim_Parser.CondExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 94, self.RULE_condExpr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 530
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,51,self._ctx)
            if la_ == 1:
                self.state = 528
=======
                self.state = 504
                self.match(nim_Parser.COLON)
                self.state = 505
                self.optInd()
                self.state = 508
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,49,self._ctx)
                if la_ == 1:
                    self.state = 506
                    self.simpleExpr()
                    pass

                elif la_ == 2:
                    self.state = 507
                    self.expr()
                    pass


                self.state = 511
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==nim_Parser.EOF or _la==nim_Parser.DEDENT:
                    self.state = 510
                    self.ded()


                self.state = 517
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 518
            self.match(nim_Parser.ELSE)
            self.state = 519
            self.match(nim_Parser.COLON)
            self.state = 520
            self.optInd()
            self.state = 523
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,52,self._ctx)
            if la_ == 1:
                self.state = 521
>>>>>>> rev1
                self.simpleExpr()
                pass

            elif la_ == 2:
<<<<<<< HEAD
                self.state = 529
=======
                self.state = 522
>>>>>>> rev1
                self.expr()
                pass


<<<<<<< HEAD
            self.state = 532
            self.match(nim_Parser.COLON)
            self.state = 538
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,52,self._ctx)
            if la_ == 1:
                self.state = 533
                self.ind()
                self.state = 534
                self.condExprBody()
                self.state = 535
=======
            self.state = 526
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,53,self._ctx)
            if la_ == 1:
                self.state = 525
>>>>>>> rev1
                self.ded()
                pass

            elif la_ == 2:
                self.state = 537
                self.condExprBody()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class CaseExprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CASE(self):
            return self.getToken(nim_Parser.CASE, 0)

        def simpleExpr(self):
            return self.getTypedRuleContext(nim_Parser.SimpleExprContext,0)


        def expr(self):
            return self.getTypedRuleContext(nim_Parser.ExprContext,0)


        def ofBranches(self):
            return self.getTypedRuleContext(nim_Parser.OfBranchesContext,0)


        def ind(self):
            return self.getTypedRuleContext(nim_Parser.IndContext,0)


        def ded(self):
            return self.getTypedRuleContext(nim_Parser.DedContext,0)


        def getRuleIndex(self):
            return nim_Parser.RULE_caseExpr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCaseExpr" ):
                listener.enterCaseExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCaseExpr" ):
                listener.exitCaseExpr(self)




    def caseExpr(self):

        localctx = nim_Parser.CaseExprContext(self, self._ctx, self.state)
<<<<<<< HEAD
        self.enterRule(localctx, 96, self.RULE_caseExpr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 540
            self.match(nim_Parser.CASE)
            self.state = 543
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,53,self._ctx)
            if la_ == 1:
                self.state = 541
=======
        self.enterRule(localctx, 88, self.RULE_caseExpr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 528
            self.match(nim_Parser.CASE)
            self.state = 531
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,54,self._ctx)
            if la_ == 1:
                self.state = 529
>>>>>>> rev1
                self.simpleExpr()
                pass

            elif la_ == 2:
<<<<<<< HEAD
                self.state = 542
=======
                self.state = 530
>>>>>>> rev1
                self.expr()
                pass


<<<<<<< HEAD
            self.state = 550
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [nim_Parser.INDENT]:
                self.state = 545
                self.ind()
                self.state = 546
                self.ofBranches()
                self.state = 547
                self.ded()
                pass
            elif token in [nim_Parser.OF]:
                self.state = 549
=======
            self.state = 538
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [nim_Parser.INDENT]:
                self.state = 533
                self.ind()
                self.state = 534
                self.ofBranches()
                self.state = 535
                self.ded()
                pass
            elif token in [nim_Parser.OF]:
                self.state = 537
>>>>>>> rev1
                self.ofBranches()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class WhenExprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WHEN(self):
            return self.getToken(nim_Parser.WHEN, 0)

        def condExpr(self):
            return self.getTypedRuleContext(nim_Parser.CondExprContext,0)


        def getRuleIndex(self):
            return nim_Parser.RULE_whenExpr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWhenExpr" ):
                listener.enterWhenExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWhenExpr" ):
                listener.exitWhenExpr(self)




    def whenExpr(self):

        localctx = nim_Parser.WhenExprContext(self, self._ctx, self.state)
<<<<<<< HEAD
        self.enterRule(localctx, 98, self.RULE_whenExpr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 552
            self.match(nim_Parser.WHEN)
            self.state = 553
=======
        self.enterRule(localctx, 90, self.RULE_whenExpr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 540
            self.match(nim_Parser.WHEN)
            self.state = 541
>>>>>>> rev1
            self.condExpr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class IfExprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IF(self):
            return self.getToken(nim_Parser.IF, 0)

        def condExpr(self):
            return self.getTypedRuleContext(nim_Parser.CondExprContext,0)


        def NOT(self):
            return self.getToken(nim_Parser.NOT, 0)

        def getRuleIndex(self):
            return nim_Parser.RULE_ifExpr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIfExpr" ):
                listener.enterIfExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIfExpr" ):
                listener.exitIfExpr(self)




    def ifExpr(self):

        localctx = nim_Parser.IfExprContext(self, self._ctx, self.state)
<<<<<<< HEAD
        self.enterRule(localctx, 100, self.RULE_ifExpr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 555
            self.match(nim_Parser.IF)
            self.state = 557
=======
        self.enterRule(localctx, 92, self.RULE_ifExpr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 543
            self.match(nim_Parser.IF)
            self.state = 545
>>>>>>> rev1
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,56,self._ctx)
            if la_ == 1:
<<<<<<< HEAD
                self.state = 556
                self.match(nim_Parser.NOT)


            self.state = 559
=======
                self.state = 544
                self.match(nim_Parser.NOT)


            self.state = 547
>>>>>>> rev1
            self.condExpr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

<<<<<<< HEAD
=======

>>>>>>> rev1
    class ExprListContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def simpleExpr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nim_Parser.SimpleExprContext)
            else:
                return self.getTypedRuleContext(nim_Parser.SimpleExprContext,i)
<<<<<<< HEAD


        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nim_Parser.ExprContext)
            else:
                return self.getTypedRuleContext(nim_Parser.ExprContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(nim_Parser.COMMA)
            else:
                return self.getToken(nim_Parser.COMMA, i)

        def getRuleIndex(self):
            return nim_Parser.RULE_exprList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExprList" ):
                listener.enterExprList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExprList" ):
                listener.exitExprList(self)




    def exprList(self):

        localctx = nim_Parser.ExprListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 102, self.RULE_exprList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 563
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,56,self._ctx)
            if la_ == 1:
                self.state = 561
                self.simpleExpr()
                pass

            elif la_ == 2:
                self.state = 562
                self.expr()
                pass


            self.state = 572
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==nim_Parser.COMMA:
                self.state = 565
                self.match(nim_Parser.COMMA)
                self.state = 568
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,57,self._ctx)
                if la_ == 1:
                    self.state = 566
=======


        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nim_Parser.ExprContext)
            else:
                return self.getTypedRuleContext(nim_Parser.ExprContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(nim_Parser.COMMA)
            else:
                return self.getToken(nim_Parser.COMMA, i)

        def getRuleIndex(self):
            return nim_Parser.RULE_exprList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExprList" ):
                listener.enterExprList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExprList" ):
                listener.exitExprList(self)




    def exprList(self):

        localctx = nim_Parser.ExprListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 94, self.RULE_exprList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 551
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,57,self._ctx)
            if la_ == 1:
                self.state = 549
                self.simpleExpr()
                pass

            elif la_ == 2:
                self.state = 550
                self.expr()
                pass


            self.state = 560
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==nim_Parser.COMMA:
                self.state = 553
                self.match(nim_Parser.COMMA)
                self.state = 556
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,58,self._ctx)
                if la_ == 1:
                    self.state = 554
>>>>>>> rev1
                    self.simpleExpr()
                    pass

                elif la_ == 2:
<<<<<<< HEAD
                    self.state = 567
=======
                    self.state = 555
>>>>>>> rev1
                    self.expr()
                    pass


<<<<<<< HEAD
                self.state = 574
=======
                self.state = 562
>>>>>>> rev1
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

<<<<<<< HEAD
=======

>>>>>>> rev1
    class OfBranchContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OF(self):
            return self.getToken(nim_Parser.OF, 0)

        def exprList(self):
            return self.getTypedRuleContext(nim_Parser.ExprListContext,0)


        def COLON(self):
            return self.getToken(nim_Parser.COLON, 0)

        def ind(self):
            return self.getTypedRuleContext(nim_Parser.IndContext,0)

<<<<<<< HEAD

        def ded(self):
            return self.getTypedRuleContext(nim_Parser.DedContext,0)
=======
        def exprStmt(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nim_Parser.ExprStmtContext)
            else:
                return self.getTypedRuleContext(nim_Parser.ExprStmtContext,i)


        def ded(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nim_Parser.DedContext)
            else:
                return self.getTypedRuleContext(nim_Parser.DedContext,i)
>>>>>>> rev1


        def stmt(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nim_Parser.StmtContext)
            else:
                return self.getTypedRuleContext(nim_Parser.StmtContext,i)


<<<<<<< HEAD
        def stmt(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nim_Parser.StmtContext)
            else:
                return self.getTypedRuleContext(nim_Parser.StmtContext,i)
=======
        def ind(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nim_Parser.IndContext)
            else:
                return self.getTypedRuleContext(nim_Parser.IndContext,i)
>>>>>>> rev1


        def getRuleIndex(self):
            return nim_Parser.RULE_ofBranch

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOfBranch" ):
                listener.enterOfBranch(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOfBranch" ):
                listener.exitOfBranch(self)




    def ofBranch(self):

        localctx = nim_Parser.OfBranchContext(self, self._ctx, self.state)
<<<<<<< HEAD
        self.enterRule(localctx, 104, self.RULE_ofBranch)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 575
            self.match(nim_Parser.OF)
            self.state = 576
            self.exprList()
            self.state = 577
            self.match(nim_Parser.COLON)
            self.state = 591
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,62,self._ctx)
            if la_ == 1:
                self.state = 578
                self.ind()
                self.state = 581 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 581
                        self._errHandler.sync(self)
                        la_ = self._interp.adaptivePredict(self._input,59,self._ctx)
                        if la_ == 1:
                            self.state = 579
                            self.exprStmt()
                            pass

                        elif la_ == 2:
                            self.state = 580
                            self.stmt()
                            pass


=======
        self.enterRule(localctx, 96, self.RULE_ofBranch)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 563
            self.match(nim_Parser.OF)
            self.state = 564
            self.exprList()
            self.state = 565
            self.match(nim_Parser.COLON)
            self.state = 566
            self.optInd()
            self.state = 575 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 575
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,61,self._ctx)
                    if la_ == 1:
                        self.state = 567
                        self.exprStmt()
                        pass

                    elif la_ == 2:
                        self.state = 573
                        self._errHandler.sync(self)
                        la_ = self._interp.adaptivePredict(self._input,60,self._ctx)
                        if la_ == 1:
                            self.state = 568
                            self.stmt()
                            pass

                        elif la_ == 2:
                            self.state = 569
                            self.ind()
                            self.state = 570
                            self.stmt()
                            self.state = 571
                            self.ded()
                            pass


                        pass
>>>>>>> rev1

                    else:
                        raise NoViableAltException(self)
                    self.state = 583 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,60,self._ctx)

                self.state = 585
                self.ded()
                pass

<<<<<<< HEAD
            elif la_ == 2:
                self.state = 589
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,61,self._ctx)
                if la_ == 1:
                    self.state = 587
                    self.exprStmt()
                    pass

                elif la_ == 2:
                    self.state = 588
                    self.stmt()
                    pass


                pass
=======
                else:
                    raise NoViableAltException(self)
                self.state = 577 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,62,self._ctx)

            self.state = 580
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,63,self._ctx)
            if la_ == 1:
                self.state = 579
                self.ded()
>>>>>>> rev1


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

<<<<<<< HEAD
=======

>>>>>>> rev1
    class OfBranchesContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ofBranch(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nim_Parser.OfBranchContext)
            else:
                return self.getTypedRuleContext(nim_Parser.OfBranchContext,i)
<<<<<<< HEAD


        def ELSE(self):
            return self.getToken(nim_Parser.ELSE, 0)

        def COLON(self):
            return self.getToken(nim_Parser.COLON, 0)
=======


        def ELSE(self):
            return self.getToken(nim_Parser.ELSE, 0)

        def COLON(self):
            return self.getToken(nim_Parser.COLON, 0)

        def optInd(self):
            return self.getTypedRuleContext(nim_Parser.OptIndContext,0)
>>>>>>> rev1

        def ind(self):
            return self.getTypedRuleContext(nim_Parser.IndContext,0)

<<<<<<< HEAD

        def ded(self):
            return self.getTypedRuleContext(nim_Parser.DedContext,0)
=======
        def exprStmt(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nim_Parser.ExprStmtContext)
            else:
                return self.getTypedRuleContext(nim_Parser.ExprStmtContext,i)
>>>>>>> rev1


        def ded(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nim_Parser.DedContext)
            else:
                return self.getTypedRuleContext(nim_Parser.DedContext,i)


        def stmt(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nim_Parser.StmtContext)
            else:
                return self.getTypedRuleContext(nim_Parser.StmtContext,i)


<<<<<<< HEAD
=======
        def ind(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nim_Parser.IndContext)
            else:
                return self.getTypedRuleContext(nim_Parser.IndContext,i)


>>>>>>> rev1
        def getRuleIndex(self):
            return nim_Parser.RULE_ofBranches

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOfBranches" ):
                listener.enterOfBranches(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOfBranches" ):
                listener.exitOfBranches(self)




    def ofBranches(self):

        localctx = nim_Parser.OfBranchesContext(self, self._ctx, self.state)
<<<<<<< HEAD
        self.enterRule(localctx, 106, self.RULE_ofBranches)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 594 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 593
                self.ofBranch()
                self.state = 596 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==nim_Parser.OF):
                    break

            self.state = 615
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==nim_Parser.ELSE:
                self.state = 598
                self.match(nim_Parser.ELSE)
                self.state = 599
                self.match(nim_Parser.COLON)
                self.state = 613
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,67,self._ctx)
                if la_ == 1:
                    self.state = 600
                    self.ind()
                    self.state = 603 
                    self._errHandler.sync(self)
                    _alt = 1
                    while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                        if _alt == 1:
                            self.state = 603
                            self._errHandler.sync(self)
                            la_ = self._interp.adaptivePredict(self._input,64,self._ctx)
                            if la_ == 1:
                                self.state = 601
                                self.exprStmt()
                                pass

                            elif la_ == 2:
                                self.state = 602
                                self.stmt()
                                pass



                        else:
                            raise NoViableAltException(self)
                        self.state = 605 
                        self._errHandler.sync(self)
                        _alt = self._interp.adaptivePredict(self._input,65,self._ctx)

                    self.state = 607
                    self.ded()
                    pass

                elif la_ == 2:
                    self.state = 611
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,66,self._ctx)
                    if la_ == 1:
                        self.state = 609
                        self.exprStmt()
                        pass

                    elif la_ == 2:
                        self.state = 610
                        self.stmt()
                        pass


                    pass




        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class CaseStmtContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CASE(self):
            return self.getToken(nim_Parser.CASE, 0)

        def simpleExpr(self):
            return self.getTypedRuleContext(nim_Parser.SimpleExprContext,0)


        def expr(self):
            return self.getTypedRuleContext(nim_Parser.ExprContext,0)


        def ofBranches(self):
            return self.getTypedRuleContext(nim_Parser.OfBranchesContext,0)


        def ind(self):
            return self.getTypedRuleContext(nim_Parser.IndContext,0)


        def ded(self):
            return self.getTypedRuleContext(nim_Parser.DedContext,0)


        def getRuleIndex(self):
            return nim_Parser.RULE_caseStmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCaseStmt" ):
                listener.enterCaseStmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCaseStmt" ):
                listener.exitCaseStmt(self)




    def caseStmt(self):

        localctx = nim_Parser.CaseStmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 108, self.RULE_caseStmt)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 617
            self.match(nim_Parser.CASE)
            self.state = 620
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,69,self._ctx)
            if la_ == 1:
                self.state = 618
                self.simpleExpr()
                pass

            elif la_ == 2:
                self.state = 619
                self.expr()
                pass


            self.state = 627
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [nim_Parser.INDENT]:
                self.state = 622
                self.ind()
                self.state = 623
                self.ofBranches()
                self.state = 624
                self.ded()
                pass
            elif token in [nim_Parser.OF]:
                self.state = 626
                self.ofBranches()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class IfStmtContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IF(self):
            return self.getToken(nim_Parser.IF, 0)

        def condStmt(self):
            return self.getTypedRuleContext(nim_Parser.CondStmtContext,0)


        def NOT(self):
            return self.getToken(nim_Parser.NOT, 0)

        def getRuleIndex(self):
            return nim_Parser.RULE_ifStmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIfStmt" ):
                listener.enterIfStmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIfStmt" ):
                listener.exitIfStmt(self)




    def ifStmt(self):

        localctx = nim_Parser.IfStmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 110, self.RULE_ifStmt)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 629
            self.match(nim_Parser.IF)
            self.state = 631
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,71,self._ctx)
            if la_ == 1:
                self.state = 630
                self.match(nim_Parser.NOT)


            self.state = 633
            self.condStmt()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class WhenStmtContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WHEN(self):
            return self.getToken(nim_Parser.WHEN, 0)

        def condStmt(self):
            return self.getTypedRuleContext(nim_Parser.CondStmtContext,0)


        def NOT(self):
            return self.getToken(nim_Parser.NOT, 0)

        def getRuleIndex(self):
            return nim_Parser.RULE_whenStmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWhenStmt" ):
                listener.enterWhenStmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWhenStmt" ):
                listener.exitWhenStmt(self)




    def whenStmt(self):

        localctx = nim_Parser.WhenStmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 112, self.RULE_whenStmt)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 635
            self.match(nim_Parser.WHEN)
            self.state = 637
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,72,self._ctx)
            if la_ == 1:
                self.state = 636
                self.match(nim_Parser.NOT)


            self.state = 639
            self.condStmt()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ForStmtContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FOR(self):
            return self.getToken(nim_Parser.FOR, 0)

        def IN(self):
            return self.getToken(nim_Parser.IN, 0)

        def simpleExpr(self):
            return self.getTypedRuleContext(nim_Parser.SimpleExprContext,0)


        def COLON(self):
            return self.getToken(nim_Parser.COLON, 0)

        def IDENTIFIER(self, i:int=None):
            if i is None:
                return self.getTokens(nim_Parser.IDENTIFIER)
            else:
                return self.getToken(nim_Parser.IDENTIFIER, i)

        def ind(self):
            return self.getTypedRuleContext(nim_Parser.IndContext,0)


        def ded(self):
            return self.getTypedRuleContext(nim_Parser.DedContext,0)


        def stmt(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nim_Parser.StmtContext)
            else:
                return self.getTypedRuleContext(nim_Parser.StmtContext,i)


        def exprStmt(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nim_Parser.ExprStmtContext)
            else:
                return self.getTypedRuleContext(nim_Parser.ExprStmtContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(nim_Parser.COMMA)
            else:
                return self.getToken(nim_Parser.COMMA, i)

        def getRuleIndex(self):
            return nim_Parser.RULE_forStmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterForStmt" ):
                listener.enterForStmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitForStmt" ):
                listener.exitForStmt(self)




    def forStmt(self):

        localctx = nim_Parser.ForStmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 114, self.RULE_forStmt)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 641
            self.match(nim_Parser.FOR)

            self.state = 642
            self.match(nim_Parser.IDENTIFIER)
            self.state = 647
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==nim_Parser.COMMA:
                self.state = 643
                self.match(nim_Parser.COMMA)
                self.state = 644
                self.match(nim_Parser.IDENTIFIER)
                self.state = 649
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 650
            self.match(nim_Parser.IN)
            self.state = 651
            self.simpleExpr()
            self.state = 652
            self.match(nim_Parser.COLON)
            self.state = 666
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,77,self._ctx)
            if la_ == 1:
                self.state = 653
                self.ind()
                self.state = 656 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 656
                        self._errHandler.sync(self)
                        la_ = self._interp.adaptivePredict(self._input,74,self._ctx)
                        if la_ == 1:
                            self.state = 654
                            self.stmt()
                            pass

                        elif la_ == 2:
                            self.state = 655
                            self.exprStmt()
                            pass



                    else:
                        raise NoViableAltException(self)
                    self.state = 658 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,75,self._ctx)

                self.state = 660
                self.ded()
                pass

            elif la_ == 2:
                self.state = 664
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,76,self._ctx)
                if la_ == 1:
                    self.state = 662
                    self.stmt()
                    pass

                elif la_ == 2:
                    self.state = 663
                    self.exprStmt()
                    pass


                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class CondStmtBodyContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def exprStmt(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nim_Parser.ExprStmtContext)
            else:
                return self.getTypedRuleContext(nim_Parser.ExprStmtContext,i)


        def substmt(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nim_Parser.SubstmtContext)
            else:
                return self.getTypedRuleContext(nim_Parser.SubstmtContext,i)


        def ELIF(self, i:int=None):
            if i is None:
                return self.getTokens(nim_Parser.ELIF)
            else:
                return self.getToken(nim_Parser.ELIF, i)

        def COLON(self, i:int=None):
            if i is None:
                return self.getTokens(nim_Parser.COLON)
            else:
                return self.getToken(nim_Parser.COLON, i)

        def ELSE(self):
            return self.getToken(nim_Parser.ELSE, 0)

        def simpleExpr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nim_Parser.SimpleExprContext)
            else:
                return self.getTypedRuleContext(nim_Parser.SimpleExprContext,i)


        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nim_Parser.ExprContext)
            else:
                return self.getTypedRuleContext(nim_Parser.ExprContext,i)


        def ind(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nim_Parser.IndContext)
            else:
                return self.getTypedRuleContext(nim_Parser.IndContext,i)


        def ded(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nim_Parser.DedContext)
            else:
                return self.getTypedRuleContext(nim_Parser.DedContext,i)


        def getRuleIndex(self):
            return nim_Parser.RULE_condStmtBody

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCondStmtBody" ):
                listener.enterCondStmtBody(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCondStmtBody" ):
                listener.exitCondStmtBody(self)




    def condStmtBody(self):

        localctx = nim_Parser.CondStmtBodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 116, self.RULE_condStmtBody)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 670
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,78,self._ctx)
            if la_ == 1:
                self.state = 668
                self.exprStmt()
                pass

            elif la_ == 2:
                self.state = 669
                self.substmt()
                pass


            self.state = 701
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,85,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 672
                    self.match(nim_Parser.ELIF)
                    self.state = 675
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,79,self._ctx)
                    if la_ == 1:
                        self.state = 673
                        self.simpleExpr()
                        pass

                    elif la_ == 2:
                        self.state = 674
                        self.expr()
                        pass


                    self.state = 677
                    self.match(nim_Parser.COLON)
                    self.state = 697
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,84,self._ctx)
                    if la_ == 1:
                        self.state = 678
                        self.ind()
                        self.state = 685
                        self._errHandler.sync(self)
                        la_ = self._interp.adaptivePredict(self._input,81,self._ctx)
                        if la_ == 1:
                            self.state = 680 
                            self._errHandler.sync(self)
                            _alt = 1
                            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                                if _alt == 1:
                                    self.state = 679
                                    self.exprStmt()

                                else:
                                    raise NoViableAltException(self)
                                self.state = 682 
                                self._errHandler.sync(self)
                                _alt = self._interp.adaptivePredict(self._input,80,self._ctx)

                            pass

                        elif la_ == 2:
                            self.state = 684
                            self.substmt()
                            pass


                        self.state = 687
                        self.ded()
                        pass

                    elif la_ == 2:
                        self.state = 695
                        self._errHandler.sync(self)
                        la_ = self._interp.adaptivePredict(self._input,83,self._ctx)
                        if la_ == 1:
                            self.state = 690 
                            self._errHandler.sync(self)
                            _alt = 1
                            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                                if _alt == 1:
                                    self.state = 689
                                    self.exprStmt()

                                else:
                                    raise NoViableAltException(self)
                                self.state = 692 
                                self._errHandler.sync(self)
                                _alt = self._interp.adaptivePredict(self._input,82,self._ctx)

                            pass

                        elif la_ == 2:
                            self.state = 694
                            self.substmt()
                            pass


                        pass

             
                self.state = 703
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,85,self._ctx)

            self.state = 727
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,91,self._ctx)
            if la_ == 1:
                self.state = 704
                self.match(nim_Parser.ELSE)
                self.state = 705
                self.match(nim_Parser.COLON)
                self.state = 725
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,90,self._ctx)
                if la_ == 1:
                    self.state = 706
                    self.ind()
                    self.state = 713
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,87,self._ctx)
                    if la_ == 1:
                        self.state = 708 
                        self._errHandler.sync(self)
                        _alt = 1
                        while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                            if _alt == 1:
                                self.state = 707
                                self.exprStmt()

                            else:
                                raise NoViableAltException(self)
                            self.state = 710 
                            self._errHandler.sync(self)
                            _alt = self._interp.adaptivePredict(self._input,86,self._ctx)

                        pass

                    elif la_ == 2:
                        self.state = 712
                        self.substmt()
                        pass


                    self.state = 715
                    self.ded()
                    pass

                elif la_ == 2:
                    self.state = 723
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,89,self._ctx)
                    if la_ == 1:
                        self.state = 718 
                        self._errHandler.sync(self)
                        _alt = 1
                        while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                            if _alt == 1:
                                self.state = 717
                                self.exprStmt()

                            else:
                                raise NoViableAltException(self)
                            self.state = 720 
                            self._errHandler.sync(self)
                            _alt = self._interp.adaptivePredict(self._input,88,self._ctx)

                        pass

                    elif la_ == 2:
                        self.state = 722
                        self.substmt()
                        pass


                    pass




        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class CondStmtContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COLON(self):
            return self.getToken(nim_Parser.COLON, 0)

        def simpleExpr(self):
            return self.getTypedRuleContext(nim_Parser.SimpleExprContext,0)


        def expr(self):
            return self.getTypedRuleContext(nim_Parser.ExprContext,0)


        def ind(self):
            return self.getTypedRuleContext(nim_Parser.IndContext,0)


        def condStmtBody(self):
            return self.getTypedRuleContext(nim_Parser.CondStmtBodyContext,0)


        def ded(self):
            return self.getTypedRuleContext(nim_Parser.DedContext,0)


        def getRuleIndex(self):
            return nim_Parser.RULE_condStmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCondStmt" ):
                listener.enterCondStmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCondStmt" ):
                listener.exitCondStmt(self)




    def condStmt(self):

        localctx = nim_Parser.CondStmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 118, self.RULE_condStmt)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 731
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,92,self._ctx)
            if la_ == 1:
                self.state = 729
                self.simpleExpr()
                pass

            elif la_ == 2:
                self.state = 730
                self.expr()
                pass


            self.state = 733
            self.match(nim_Parser.COLON)
            self.state = 739
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,93,self._ctx)
            if la_ == 1:
                self.state = 734
                self.ind()
                self.state = 735
                self.condStmtBody()
                self.state = 736
                self.ded()
                pass

            elif la_ == 2:
                self.state = 738
                self.condStmtBody()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class BlockStmtContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BLOCK(self):
            return self.getToken(nim_Parser.BLOCK, 0)

        def COLON(self):
            return self.getToken(nim_Parser.COLON, 0)

        def ind(self):
            return self.getTypedRuleContext(nim_Parser.IndContext,0)


        def stmt(self):
            return self.getTypedRuleContext(nim_Parser.StmtContext,0)


        def ded(self):
            return self.getTypedRuleContext(nim_Parser.DedContext,0)


        def symbol(self):
            return self.getTypedRuleContext(nim_Parser.SymbolContext,0)


        def getRuleIndex(self):
            return nim_Parser.RULE_blockStmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBlockStmt" ):
                listener.enterBlockStmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBlockStmt" ):
                listener.exitBlockStmt(self)




    def blockStmt(self):
=======
        self.enterRule(localctx, 98, self.RULE_ofBranches)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 583 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 582
                    self.ofBranch()

                else:
                    raise NoViableAltException(self)
                self.state = 585 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,64,self._ctx)

            self.state = 605
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,69,self._ctx)
            if la_ == 1:
                self.state = 587
                self.match(nim_Parser.ELSE)
                self.state = 588
                self.match(nim_Parser.COLON)
                self.state = 589
                self.optInd()
                self.state = 598 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 598
                        self._errHandler.sync(self)
                        la_ = self._interp.adaptivePredict(self._input,66,self._ctx)
                        if la_ == 1:
                            self.state = 590
                            self.exprStmt()
                            pass

                        elif la_ == 2:
                            self.state = 596
                            self._errHandler.sync(self)
                            la_ = self._interp.adaptivePredict(self._input,65,self._ctx)
                            if la_ == 1:
                                self.state = 591
                                self.stmt()
                                pass

                            elif la_ == 2:
                                self.state = 592
                                self.ind()
                                self.state = 593
                                self.stmt()
                                self.state = 594
                                self.ded()
                                pass


                            pass



                    else:
                        raise NoViableAltException(self)
                    self.state = 600 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,67,self._ctx)

                self.state = 603
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,68,self._ctx)
                if la_ == 1:
                    self.state = 602
                    self.ded()
>>>>>>> rev1

        localctx = nim_Parser.BlockStmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 120, self.RULE_blockStmt)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 741
            self.match(nim_Parser.BLOCK)
            self.state = 743
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,94,self._ctx)
            if la_ == 1:
                self.state = 742
                self.symbol()


            self.state = 745
            self.match(nim_Parser.COLON)
            self.state = 751
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [nim_Parser.INDENT]:
                self.state = 746
                self.ind()
                self.state = 747
                self.stmt()
                self.state = 748
                self.ded()
                pass
            elif token in [nim_Parser.OPEN_BRACE, nim_Parser.TYPE, nim_Parser.VARIABLE, nim_Parser.LET, nim_Parser.CONST, nim_Parser.PROC, nim_Parser.IF, nim_Parser.FOR, nim_Parser.TEMPLATE, nim_Parser.WHEN, nim_Parser.IMPORT, nim_Parser.FROM, nim_Parser.BLOCK, nim_Parser.MACRO]:
                self.state = 750
                self.stmt()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

<<<<<<< HEAD
    class PragmaStmtContext(ParserRuleContext):
=======

    class CaseStmtContext(ParserRuleContext):
>>>>>>> rev1

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

<<<<<<< HEAD
        def pragma(self):
            return self.getTypedRuleContext(nim_Parser.PragmaContext,0)


        def getRuleIndex(self):
            return nim_Parser.RULE_pragmaStmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPragmaStmt" ):
                listener.enterPragmaStmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPragmaStmt" ):
                listener.exitPragmaStmt(self)
=======
        def CASE(self):
            return self.getToken(nim_Parser.CASE, 0)

        def simpleExpr(self):
            return self.getTypedRuleContext(nim_Parser.SimpleExprContext,0)
>>>>>>> rev1


        def expr(self):
            return self.getTypedRuleContext(nim_Parser.ExprContext,0)


<<<<<<< HEAD
    def pragmaStmt(self):

        localctx = nim_Parser.PragmaStmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 122, self.RULE_pragmaStmt)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 753
            self.pragma()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ExprContext(ParserRuleContext):
=======
        def ofBranches(self):
            return self.getTypedRuleContext(nim_Parser.OfBranchesContext,0)


        def ind(self):
            return self.getTypedRuleContext(nim_Parser.IndContext,0)

>>>>>>> rev1

        def ded(self):
            return self.getTypedRuleContext(nim_Parser.DedContext,0)

<<<<<<< HEAD
        def blockExpr(self):
            return self.getTypedRuleContext(nim_Parser.BlockExprContext,0)


        def forExpr(self):
            return self.getTypedRuleContext(nim_Parser.ForExprContext,0)


        def ifExpr(self):
            return self.getTypedRuleContext(nim_Parser.IfExprContext,0)


        def whenExpr(self):
            return self.getTypedRuleContext(nim_Parser.WhenExprContext,0)


        def getRuleIndex(self):
            return nim_Parser.RULE_expr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpr" ):
                listener.enterExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpr" ):
                listener.exitExpr(self)
=======

        def getRuleIndex(self):
            return nim_Parser.RULE_caseStmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCaseStmt" ):
                listener.enterCaseStmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCaseStmt" ):
                listener.exitCaseStmt(self)
>>>>>>> rev1




<<<<<<< HEAD
    def expr(self):

        localctx = nim_Parser.ExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 124, self.RULE_expr)
        try:
            self.state = 759
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [nim_Parser.BLOCK]:
                self.enterOuterAlt(localctx, 1)
                self.state = 755
                self.blockExpr()
                pass
            elif token in [nim_Parser.FOR]:
                self.enterOuterAlt(localctx, 2)
                self.state = 756
                self.forExpr()
                pass
            elif token in [nim_Parser.IF]:
                self.enterOuterAlt(localctx, 3)
                self.state = 757
                self.ifExpr()
                pass
            elif token in [nim_Parser.WHEN]:
                self.enterOuterAlt(localctx, 4)
                self.state = 758
                self.whenExpr()
=======
    def caseStmt(self):

        localctx = nim_Parser.CaseStmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 100, self.RULE_caseStmt)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 607
            self.match(nim_Parser.CASE)
            self.state = 610
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,70,self._ctx)
            if la_ == 1:
                self.state = 608
                self.simpleExpr()
                pass

            elif la_ == 2:
                self.state = 609
                self.expr()
                pass


            self.state = 617
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [nim_Parser.INDENT]:
                self.state = 612
                self.ind()
                self.state = 613
                self.ofBranches()
                self.state = 614
                self.ded()
                pass
            elif token in [nim_Parser.OF]:
                self.state = 616
                self.ofBranches()
>>>>>>> rev1
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

<<<<<<< HEAD
    class PragmaContext(ParserRuleContext):
=======

    class IfStmtContext(ParserRuleContext):
>>>>>>> rev1

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

<<<<<<< HEAD
        def OPEN_BRACE(self):
            return self.getToken(nim_Parser.OPEN_BRACE, 0)

        def DOT(self, i:int=None):
            if i is None:
                return self.getTokens(nim_Parser.DOT)
            else:
                return self.getToken(nim_Parser.DOT, i)

        def IDENTIFIER(self):
            return self.getToken(nim_Parser.IDENTIFIER, 0)

        def CLOSE_BRACE(self):
            return self.getToken(nim_Parser.CLOSE_BRACE, 0)

        def getRuleIndex(self):
            return nim_Parser.RULE_pragma

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPragma" ):
                listener.enterPragma(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPragma" ):
                listener.exitPragma(self)
=======
        def IF(self):
            return self.getToken(nim_Parser.IF, 0)

        def condStmt(self):
            return self.getTypedRuleContext(nim_Parser.CondStmtContext,0)


        def NOT(self):
            return self.getToken(nim_Parser.NOT, 0)

        def getRuleIndex(self):
            return nim_Parser.RULE_ifStmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIfStmt" ):
                listener.enterIfStmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIfStmt" ):
                listener.exitIfStmt(self)
>>>>>>> rev1




<<<<<<< HEAD
    def pragma(self):

        localctx = nim_Parser.PragmaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 126, self.RULE_pragma)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 761
            self.match(nim_Parser.OPEN_BRACE)
            self.state = 762
            self.match(nim_Parser.DOT)
            self.state = 763
            self.match(nim_Parser.IDENTIFIER)
            self.state = 765
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==nim_Parser.DOT:
                self.state = 764
                self.match(nim_Parser.DOT)


            self.state = 767
            self.match(nim_Parser.CLOSE_BRACE)
=======
    def ifStmt(self):

        localctx = nim_Parser.IfStmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 102, self.RULE_ifStmt)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 619
            self.match(nim_Parser.IF)
            self.state = 621
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,72,self._ctx)
            if la_ == 1:
                self.state = 620
                self.match(nim_Parser.NOT)


            self.state = 623
            self.condStmt()
>>>>>>> rev1
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

<<<<<<< HEAD
    class RoutineContext(ParserRuleContext):
=======

    class WhenStmtContext(ParserRuleContext):
>>>>>>> rev1

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

<<<<<<< HEAD
        def par(self):
            return self.getTypedRuleContext(nim_Parser.ParContext,0)

=======
        def WHEN(self):
            return self.getToken(nim_Parser.WHEN, 0)

        def condStmt(self):
            return self.getTypedRuleContext(nim_Parser.CondStmtContext,0)


        def NOT(self):
            return self.getToken(nim_Parser.NOT, 0)

        def getRuleIndex(self):
            return nim_Parser.RULE_whenStmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWhenStmt" ):
                listener.enterWhenStmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWhenStmt" ):
                listener.exitWhenStmt(self)




    def whenStmt(self):

        localctx = nim_Parser.WhenStmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 104, self.RULE_whenStmt)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 625
            self.match(nim_Parser.WHEN)
            self.state = 627
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,73,self._ctx)
            if la_ == 1:
                self.state = 626
                self.match(nim_Parser.NOT)


            self.state = 629
            self.condStmt()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ForStmtContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FOR(self):
            return self.getToken(nim_Parser.FOR, 0)

        def IN(self):
            return self.getToken(nim_Parser.IN, 0)

        def simpleExpr(self):
            return self.getTypedRuleContext(nim_Parser.SimpleExprContext,0)


        def COLON(self):
            return self.getToken(nim_Parser.COLON, 0)

        def optInd(self):
            return self.getTypedRuleContext(nim_Parser.OptIndContext,0)
>>>>>>> rev1

        def COLON(self, i:int=None):
            if i is None:
                return self.getTokens(nim_Parser.COLON)
            else:
                return self.getToken(nim_Parser.COLON, i)

<<<<<<< HEAD
        def substmt(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nim_Parser.SubstmtContext)
            else:
                return self.getTypedRuleContext(nim_Parser.SubstmtContext,i)
=======
        def IDENTIFIER(self, i:int=None):
            if i is None:
                return self.getTokens(nim_Parser.IDENTIFIER)
            else:
                return self.getToken(nim_Parser.IDENTIFIER, i)

        def exprStmt(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nim_Parser.ExprStmtContext)
            else:
                return self.getTypedRuleContext(nim_Parser.ExprStmtContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(nim_Parser.COMMA)
            else:
                return self.getToken(nim_Parser.COMMA, i)

        def stmt(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nim_Parser.StmtContext)
            else:
                return self.getTypedRuleContext(nim_Parser.StmtContext,i)


        def ind(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nim_Parser.IndContext)
            else:
                return self.getTypedRuleContext(nim_Parser.IndContext,i)


        def ded(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nim_Parser.DedContext)
            else:
                return self.getTypedRuleContext(nim_Parser.DedContext,i)


        def getRuleIndex(self):
            return nim_Parser.RULE_forStmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterForStmt" ):
                listener.enterForStmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitForStmt" ):
                listener.exitForStmt(self)




    def forStmt(self):

        localctx = nim_Parser.ForStmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 106, self.RULE_forStmt)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 631
            self.match(nim_Parser.FOR)

            self.state = 632
            self.match(nim_Parser.IDENTIFIER)
            self.state = 637
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==nim_Parser.COMMA:
                self.state = 633
                self.match(nim_Parser.COMMA)
                self.state = 634
                self.match(nim_Parser.IDENTIFIER)
                self.state = 639
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 640
            self.match(nim_Parser.IN)
            self.state = 641
            self.simpleExpr()
            self.state = 642
            self.match(nim_Parser.COLON)
            self.state = 643
            self.optInd()
            self.state = 652 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 652
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,76,self._ctx)
                    if la_ == 1:
                        self.state = 649
                        self._errHandler.sync(self)
                        la_ = self._interp.adaptivePredict(self._input,75,self._ctx)
                        if la_ == 1:
                            self.state = 644
                            self.stmt()
                            pass

                        elif la_ == 2:
                            self.state = 645
                            self.ind()
                            self.state = 646
                            self.stmt()
                            self.state = 647
                            self.ded()
                            pass


                        pass

                    elif la_ == 2:
                        self.state = 651
                        self.exprStmt()
                        pass



                else:
                    raise NoViableAltException(self)
                self.state = 654 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,77,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CondStmtContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COLON(self, i:int=None):
            if i is None:
                return self.getTokens(nim_Parser.COLON)
            else:
                return self.getToken(nim_Parser.COLON, i)

        def optInd(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nim_Parser.OptIndContext)
            else:
                return self.getTypedRuleContext(nim_Parser.OptIndContext,i)


        def ELIF(self, i:int=None):
            if i is None:
                return self.getTokens(nim_Parser.ELIF)
            else:
                return self.getToken(nim_Parser.ELIF, i)

        def ELSE(self):
            return self.getToken(nim_Parser.ELSE, 0)

        def simpleExpr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nim_Parser.SimpleExprContext)
            else:
                return self.getTypedRuleContext(nim_Parser.SimpleExprContext,i)


        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nim_Parser.ExprContext)
            else:
                return self.getTypedRuleContext(nim_Parser.ExprContext,i)


        def exprStmt(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nim_Parser.ExprStmtContext)
            else:
                return self.getTypedRuleContext(nim_Parser.ExprStmtContext,i)


        def ded(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nim_Parser.DedContext)
            else:
                return self.getTypedRuleContext(nim_Parser.DedContext,i)


        def stmt(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nim_Parser.StmtContext)
            else:
                return self.getTypedRuleContext(nim_Parser.StmtContext,i)


        def ind(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nim_Parser.IndContext)
            else:
                return self.getTypedRuleContext(nim_Parser.IndContext,i)


        def getRuleIndex(self):
            return nim_Parser.RULE_condStmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCondStmt" ):
                listener.enterCondStmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCondStmt" ):
                listener.exitCondStmt(self)




    def condStmt(self):

        localctx = nim_Parser.CondStmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 108, self.RULE_condStmt)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 658
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,78,self._ctx)
            if la_ == 1:
                self.state = 656
                self.simpleExpr()
                pass

            elif la_ == 2:
                self.state = 657
                self.expr()
                pass


            self.state = 660
            self.match(nim_Parser.COLON)
            self.state = 661
            self.optInd()
            self.state = 670 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 670
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,80,self._ctx)
                    if la_ == 1:
                        self.state = 662
                        self.exprStmt()
                        pass

                    elif la_ == 2:
                        self.state = 668
                        self._errHandler.sync(self)
                        la_ = self._interp.adaptivePredict(self._input,79,self._ctx)
                        if la_ == 1:
                            self.state = 663
                            self.stmt()
                            pass

                        elif la_ == 2:
                            self.state = 664
                            self.ind()
                            self.state = 665
                            self.stmt()
                            self.state = 666
                            self.ded()
                            pass


                        pass



                else:
                    raise NoViableAltException(self)
                self.state = 672 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,81,self._ctx)

            self.state = 675
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,82,self._ctx)
            if la_ == 1:
                self.state = 674
                self.ded()


            self.state = 701
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,88,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 677
                    self.match(nim_Parser.ELIF)
                    self.state = 680
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,83,self._ctx)
                    if la_ == 1:
                        self.state = 678
                        self.simpleExpr()
                        pass

                    elif la_ == 2:
                        self.state = 679
                        self.expr()
                        pass


                    self.state = 682
                    self.match(nim_Parser.COLON)
                    self.state = 683
                    self.optInd()
                    self.state = 692 
                    self._errHandler.sync(self)
                    _alt = 1
                    while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                        if _alt == 1:
                            self.state = 692
                            self._errHandler.sync(self)
                            la_ = self._interp.adaptivePredict(self._input,85,self._ctx)
                            if la_ == 1:
                                self.state = 684
                                self.exprStmt()
                                pass

                            elif la_ == 2:
                                self.state = 690
                                self._errHandler.sync(self)
                                la_ = self._interp.adaptivePredict(self._input,84,self._ctx)
                                if la_ == 1:
                                    self.state = 685
                                    self.stmt()
                                    pass

                                elif la_ == 2:
                                    self.state = 686
                                    self.ind()
                                    self.state = 687
                                    self.stmt()
                                    self.state = 688
                                    self.ded()
                                    pass


                                pass



                        else:
                            raise NoViableAltException(self)
                        self.state = 694 
                        self._errHandler.sync(self)
                        _alt = self._interp.adaptivePredict(self._input,86,self._ctx)

                    self.state = 697
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,87,self._ctx)
                    if la_ == 1:
                        self.state = 696
                        self.ded()

             
                self.state = 703
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,88,self._ctx)

            self.state = 722
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,93,self._ctx)
            if la_ == 1:
                self.state = 704
                self.match(nim_Parser.ELSE)
                self.state = 705
                self.match(nim_Parser.COLON)
                self.state = 706
                self.optInd()
                self.state = 715 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 715
                        self._errHandler.sync(self)
                        la_ = self._interp.adaptivePredict(self._input,90,self._ctx)
                        if la_ == 1:
                            self.state = 707
                            self.exprStmt()
                            pass

                        elif la_ == 2:
                            self.state = 713
                            self._errHandler.sync(self)
                            la_ = self._interp.adaptivePredict(self._input,89,self._ctx)
                            if la_ == 1:
                                self.state = 708
                                self.stmt()
                                pass

                            elif la_ == 2:
                                self.state = 709
                                self.ind()
                                self.state = 710
                                self.stmt()
                                self.state = 711
                                self.ded()
                                pass


                            pass



                    else:
                        raise NoViableAltException(self)
                    self.state = 717 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,91,self._ctx)

                self.state = 720
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,92,self._ctx)
                if la_ == 1:
                    self.state = 719
                    self.ded()




        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WhileStmtContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WHILE(self):
            return self.getToken(nim_Parser.WHILE, 0)

        def COLON(self):
            return self.getToken(nim_Parser.COLON, 0)

        def optInd(self):
            return self.getTypedRuleContext(nim_Parser.OptIndContext,0)


        def simpleExpr(self):
            return self.getTypedRuleContext(nim_Parser.SimpleExprContext,0)


        def expr(self):
            return self.getTypedRuleContext(nim_Parser.ExprContext,0)


        def exprStmt(self):
            return self.getTypedRuleContext(nim_Parser.ExprStmtContext,0)


        def ded(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nim_Parser.DedContext)
            else:
                return self.getTypedRuleContext(nim_Parser.DedContext,i)


        def stmt(self):
            return self.getTypedRuleContext(nim_Parser.StmtContext,0)


        def ind(self):
            return self.getTypedRuleContext(nim_Parser.IndContext,0)


        def getRuleIndex(self):
            return nim_Parser.RULE_whileStmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWhileStmt" ):
                listener.enterWhileStmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWhileStmt" ):
                listener.exitWhileStmt(self)




    def whileStmt(self):

        localctx = nim_Parser.WhileStmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 110, self.RULE_whileStmt)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 724
            self.match(nim_Parser.WHILE)
            self.state = 727
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,94,self._ctx)
            if la_ == 1:
                self.state = 725
                self.simpleExpr()
                pass

            elif la_ == 2:
                self.state = 726
                self.expr()
                pass


            self.state = 729
            self.match(nim_Parser.COLON)
            self.state = 730
            self.optInd()
            self.state = 739
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,96,self._ctx)
            if la_ == 1:
                self.state = 731
                self.exprStmt()
                pass

            elif la_ == 2:
                self.state = 737
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,95,self._ctx)
                if la_ == 1:
                    self.state = 732
                    self.stmt()
                    pass

                elif la_ == 2:
                    self.state = 733
                    self.ind()
                    self.state = 734
                    self.stmt()
                    self.state = 735
                    self.ded()
                    pass


                pass


            self.state = 742
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,97,self._ctx)
            if la_ == 1:
                self.state = 741
                self.ded()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ImportStmtContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IMPORT(self):
            return self.getToken(nim_Parser.IMPORT, 0)

        def optInd(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nim_Parser.OptIndContext)
            else:
                return self.getTypedRuleContext(nim_Parser.OptIndContext,i)


        def IDENTIFIER(self, i:int=None):
            if i is None:
                return self.getTokens(nim_Parser.IDENTIFIER)
            else:
                return self.getToken(nim_Parser.IDENTIFIER, i)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(nim_Parser.COMMA)
            else:
                return self.getToken(nim_Parser.COMMA, i)

        def ded(self):
            return self.getTypedRuleContext(nim_Parser.DedContext,0)


        def getRuleIndex(self):
            return nim_Parser.RULE_importStmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterImportStmt" ):
                listener.enterImportStmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitImportStmt" ):
                listener.exitImportStmt(self)




    def importStmt(self):

        localctx = nim_Parser.ImportStmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 112, self.RULE_importStmt)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 744
            self.match(nim_Parser.IMPORT)
            self.state = 745
            self.optInd()
            self.state = 746
            self.match(nim_Parser.IDENTIFIER)
            self.state = 753
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,98,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 747
                    self.match(nim_Parser.COMMA)
                    self.state = 748
                    self.optInd()
                    self.state = 749
                    self.match(nim_Parser.IDENTIFIER) 
                self.state = 755
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,98,self._ctx)

            self.state = 757
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,99,self._ctx)
            if la_ == 1:
                self.state = 756
                self.ded()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FromStmtContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FROM(self):
            return self.getToken(nim_Parser.FROM, 0)

        def optInd(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nim_Parser.OptIndContext)
            else:
                return self.getTypedRuleContext(nim_Parser.OptIndContext,i)


        def IDENTIFIER(self):
            return self.getToken(nim_Parser.IDENTIFIER, 0)

        def importStmt(self):
            return self.getTypedRuleContext(nim_Parser.ImportStmtContext,0)


        def ded(self):
            return self.getTypedRuleContext(nim_Parser.DedContext,0)


        def getRuleIndex(self):
            return nim_Parser.RULE_fromStmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFromStmt" ):
                listener.enterFromStmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFromStmt" ):
                listener.exitFromStmt(self)




    def fromStmt(self):

        localctx = nim_Parser.FromStmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 114, self.RULE_fromStmt)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 759
            self.match(nim_Parser.FROM)
            self.state = 760
            self.optInd()
            self.state = 761
            self.match(nim_Parser.IDENTIFIER)
            self.state = 762
            self.optInd()
            self.state = 763
            self.importStmt()
            self.state = 765
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,100,self._ctx)
            if la_ == 1:
                self.state = 764
                self.ded()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DiscardStmtContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DISCARD(self):
            return self.getToken(nim_Parser.DISCARD, 0)

        def simpleExpr(self):
            return self.getTypedRuleContext(nim_Parser.SimpleExprContext,0)


        def getRuleIndex(self):
            return nim_Parser.RULE_discardStmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDiscardStmt" ):
                listener.enterDiscardStmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDiscardStmt" ):
                listener.exitDiscardStmt(self)




    def discardStmt(self):

        localctx = nim_Parser.DiscardStmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 116, self.RULE_discardStmt)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 767
            self.match(nim_Parser.DISCARD)
            self.state = 769
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,101,self._ctx)
            if la_ == 1:
                self.state = 768
                self.simpleExpr()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ReturnStmtContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RETURN(self):
            return self.getToken(nim_Parser.RETURN, 0)

        def simpleExpr(self):
            return self.getTypedRuleContext(nim_Parser.SimpleExprContext,0)


        def getRuleIndex(self):
            return nim_Parser.RULE_returnStmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReturnStmt" ):
                listener.enterReturnStmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReturnStmt" ):
                listener.exitReturnStmt(self)




    def returnStmt(self):

        localctx = nim_Parser.ReturnStmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 118, self.RULE_returnStmt)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 771
            self.match(nim_Parser.RETURN)
            self.state = 773
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,102,self._ctx)
            if la_ == 1:
                self.state = 772
                self.simpleExpr()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BreakStmtContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BREAK(self):
            return self.getToken(nim_Parser.BREAK, 0)

        def simpleExpr(self):
            return self.getTypedRuleContext(nim_Parser.SimpleExprContext,0)


        def getRuleIndex(self):
            return nim_Parser.RULE_breakStmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBreakStmt" ):
                listener.enterBreakStmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBreakStmt" ):
                listener.exitBreakStmt(self)




    def breakStmt(self):

        localctx = nim_Parser.BreakStmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 120, self.RULE_breakStmt)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 775
            self.match(nim_Parser.BREAK)
            self.state = 777
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,103,self._ctx)
            if la_ == 1:
                self.state = 776
                self.simpleExpr()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BlockStmtContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BLOCK(self):
            return self.getToken(nim_Parser.BLOCK, 0)

        def COLON(self):
            return self.getToken(nim_Parser.COLON, 0)

        def optInd(self):
            return self.getTypedRuleContext(nim_Parser.OptIndContext,0)


        def symbol(self):
            return self.getTypedRuleContext(nim_Parser.SymbolContext,0)


        def stmt(self):
            return self.getTypedRuleContext(nim_Parser.StmtContext,0)


        def ded(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nim_Parser.DedContext)
            else:
                return self.getTypedRuleContext(nim_Parser.DedContext,i)


        def ind(self):
            return self.getTypedRuleContext(nim_Parser.IndContext,0)


        def getRuleIndex(self):
            return nim_Parser.RULE_blockStmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBlockStmt" ):
                listener.enterBlockStmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBlockStmt" ):
                listener.exitBlockStmt(self)




    def blockStmt(self):

        localctx = nim_Parser.BlockStmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 122, self.RULE_blockStmt)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 779
            self.match(nim_Parser.BLOCK)
            self.state = 781
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,104,self._ctx)
            if la_ == 1:
                self.state = 780
                self.symbol()


            self.state = 783
            self.match(nim_Parser.COLON)

            self.state = 784
            self.optInd()
            self.state = 790
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,105,self._ctx)
            if la_ == 1:
                self.state = 785
                self.stmt()
                pass

            elif la_ == 2:
                self.state = 786
                self.ind()
                self.state = 787
                self.stmt()
                self.state = 788
                self.ded()
                pass


            self.state = 793
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,106,self._ctx)
            if la_ == 1:
                self.state = 792
                self.ded()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PragmaStmtContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def pragma(self):
            return self.getTypedRuleContext(nim_Parser.PragmaContext,0)


        def getRuleIndex(self):
            return nim_Parser.RULE_pragmaStmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPragmaStmt" ):
                listener.enterPragmaStmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPragmaStmt" ):
                listener.exitPragmaStmt(self)




    def pragmaStmt(self):

        localctx = nim_Parser.PragmaStmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 124, self.RULE_pragmaStmt)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 795
            self.pragma()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def blockExpr(self):
            return self.getTypedRuleContext(nim_Parser.BlockExprContext,0)


        def forExpr(self):
            return self.getTypedRuleContext(nim_Parser.ForExprContext,0)


        def ifExpr(self):
            return self.getTypedRuleContext(nim_Parser.IfExprContext,0)


        def whenExpr(self):
            return self.getTypedRuleContext(nim_Parser.WhenExprContext,0)


        def caseExpr(self):
            return self.getTypedRuleContext(nim_Parser.CaseExprContext,0)


        def getRuleIndex(self):
            return nim_Parser.RULE_expr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpr" ):
                listener.enterExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpr" ):
                listener.exitExpr(self)




    def expr(self):

        localctx = nim_Parser.ExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 126, self.RULE_expr)
        try:
            self.state = 802
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [nim_Parser.BLOCK]:
                self.enterOuterAlt(localctx, 1)
                self.state = 797
                self.blockExpr()
                pass
            elif token in [nim_Parser.FOR]:
                self.enterOuterAlt(localctx, 2)
                self.state = 798
                self.forExpr()
                pass
            elif token in [nim_Parser.IF]:
                self.enterOuterAlt(localctx, 3)
                self.state = 799
                self.ifExpr()
                pass
            elif token in [nim_Parser.WHEN]:
                self.enterOuterAlt(localctx, 4)
                self.state = 800
                self.whenExpr()
                pass
            elif token in [nim_Parser.CASE]:
                self.enterOuterAlt(localctx, 5)
                self.state = 801
                self.caseExpr()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PragmaContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPEN_BRACE(self):
            return self.getToken(nim_Parser.OPEN_BRACE, 0)

        def DOT(self, i:int=None):
            if i is None:
                return self.getTokens(nim_Parser.DOT)
            else:
                return self.getToken(nim_Parser.DOT, i)

        def IDENTIFIER(self):
            return self.getToken(nim_Parser.IDENTIFIER, 0)

        def CLOSE_BRACE(self):
            return self.getToken(nim_Parser.CLOSE_BRACE, 0)

        def getRuleIndex(self):
            return nim_Parser.RULE_pragma

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPragma" ):
                listener.enterPragma(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPragma" ):
                listener.exitPragma(self)




    def pragma(self):

        localctx = nim_Parser.PragmaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 128, self.RULE_pragma)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 804
            self.match(nim_Parser.OPEN_BRACE)
            self.state = 805
            self.match(nim_Parser.DOT)
            self.state = 806
            self.match(nim_Parser.IDENTIFIER)
            self.state = 808
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==nim_Parser.DOT:
                self.state = 807
                self.match(nim_Parser.DOT)


            self.state = 810
            self.match(nim_Parser.CLOSE_BRACE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RoutineContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def par(self):
            return self.getTypedRuleContext(nim_Parser.ParContext,0)


        def COLON(self, i:int=None):
            if i is None:
                return self.getTokens(nim_Parser.COLON)
            else:
                return self.getToken(nim_Parser.COLON, i)

        def stmt(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nim_Parser.StmtContext)
            else:
                return self.getTypedRuleContext(nim_Parser.StmtContext,i)


        def getRuleIndex(self):
            return nim_Parser.RULE_routine

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRoutine" ):
                listener.enterRoutine(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRoutine" ):
                listener.exitRoutine(self)




    def routine(self):

        localctx = nim_Parser.RoutineContext(self, self._ctx, self.state)
        self.enterRule(localctx, 130, self.RULE_routine)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 812
            self.par()
            self.state = 817
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,109,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 813
                    self.match(nim_Parser.COLON)
                    self.state = 814
                    self.stmt() 
                self.state = 819
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,109,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TypeSectionContext(ParserRuleContext):
>>>>>>> rev1

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPEN_BRACE(self):
            return self.getToken(nim_Parser.OPEN_BRACE, 0)

        def getRuleIndex(self):
<<<<<<< HEAD
            return nim_Parser.RULE_routine

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRoutine" ):
                listener.enterRoutine(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRoutine" ):
                listener.exitRoutine(self)
=======
            return nim_Parser.RULE_typeSection

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTypeSection" ):
                listener.enterTypeSection(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTypeSection" ):
                listener.exitTypeSection(self)
>>>>>>> rev1




<<<<<<< HEAD
    def routine(self):

        localctx = nim_Parser.RoutineContext(self, self._ctx, self.state)
        self.enterRule(localctx, 128, self.RULE_routine)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 769
            self.par()
            self.state = 774
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,98,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 770
                    self.match(nim_Parser.COLON)
                    self.state = 771
                    self.substmt() 
                self.state = 776
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,98,self._ctx)

=======
    def typeSection(self):

        localctx = nim_Parser.TypeSectionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 132, self.RULE_typeSection)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 820
            self.match(nim_Parser.OPEN_BRACE)
>>>>>>> rev1
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

<<<<<<< HEAD
    class TypeSectionContext(ParserRuleContext):
=======

    class VariableSectionContext(ParserRuleContext):
>>>>>>> rev1

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

<<<<<<< HEAD
        def OPEN_BRACE(self):
            return self.getToken(nim_Parser.OPEN_BRACE, 0)

        def getRuleIndex(self):
            return nim_Parser.RULE_typeSection

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTypeSection" ):
                listener.enterTypeSection(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTypeSection" ):
                listener.exitTypeSection(self)
=======
        def ind(self):
            return self.getTypedRuleContext(nim_Parser.IndContext,0)


        def ded(self):
            return self.getTypedRuleContext(nim_Parser.DedContext,0)


        def variable(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nim_Parser.VariableContext)
            else:
                return self.getTypedRuleContext(nim_Parser.VariableContext,i)


        def getRuleIndex(self):
            return nim_Parser.RULE_variableSection

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariableSection" ):
                listener.enterVariableSection(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariableSection" ):
                listener.exitVariableSection(self)
>>>>>>> rev1




<<<<<<< HEAD
    def typeSection(self):

        localctx = nim_Parser.TypeSectionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 130, self.RULE_typeSection)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 777
            self.match(nim_Parser.OPEN_BRACE)
=======
    def variableSection(self):

        localctx = nim_Parser.VariableSectionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 134, self.RULE_variableSection)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 835
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [nim_Parser.IDENTIFIER]:
                self.state = 823 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 822
                        self.variable()

                    else:
                        raise NoViableAltException(self)
                    self.state = 825 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,110,self._ctx)

                pass
            elif token in [nim_Parser.INDENT]:
                self.state = 827
                self.ind()
                self.state = 829 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 828
                    self.variable()
                    self.state = 831 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==nim_Parser.IDENTIFIER):
                        break

                self.state = 833
                self.ded()
                pass
            else:
                raise NoViableAltException(self)

>>>>>>> rev1
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

<<<<<<< HEAD
    class VariableSectionContext(ParserRuleContext):
=======

    class ConstantSectionContext(ParserRuleContext):
>>>>>>> rev1

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ind(self):
            return self.getTypedRuleContext(nim_Parser.IndContext,0)


        def ded(self):
            return self.getTypedRuleContext(nim_Parser.DedContext,0)


<<<<<<< HEAD
        def variable(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nim_Parser.VariableContext)
            else:
                return self.getTypedRuleContext(nim_Parser.VariableContext,i)


        def getRuleIndex(self):
            return nim_Parser.RULE_variableSection

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariableSection" ):
                listener.enterVariableSection(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariableSection" ):
                listener.exitVariableSection(self)
=======
        def constant(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nim_Parser.ConstantContext)
            else:
                return self.getTypedRuleContext(nim_Parser.ConstantContext,i)


        def getRuleIndex(self):
            return nim_Parser.RULE_constantSection

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConstantSection" ):
                listener.enterConstantSection(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConstantSection" ):
                listener.exitConstantSection(self)
>>>>>>> rev1




<<<<<<< HEAD
    def variableSection(self):

        localctx = nim_Parser.VariableSectionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 132, self.RULE_variableSection)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 792
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [nim_Parser.IDENTIFIER]:
                self.state = 780 
=======
    def constantSection(self):

        localctx = nim_Parser.ConstantSectionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 136, self.RULE_constantSection)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 850
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [nim_Parser.IDENTIFIER]:
                self.state = 838 
>>>>>>> rev1
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
<<<<<<< HEAD
                        self.state = 779
                        self.variable()

                    else:
                        raise NoViableAltException(self)
                    self.state = 782 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,99,self._ctx)

                pass
            elif token in [nim_Parser.INDENT]:
                self.state = 784
                self.ind()
                self.state = 786 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 785
                    self.variable()
                    self.state = 788 
=======
                        self.state = 837
                        self.constant()

                    else:
                        raise NoViableAltException(self)
                    self.state = 840 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,113,self._ctx)

                pass
            elif token in [nim_Parser.INDENT]:
                self.state = 842
                self.ind()
                self.state = 844 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 843
                    self.constant()
                    self.state = 846 
>>>>>>> rev1
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==nim_Parser.IDENTIFIER):
                        break

<<<<<<< HEAD
                self.state = 790
=======
                self.state = 848
>>>>>>> rev1
                self.ded()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

<<<<<<< HEAD
    class ConstantSectionContext(ParserRuleContext):
=======

    class IdentVisContext(ParserRuleContext):
>>>>>>> rev1

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

<<<<<<< HEAD
        def ind(self):
            return self.getTypedRuleContext(nim_Parser.IndContext,0)


        def ded(self):
            return self.getTypedRuleContext(nim_Parser.DedContext,0)


        def constant(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nim_Parser.ConstantContext)
            else:
                return self.getTypedRuleContext(nim_Parser.ConstantContext,i)


        def getRuleIndex(self):
            return nim_Parser.RULE_constantSection

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConstantSection" ):
                listener.enterConstantSection(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConstantSection" ):
                listener.exitConstantSection(self)
=======
        def symbol(self):
            return self.getTypedRuleContext(nim_Parser.SymbolContext,0)


        def operator(self):
            return self.getTypedRuleContext(nim_Parser.OperatorContext,0)


        def getRuleIndex(self):
            return nim_Parser.RULE_identVis

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdentVis" ):
                listener.enterIdentVis(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdentVis" ):
                listener.exitIdentVis(self)
>>>>>>> rev1




<<<<<<< HEAD
    def constantSection(self):

        localctx = nim_Parser.ConstantSectionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 134, self.RULE_constantSection)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 807
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [nim_Parser.IDENTIFIER]:
                self.state = 795 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 794
                        self.constant()

                    else:
                        raise NoViableAltException(self)
                    self.state = 797 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,102,self._ctx)

                pass
            elif token in [nim_Parser.INDENT]:
                self.state = 799
                self.ind()
                self.state = 801 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 800
                    self.constant()
                    self.state = 803 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==nim_Parser.IDENTIFIER):
                        break

                self.state = 805
                self.ded()
                pass
            else:
                raise NoViableAltException(self)
=======
    def identVis(self):

        localctx = nim_Parser.IdentVisContext(self, self._ctx, self.state)
        self.enterRule(localctx, 138, self.RULE_identVis)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 852
            self.symbol()
            self.state = 854
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << nim_Parser.COLON) | (1 << nim_Parser.DOT) | (1 << nim_Parser.EQUALS) | (1 << nim_Parser.IN) | (1 << nim_Parser.OF) | (1 << nim_Parser.NOT) | (1 << nim_Parser.OP0) | (1 << nim_Parser.OP1) | (1 << nim_Parser.OP2) | (1 << nim_Parser.OP3) | (1 << nim_Parser.OP4) | (1 << nim_Parser.OP5) | (1 << nim_Parser.OP6) | (1 << nim_Parser.OP7) | (1 << nim_Parser.OP8) | (1 << nim_Parser.OP9) | (1 << nim_Parser.OP10))) != 0):
                self.state = 853
                self.operator()

>>>>>>> rev1

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

<<<<<<< HEAD
    class IdentVisContext(ParserRuleContext):
=======

    class VarTupleContext(ParserRuleContext):
>>>>>>> rev1

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def symbol(self):
            return self.getTypedRuleContext(nim_Parser.SymbolContext,0)

<<<<<<< HEAD

        def operator(self):
            return self.getTypedRuleContext(nim_Parser.OperatorContext,0)
=======
        def identVis(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nim_Parser.IdentVisContext)
            else:
                return self.getTypedRuleContext(nim_Parser.IdentVisContext,i)


        def optInd(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nim_Parser.OptIndContext)
            else:
                return self.getTypedRuleContext(nim_Parser.OptIndContext,i)

>>>>>>> rev1


        def EQUALS(self):
            return self.getToken(nim_Parser.EQUALS, 0)

        def simpleExpr(self):
            return self.getTypedRuleContext(nim_Parser.SimpleExprContext,0)


        def expr(self):
            return self.getTypedRuleContext(nim_Parser.ExprContext,0)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(nim_Parser.COMMA)
            else:
                return self.getToken(nim_Parser.COMMA, i)

        def ded(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nim_Parser.DedContext)
            else:
                return self.getTypedRuleContext(nim_Parser.DedContext,i)


        def getRuleIndex(self):
<<<<<<< HEAD
            return nim_Parser.RULE_identVis

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdentVis" ):
                listener.enterIdentVis(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdentVis" ):
                listener.exitIdentVis(self)
=======
            return nim_Parser.RULE_varTuple

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVarTuple" ):
                listener.enterVarTuple(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVarTuple" ):
                listener.exitVarTuple(self)
>>>>>>> rev1




<<<<<<< HEAD
    def identVis(self):

        localctx = nim_Parser.IdentVisContext(self, self._ctx, self.state)
        self.enterRule(localctx, 136, self.RULE_identVis)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 809
            self.symbol()
            self.state = 811
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << nim_Parser.COLON) | (1 << nim_Parser.DOT) | (1 << nim_Parser.EQUALS) | (1 << nim_Parser.IN) | (1 << nim_Parser.OF) | (1 << nim_Parser.NOT) | (1 << nim_Parser.OP0) | (1 << nim_Parser.OP1) | (1 << nim_Parser.OP2) | (1 << nim_Parser.OP3) | (1 << nim_Parser.OP4) | (1 << nim_Parser.OP5) | (1 << nim_Parser.OP6) | (1 << nim_Parser.OP7) | (1 << nim_Parser.OP8) | (1 << nim_Parser.OP9) | (1 << nim_Parser.OP10))) != 0):
                self.state = 810
                self.operator()
=======
    def varTuple(self):

        localctx = nim_Parser.VarTupleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 140, self.RULE_varTuple)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 856
            self.match(nim_Parser.OPEN_BRACE)
            self.state = 857
            self.identVis()
            self.state = 862
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==nim_Parser.COMMA:
                self.state = 858
                self.match(nim_Parser.COMMA)
                self.state = 859
                self.identVis()
                self.state = 864
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 865
            self.optInd()
            self.state = 866
            self.match(nim_Parser.CLOSE_BRACE)
            self.state = 868
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==nim_Parser.EOF or _la==nim_Parser.DEDENT:
                self.state = 867
                self.ded()


            self.state = 870
            self.match(nim_Parser.EQUALS)
            self.state = 872
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,119,self._ctx)
            if la_ == 1:
                self.state = 871
                self.ded()


            self.state = 874
            self.optInd()
            self.state = 877
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,120,self._ctx)
            if la_ == 1:
                self.state = 875
                self.simpleExpr()
                pass

            elif la_ == 2:
                self.state = 876
                self.expr()
                pass
>>>>>>> rev1


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

<<<<<<< HEAD
    class VarTupleContext(ParserRuleContext):
=======

    class ConstantContext(ParserRuleContext):
>>>>>>> rev1

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

<<<<<<< HEAD
        def OPEN_BRACE(self):
            return self.getToken(nim_Parser.OPEN_BRACE, 0)

        def identVis(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nim_Parser.IdentVisContext)
            else:
                return self.getTypedRuleContext(nim_Parser.IdentVisContext,i)


        def EQUALS(self):
            return self.getToken(nim_Parser.EQUALS, 0)

        def ind(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nim_Parser.IndContext)
            else:
                return self.getTypedRuleContext(nim_Parser.IndContext,i)


        def CLOSE_BRACE(self):
            return self.getToken(nim_Parser.CLOSE_BRACE, 0)

        def ded(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nim_Parser.DedContext)
            else:
                return self.getTypedRuleContext(nim_Parser.DedContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(nim_Parser.COMMA)
            else:
                return self.getToken(nim_Parser.COMMA, i)

=======
        def IDENTIFIER(self, i:int=None):
            if i is None:
                return self.getTokens(nim_Parser.IDENTIFIER)
            else:
                return self.getToken(nim_Parser.IDENTIFIER, i)

        def EQUALS(self):
            return self.getToken(nim_Parser.EQUALS, 0)

        def optInd(self):
            return self.getTypedRuleContext(nim_Parser.OptIndContext,0)


        def expr(self):
            return self.getTypedRuleContext(nim_Parser.ExprContext,0)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(nim_Parser.COMMA)
            else:
                return self.getToken(nim_Parser.COMMA, i)

        def COLON(self):
            return self.getToken(nim_Parser.COLON, 0)

>>>>>>> rev1
        def simpleExpr(self):
            return self.getTypedRuleContext(nim_Parser.SimpleExprContext,0)


<<<<<<< HEAD
        def expr(self):
            return self.getTypedRuleContext(nim_Parser.ExprContext,0)


        def getRuleIndex(self):
            return nim_Parser.RULE_varTuple

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVarTuple" ):
                listener.enterVarTuple(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVarTuple" ):
                listener.exitVarTuple(self)
=======
        def ded(self):
            return self.getTypedRuleContext(nim_Parser.DedContext,0)


        def getRuleIndex(self):
            return nim_Parser.RULE_constant

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConstant" ):
                listener.enterConstant(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConstant" ):
                listener.exitConstant(self)
>>>>>>> rev1




<<<<<<< HEAD
    def varTuple(self):

        localctx = nim_Parser.VarTupleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 138, self.RULE_varTuple)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 813
            self.match(nim_Parser.OPEN_BRACE)
            self.state = 814
            self.identVis()
            self.state = 819
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==nim_Parser.COMMA:
                self.state = 815
                self.match(nim_Parser.COMMA)
                self.state = 816
                self.identVis()
                self.state = 821
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 827
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [nim_Parser.INDENT]:
                self.state = 822
                self.ind()
                self.state = 823
                self.match(nim_Parser.CLOSE_BRACE)
                self.state = 824
                self.ded()
                pass
            elif token in [nim_Parser.CLOSE_BRACE]:
                self.state = 826
                self.match(nim_Parser.CLOSE_BRACE)
                pass
            else:
                raise NoViableAltException(self)

            self.state = 829
            self.match(nim_Parser.EQUALS)
            self.state = 831
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,108,self._ctx)
            if la_ == 1:
                self.state = 830
                self.ded()


            self.state = 842
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,111,self._ctx)
            if la_ == 1:
                self.state = 833
                self.ind()
                self.state = 836
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,109,self._ctx)
                if la_ == 1:
                    self.state = 834
                    self.simpleExpr()
                    pass

                elif la_ == 2:
                    self.state = 835
                    self.expr()
                    pass


                pass

            elif la_ == 2:
                self.state = 840
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,110,self._ctx)
                if la_ == 1:
                    self.state = 838
                    self.simpleExpr()
                    pass

                elif la_ == 2:
                    self.state = 839
                    self.expr()
                    pass


                pass
=======
    def constant(self):

        localctx = nim_Parser.ConstantContext(self, self._ctx, self.state)
        self.enterRule(localctx, 142, self.RULE_constant)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 879
            self.match(nim_Parser.IDENTIFIER)
            self.state = 884
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==nim_Parser.COMMA:
                self.state = 880
                self.match(nim_Parser.COMMA)
                self.state = 881
                self.match(nim_Parser.IDENTIFIER)
                self.state = 886
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 889
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==nim_Parser.COLON:
                self.state = 887
                self.match(nim_Parser.COLON)
                self.state = 888
                self.simpleExpr()


            self.state = 891
            self.match(nim_Parser.EQUALS)
            self.state = 892
            self.optInd()
            self.state = 893
            self.expr()
            self.state = 895
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,123,self._ctx)
            if la_ == 1:
                self.state = 894
                self.ded()
>>>>>>> rev1


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

<<<<<<< HEAD
    class ConstantContext(ParserRuleContext):
=======

    class VariableContext(ParserRuleContext):
>>>>>>> rev1

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

<<<<<<< HEAD
        def IDENTIFIER(self, i:int=None):
            if i is None:
                return self.getTokens(nim_Parser.IDENTIFIER)
            else:
                return self.getToken(nim_Parser.IDENTIFIER, i)

        def EQUALS(self):
            return self.getToken(nim_Parser.EQUALS, 0)

        def ind(self):
            return self.getTypedRuleContext(nim_Parser.IndContext,0)


        def expr(self):
            return self.getTypedRuleContext(nim_Parser.ExprContext,0)


        def ded(self):
            return self.getTypedRuleContext(nim_Parser.DedContext,0)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(nim_Parser.COMMA)
            else:
                return self.getToken(nim_Parser.COMMA, i)

        def COLON(self):
            return self.getToken(nim_Parser.COLON, 0)

        def simpleExpr(self):
            return self.getTypedRuleContext(nim_Parser.SimpleExprContext,0)


        def getRuleIndex(self):
            return nim_Parser.RULE_constant

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConstant" ):
                listener.enterConstant(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConstant" ):
                listener.exitConstant(self)
=======
        def idColonEq(self):
            return self.getTypedRuleContext(nim_Parser.IdColonEqContext,0)


        def getRuleIndex(self):
            return nim_Parser.RULE_variable

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariable" ):
                listener.enterVariable(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariable" ):
                listener.exitVariable(self)
>>>>>>> rev1




<<<<<<< HEAD
    def constant(self):

        localctx = nim_Parser.ConstantContext(self, self._ctx, self.state)
        self.enterRule(localctx, 140, self.RULE_constant)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 844
            self.match(nim_Parser.IDENTIFIER)
            self.state = 849
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==nim_Parser.COMMA:
                self.state = 845
                self.match(nim_Parser.COMMA)
                self.state = 846
                self.match(nim_Parser.IDENTIFIER)
                self.state = 851
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 854
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==nim_Parser.COLON:
                self.state = 852
                self.match(nim_Parser.COLON)
                self.state = 853
                self.simpleExpr()


            self.state = 856
            self.match(nim_Parser.EQUALS)
            self.state = 862
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [nim_Parser.INDENT]:
                self.state = 857
                self.ind()
                self.state = 858
                self.expr()
                self.state = 859
                self.ded()
                pass
            elif token in [nim_Parser.IF, nim_Parser.FOR, nim_Parser.WHEN, nim_Parser.BLOCK]:
                self.state = 861
                self.expr()
                pass
            else:
                raise NoViableAltException(self)

=======
    def variable(self):

        localctx = nim_Parser.VariableContext(self, self._ctx, self.state)
        self.enterRule(localctx, 144, self.RULE_variable)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 897
            self.idColonEq()
>>>>>>> rev1
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

<<<<<<< HEAD
    class VariableContext(ParserRuleContext):
=======

    class IdColonEqContext(ParserRuleContext):
>>>>>>> rev1

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

<<<<<<< HEAD
        def idColonEq(self):
            return self.getTypedRuleContext(nim_Parser.IdColonEqContext,0)


        def optInd(self):
            return self.getTypedRuleContext(nim_Parser.OptIndContext,0)


        def colonBody(self):
            return self.getTypedRuleContext(nim_Parser.ColonBodyContext,0)


        def getRuleIndex(self):
            return nim_Parser.RULE_variable

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariable" ):
                listener.enterVariable(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariable" ):
                listener.exitVariable(self)
=======
        def IDENTIFIER(self, i:int=None):
            if i is None:
                return self.getTokens(nim_Parser.IDENTIFIER)
            else:
                return self.getToken(nim_Parser.IDENTIFIER, i)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(nim_Parser.COMMA)
            else:
                return self.getToken(nim_Parser.COMMA, i)

        def COLON(self):
            return self.getToken(nim_Parser.COLON, 0)

        def optInd(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nim_Parser.OptIndContext)
            else:
                return self.getTypedRuleContext(nim_Parser.OptIndContext,i)


        def simpleExpr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nim_Parser.SimpleExprContext)
            else:
                return self.getTypedRuleContext(nim_Parser.SimpleExprContext,i)


        def EQUALS(self):
            return self.getToken(nim_Parser.EQUALS, 0)

        def expr(self):
            return self.getTypedRuleContext(nim_Parser.ExprContext,0)


        def ded(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nim_Parser.DedContext)
            else:
                return self.getTypedRuleContext(nim_Parser.DedContext,i)


        def getRuleIndex(self):
            return nim_Parser.RULE_idColonEq

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdColonEq" ):
                listener.enterIdColonEq(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdColonEq" ):
                listener.exitIdColonEq(self)
>>>>>>> rev1




<<<<<<< HEAD
    def variable(self):

        localctx = nim_Parser.VariableContext(self, self._ctx, self.state)
        self.enterRule(localctx, 142, self.RULE_variable)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 864
            self.idColonEq()
            self.state = 866
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,115,self._ctx)
            if la_ == 1:
                self.state = 865
                self.colonBody()


            self.state = 868
            self.optInd()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class IdColonEqContext(ParserRuleContext):
=======
    def idColonEq(self):

        localctx = nim_Parser.IdColonEqContext(self, self._ctx, self.state)
        self.enterRule(localctx, 146, self.RULE_idColonEq)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 899
            self.match(nim_Parser.IDENTIFIER)
            self.state = 904
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,124,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 900
                    self.match(nim_Parser.COMMA)
                    self.state = 901
                    self.match(nim_Parser.IDENTIFIER) 
                self.state = 906
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,124,self._ctx)

            self.state = 908
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,125,self._ctx)
            if la_ == 1:
                self.state = 907
                self.match(nim_Parser.COMMA)

>>>>>>> rev1

            self.state = 916
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,127,self._ctx)
            if la_ == 1:
                self.state = 910
                self.match(nim_Parser.COLON)
                self.state = 911
                self.optInd()
                self.state = 912
                self.simpleExpr()
                self.state = 914
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,126,self._ctx)
                if la_ == 1:
                    self.state = 913
                    self.ded()

<<<<<<< HEAD
        def IDENTIFIER(self, i:int=None):
            if i is None:
                return self.getTokens(nim_Parser.IDENTIFIER)
            else:
                return self.getToken(nim_Parser.IDENTIFIER, i)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(nim_Parser.COMMA)
            else:
                return self.getToken(nim_Parser.COMMA, i)

        def COLON(self):
            return self.getToken(nim_Parser.COLON, 0)

        def EQUALS(self):
            return self.getToken(nim_Parser.EQUALS, 0)

        def ind(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nim_Parser.IndContext)
            else:
                return self.getTypedRuleContext(nim_Parser.IndContext,i)


        def simpleExpr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nim_Parser.SimpleExprContext)
            else:
                return self.getTypedRuleContext(nim_Parser.SimpleExprContext,i)


        def ded(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nim_Parser.DedContext)
            else:
                return self.getTypedRuleContext(nim_Parser.DedContext,i)


        def anyExpr(self):
            return self.getTypedRuleContext(nim_Parser.AnyExprContext,0)


        def expr(self):
            return self.getTypedRuleContext(nim_Parser.ExprContext,0)


        def getRuleIndex(self):
            return nim_Parser.RULE_idColonEq

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdColonEq" ):
                listener.enterIdColonEq(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdColonEq" ):
                listener.exitIdColonEq(self)
=======



            self.state = 927
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,130,self._ctx)
            if la_ == 1:
                self.state = 918
                self.match(nim_Parser.EQUALS)
                self.state = 919
                self.optInd()
                self.state = 922
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,128,self._ctx)
                if la_ == 1:
                    self.state = 920
                    self.expr()
                    pass

                elif la_ == 2:
                    self.state = 921
                    self.simpleExpr()
                    pass

>>>>>>> rev1

                self.state = 925
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,129,self._ctx)
                if la_ == 1:
                    self.state = 924
                    self.ded()



<<<<<<< HEAD
    def idColonEq(self):

        localctx = nim_Parser.IdColonEqContext(self, self._ctx, self.state)
        self.enterRule(localctx, 144, self.RULE_idColonEq)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 870
            self.match(nim_Parser.IDENTIFIER)
            self.state = 875
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,116,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 871
                    self.match(nim_Parser.COMMA)
                    self.state = 872
                    self.match(nim_Parser.IDENTIFIER) 
                self.state = 877
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,116,self._ctx)

            self.state = 879
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,117,self._ctx)
            if la_ == 1:
                self.state = 878
                self.match(nim_Parser.COMMA)


            self.state = 889
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,119,self._ctx)
            if la_ == 1:
                self.state = 881
                self.match(nim_Parser.COLON)
                self.state = 887
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,118,self._ctx)
                if la_ == 1:
                    self.state = 882
                    self.ind()
                    self.state = 883
                    self.simpleExpr()
                    self.state = 884
                    self.ded()
                    pass

                elif la_ == 2:
                    self.state = 886
                    self.simpleExpr()
                    pass




            self.state = 902
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,122,self._ctx)
            if la_ == 1:
                self.state = 891
                self.match(nim_Parser.EQUALS)
                self.state = 900
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,121,self._ctx)
                if la_ == 1:
                    self.state = 892
                    self.ind()
                    self.state = 895
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,120,self._ctx)
                    if la_ == 1:
                        self.state = 893
                        self.expr()
                        pass

                    elif la_ == 2:
                        self.state = 894
                        self.simpleExpr()
                        pass


                    self.state = 897
                    self.ded()
                    pass

                elif la_ == 2:
                    self.state = 899
                    self.anyExpr()
                    pass




=======

>>>>>>> rev1
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Simple_complexStmtContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def simpleStmt(self):
            return self.getTypedRuleContext(nim_Parser.SimpleStmtContext,0)


        def complexStmt(self):
            return self.getTypedRuleContext(nim_Parser.ComplexStmtContext,0)


        def getRuleIndex(self):
            return nim_Parser.RULE_simple_complexStmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimple_complexStmt" ):
                listener.enterSimple_complexStmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimple_complexStmt" ):
                listener.exitSimple_complexStmt(self)




    def simple_complexStmt(self):

        localctx = nim_Parser.Simple_complexStmtContext(self, self._ctx, self.state)
<<<<<<< HEAD
        self.enterRule(localctx, 146, self.RULE_simple_complexStmt)
        try:
            self.state = 906
=======
        self.enterRule(localctx, 148, self.RULE_simple_complexStmt)
        try:
            self.state = 931
>>>>>>> rev1
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [nim_Parser.OPEN_BRACE, nim_Parser.IMPORT, nim_Parser.FROM]:
                self.enterOuterAlt(localctx, 1)
<<<<<<< HEAD
                self.state = 904
=======
                self.state = 929
>>>>>>> rev1
                self.simpleStmt()
                pass
            elif token in [nim_Parser.TYPE, nim_Parser.VARIABLE, nim_Parser.LET, nim_Parser.CONST, nim_Parser.PROC, nim_Parser.IF, nim_Parser.FOR, nim_Parser.TEMPLATE, nim_Parser.WHEN, nim_Parser.BLOCK, nim_Parser.MACRO]:
                self.enterOuterAlt(localctx, 2)
<<<<<<< HEAD
                self.state = 905
=======
                self.state = 930
>>>>>>> rev1
                self.complexStmt()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class SimpleStmtContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def importStmt(self):
            return self.getTypedRuleContext(nim_Parser.ImportStmtContext,0)


        def fromStmt(self):
            return self.getTypedRuleContext(nim_Parser.FromStmtContext,0)


<<<<<<< HEAD
=======
        def discardStmt(self):
            return self.getTypedRuleContext(nim_Parser.DiscardStmtContext,0)


        def returnStmt(self):
            return self.getTypedRuleContext(nim_Parser.ReturnStmtContext,0)


        def breakStmt(self):
            return self.getTypedRuleContext(nim_Parser.BreakStmtContext,0)


>>>>>>> rev1
        def pragmaStmt(self):
            return self.getTypedRuleContext(nim_Parser.PragmaStmtContext,0)


        def getRuleIndex(self):
            return nim_Parser.RULE_simpleStmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimpleStmt" ):
                listener.enterSimpleStmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimpleStmt" ):
                listener.exitSimpleStmt(self)




    def simpleStmt(self):

        localctx = nim_Parser.SimpleStmtContext(self, self._ctx, self.state)
<<<<<<< HEAD
        self.enterRule(localctx, 148, self.RULE_simpleStmt)
        try:
            self.state = 911
=======
        self.enterRule(localctx, 150, self.RULE_simpleStmt)
        try:
            self.state = 939
>>>>>>> rev1
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [nim_Parser.IMPORT]:
                self.enterOuterAlt(localctx, 1)
<<<<<<< HEAD
                self.state = 908
=======
                self.state = 933
>>>>>>> rev1
                self.importStmt()
                pass
            elif token in [nim_Parser.FROM]:
                self.enterOuterAlt(localctx, 2)
<<<<<<< HEAD
                self.state = 909
                self.fromStmt()
                pass
            elif token in [nim_Parser.OPEN_BRACE]:
                self.enterOuterAlt(localctx, 3)
                self.state = 910
                self.pragmaStmt()
                pass
=======
                self.state = 934
                self.fromStmt()
                pass
            elif token in [nim_Parser.DISCARD]:
                self.enterOuterAlt(localctx, 3)
                self.state = 935
                self.discardStmt()
                pass
            elif token in [nim_Parser.RETURN]:
                self.enterOuterAlt(localctx, 4)
                self.state = 936
                self.returnStmt()
                pass
            elif token in [nim_Parser.BREAK]:
                self.enterOuterAlt(localctx, 5)
                self.state = 937
                self.breakStmt()
                pass
            elif token in [nim_Parser.OPEN_BRACE]:
                self.enterOuterAlt(localctx, 6)
                self.state = 938
                self.pragmaStmt()
                pass
>>>>>>> rev1
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ComplexStmtContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def forStmt(self):
            return self.getTypedRuleContext(nim_Parser.ForStmtContext,0)


        def ifStmt(self):
            return self.getTypedRuleContext(nim_Parser.IfStmtContext,0)


        def blockStmt(self):
            return self.getTypedRuleContext(nim_Parser.BlockStmtContext,0)


        def whenStmt(self):
            return self.getTypedRuleContext(nim_Parser.WhenStmtContext,0)


        def routine(self):
            return self.getTypedRuleContext(nim_Parser.RoutineContext,0)


        def TEMPLATE(self):
            return self.getToken(nim_Parser.TEMPLATE, 0)

        def PROC(self):
            return self.getToken(nim_Parser.PROC, 0)

        def MACRO(self):
            return self.getToken(nim_Parser.MACRO, 0)

        def TYPE(self):
            return self.getToken(nim_Parser.TYPE, 0)

        def typeSection(self):
            return self.getTypedRuleContext(nim_Parser.TypeSectionContext,0)


        def CONST(self):
            return self.getToken(nim_Parser.CONST, 0)

        def constantSection(self):
            return self.getTypedRuleContext(nim_Parser.ConstantSectionContext,0)


        def variableSection(self):
            return self.getTypedRuleContext(nim_Parser.VariableSectionContext,0)


        def LET(self):
            return self.getToken(nim_Parser.LET, 0)

        def VARIABLE(self):
            return self.getToken(nim_Parser.VARIABLE, 0)

        def getRuleIndex(self):
            return nim_Parser.RULE_complexStmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComplexStmt" ):
                listener.enterComplexStmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComplexStmt" ):
                listener.exitComplexStmt(self)




    def complexStmt(self):

        localctx = nim_Parser.ComplexStmtContext(self, self._ctx, self.state)
<<<<<<< HEAD
        self.enterRule(localctx, 150, self.RULE_complexStmt)
        self._la = 0 # Token type
        try:
            self.state = 925
=======
        self.enterRule(localctx, 152, self.RULE_complexStmt)
        self._la = 0 # Token type
        try:
            self.state = 954
>>>>>>> rev1
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [nim_Parser.FOR]:
                self.enterOuterAlt(localctx, 1)
<<<<<<< HEAD
                self.state = 913
=======
                self.state = 941
>>>>>>> rev1
                self.forStmt()
                pass
            elif token in [nim_Parser.IF]:
                self.enterOuterAlt(localctx, 2)
<<<<<<< HEAD
                self.state = 914
=======
                self.state = 942
>>>>>>> rev1
                self.ifStmt()
                pass
            elif token in [nim_Parser.BLOCK]:
                self.enterOuterAlt(localctx, 3)
<<<<<<< HEAD
                self.state = 915
                self.blockStmt()
                pass
            elif token in [nim_Parser.WHEN]:
                self.enterOuterAlt(localctx, 4)
                self.state = 916
                self.whenStmt()
                pass
            elif token in [nim_Parser.PROC, nim_Parser.TEMPLATE, nim_Parser.MACRO]:
                self.enterOuterAlt(localctx, 5)
                self.state = 917
=======
                self.state = 943
                self.blockStmt()
                pass
            elif token in [nim_Parser.WHILE]:
                self.enterOuterAlt(localctx, 4)
                self.state = 944
                self.whileStmt()
                pass
            elif token in [nim_Parser.WHEN]:
                self.enterOuterAlt(localctx, 5)
                self.state = 945
                self.whenStmt()
                pass
            elif token in [nim_Parser.PROC, nim_Parser.TEMPLATE, nim_Parser.MACRO]:
                self.enterOuterAlt(localctx, 6)
                self.state = 946
>>>>>>> rev1
                _la = self._input.LA(1)
                if not(((((_la - 41)) & ~0x3f) == 0 and ((1 << (_la - 41)) & ((1 << (nim_Parser.PROC - 41)) | (1 << (nim_Parser.TEMPLATE - 41)) | (1 << (nim_Parser.MACRO - 41)))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
<<<<<<< HEAD
                self.state = 918
                self.routine()
                pass
            elif token in [nim_Parser.TYPE]:
                self.enterOuterAlt(localctx, 6)
                self.state = 919
                self.match(nim_Parser.TYPE)
                self.state = 920
                self.typeSection()
                pass
            elif token in [nim_Parser.CONST]:
                self.enterOuterAlt(localctx, 7)
                self.state = 921
                self.match(nim_Parser.CONST)
                self.state = 922
                self.constantSection()
                pass
            elif token in [nim_Parser.VARIABLE, nim_Parser.LET]:
                self.enterOuterAlt(localctx, 8)
                self.state = 923
=======
                self.state = 947
                self.routine()
                pass
            elif token in [nim_Parser.TYPE]:
                self.enterOuterAlt(localctx, 7)
                self.state = 948
                self.match(nim_Parser.TYPE)
                self.state = 949
                self.typeSection()
                pass
            elif token in [nim_Parser.CONST]:
                self.enterOuterAlt(localctx, 8)
                self.state = 950
                self.match(nim_Parser.CONST)
                self.state = 951
                self.constantSection()
                pass
            elif token in [nim_Parser.VARIABLE, nim_Parser.LET]:
                self.enterOuterAlt(localctx, 9)
                self.state = 952
>>>>>>> rev1
                _la = self._input.LA(1)
                if not(_la==nim_Parser.VARIABLE or _la==nim_Parser.LET):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
<<<<<<< HEAD
                self.state = 924
=======
                self.state = 953
>>>>>>> rev1
                self.variableSection()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ColonBodyContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COLON(self):
            return self.getToken(nim_Parser.COLON, 0)

        def substmt(self):
            return self.getTypedRuleContext(nim_Parser.SubstmtContext,0)


        def getRuleIndex(self):
            return nim_Parser.RULE_colonBody

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColonBody" ):
                listener.enterColonBody(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColonBody" ):
                listener.exitColonBody(self)




    def colonBody(self):

        localctx = nim_Parser.ColonBodyContext(self, self._ctx, self.state)
<<<<<<< HEAD
        self.enterRule(localctx, 152, self.RULE_colonBody)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 927
            self.match(nim_Parser.COLON)
            self.state = 928
            self.substmt()
=======
        self.enterRule(localctx, 154, self.RULE_colonBody)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 956
            self.match(nim_Parser.COLON)
            self.state = 957
            self.stmt()
>>>>>>> rev1
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ExprStmtContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def simpleExpr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nim_Parser.SimpleExprContext)
            else:
                return self.getTypedRuleContext(nim_Parser.SimpleExprContext,i)


        def EQUALS(self):
            return self.getToken(nim_Parser.EQUALS, 0)

        def expr(self):
            return self.getTypedRuleContext(nim_Parser.ExprContext,0)


        def colonBody(self):
            return self.getTypedRuleContext(nim_Parser.ColonBodyContext,0)


        def getRuleIndex(self):
            return nim_Parser.RULE_exprStmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExprStmt" ):
                listener.enterExprStmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExprStmt" ):
                listener.exitExprStmt(self)




    def exprStmt(self):

        localctx = nim_Parser.ExprStmtContext(self, self._ctx, self.state)
<<<<<<< HEAD
        self.enterRule(localctx, 154, self.RULE_exprStmt)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 930
            self.simpleExpr()

            self.state = 931
            self.match(nim_Parser.EQUALS)
            self.state = 934
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,126,self._ctx)
            if la_ == 1:
                self.state = 932
=======
        self.enterRule(localctx, 156, self.RULE_exprStmt)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 959
            self.simpleExpr()

            self.state = 960
            self.match(nim_Parser.EQUALS)
            self.state = 963
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,134,self._ctx)
            if la_ == 1:
                self.state = 961
>>>>>>> rev1
                self.expr()
                pass

            elif la_ == 2:
<<<<<<< HEAD
                self.state = 933
=======
                self.state = 962
>>>>>>> rev1
                self.simpleExpr()
                pass


<<<<<<< HEAD
            self.state = 937
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,127,self._ctx)
            if la_ == 1:
                self.state = 936
=======
            self.state = 966
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,135,self._ctx)
            if la_ == 1:
                self.state = 965
>>>>>>> rev1
                self.colonBody()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class SubstmtContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def simple_complexStmt(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nim_Parser.Simple_complexStmtContext)
            else:
                return self.getTypedRuleContext(nim_Parser.Simple_complexStmtContext,i)


        def SEMI_COLON(self, i:int=None):
            if i is None:
                return self.getTokens(nim_Parser.SEMI_COLON)
            else:
                return self.getToken(nim_Parser.SEMI_COLON, i)

<<<<<<< HEAD
=======
        def ind(self):
            return self.getTypedRuleContext(nim_Parser.IndContext,0)


        def simpleStmt(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nim_Parser.SimpleStmtContext)
            else:
                return self.getTypedRuleContext(nim_Parser.SimpleStmtContext,i)


        def ded(self):
            return self.getTypedRuleContext(nim_Parser.DedContext,0)


>>>>>>> rev1
        def getRuleIndex(self):
            return nim_Parser.RULE_substmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSubstmt" ):
                listener.enterSubstmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSubstmt" ):
                listener.exitSubstmt(self)




    def substmt(self):

<<<<<<< HEAD
        localctx = nim_Parser.SubstmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 156, self.RULE_substmt)
        self._la = 0 # Token type
        try:
            self.state = 953
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [nim_Parser.INDENT]:
                self.enterOuterAlt(localctx, 1)
                self.state = 939
                self.ind()
                self.state = 940
                self.simple_complexStmt()
                self.state = 947
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << nim_Parser.SEMI_COLON) | (1 << nim_Parser.OPEN_BRACE) | (1 << nim_Parser.TYPE) | (1 << nim_Parser.VARIABLE) | (1 << nim_Parser.LET) | (1 << nim_Parser.CONST) | (1 << nim_Parser.PROC) | (1 << nim_Parser.IF) | (1 << nim_Parser.FOR) | (1 << nim_Parser.TEMPLATE))) != 0) or ((((_la - 66)) & ~0x3f) == 0 and ((1 << (_la - 66)) & ((1 << (nim_Parser.WHEN - 66)) | (1 << (nim_Parser.IMPORT - 66)) | (1 << (nim_Parser.FROM - 66)) | (1 << (nim_Parser.BLOCK - 66)) | (1 << (nim_Parser.MACRO - 66)))) != 0):
                    self.state = 942
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==nim_Parser.SEMI_COLON:
                        self.state = 941
                        self.match(nim_Parser.SEMI_COLON)


                    self.state = 944
                    self.simple_complexStmt()
                    self.state = 949
=======
        localctx = nim_Parser.StmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 158, self.RULE_stmt)
        self._la = 0 # Token type
        try:
            self.state = 992
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,140,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 968
                self.simple_complexStmt()
                self.state = 975
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,137,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 970
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==nim_Parser.SEMI_COLON:
                            self.state = 969
                            self.match(nim_Parser.SEMI_COLON)


                        self.state = 972
                        self.simple_complexStmt() 
                    self.state = 977
>>>>>>> rev1
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,137,self._ctx)

<<<<<<< HEAD
                self.state = 950
                self.ded()
=======
>>>>>>> rev1
                pass
            elif token in [nim_Parser.OPEN_BRACE, nim_Parser.TYPE, nim_Parser.VARIABLE, nim_Parser.LET, nim_Parser.CONST, nim_Parser.PROC, nim_Parser.IF, nim_Parser.FOR, nim_Parser.TEMPLATE, nim_Parser.WHEN, nim_Parser.IMPORT, nim_Parser.FROM, nim_Parser.BLOCK, nim_Parser.MACRO]:
                self.enterOuterAlt(localctx, 2)
<<<<<<< HEAD
                self.state = 952
                self.simple_complexStmt()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class StmtContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def simple_complexStmt(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nim_Parser.Simple_complexStmtContext)
            else:
                return self.getTypedRuleContext(nim_Parser.Simple_complexStmtContext,i)


        def SEMI_COLON(self, i:int=None):
            if i is None:
                return self.getTokens(nim_Parser.SEMI_COLON)
            else:
                return self.getToken(nim_Parser.SEMI_COLON, i)

        def getRuleIndex(self):
            return nim_Parser.RULE_stmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStmt" ):
                listener.enterStmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStmt" ):
                listener.exitStmt(self)



=======
                self.state = 978
                self.ind()
                self.state = 979
                self.simpleStmt()
                self.state = 986
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << nim_Parser.SEMI_COLON) | (1 << nim_Parser.OPEN_BRACE) | (1 << nim_Parser.RETURN) | (1 << nim_Parser.BREAK))) != 0) or ((((_la - 69)) & ~0x3f) == 0 and ((1 << (_la - 69)) & ((1 << (nim_Parser.IMPORT - 69)) | (1 << (nim_Parser.FROM - 69)) | (1 << (nim_Parser.DISCARD - 69)))) != 0):
                    self.state = 981
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==nim_Parser.SEMI_COLON:
                        self.state = 980
                        self.match(nim_Parser.SEMI_COLON)
>>>>>>> rev1

    def stmt(self):

<<<<<<< HEAD
        localctx = nim_Parser.StmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 158, self.RULE_stmt)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 955
            self.simple_complexStmt()
            self.state = 962
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,132,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 957
=======
                    self.state = 983
                    self.simpleStmt()
                    self.state = 988
>>>>>>> rev1
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==nim_Parser.SEMI_COLON:
                        self.state = 956
                        self.match(nim_Parser.SEMI_COLON)

<<<<<<< HEAD
=======
                self.state = 989
                self.ded()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 991
                self.simpleStmt()
                pass
>>>>>>> rev1

                    self.state = 959
                    self.simple_complexStmt() 
                self.state = 964
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,132,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ModuleContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def stmt(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nim_Parser.StmtContext)
            else:
                return self.getTypedRuleContext(nim_Parser.StmtContext,i)


        def getRuleIndex(self):
            return nim_Parser.RULE_module

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterModule" ):
                listener.enterModule(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitModule" ):
                listener.exitModule(self)




    def module(self):

        localctx = nim_Parser.ModuleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 160, self.RULE_module)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
<<<<<<< HEAD
            self.state = 966 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 965
                self.stmt()
                self.state = 968 
=======
            self.state = 995 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 994
                self.stmt()
                self.state = 997 
>>>>>>> rev1
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << nim_Parser.OPEN_BRACE) | (1 << nim_Parser.TYPE) | (1 << nim_Parser.VARIABLE) | (1 << nim_Parser.LET) | (1 << nim_Parser.CONST) | (1 << nim_Parser.PROC) | (1 << nim_Parser.IF) | (1 << nim_Parser.FOR) | (1 << nim_Parser.TEMPLATE))) != 0) or ((((_la - 66)) & ~0x3f) == 0 and ((1 << (_la - 66)) & ((1 << (nim_Parser.WHEN - 66)) | (1 << (nim_Parser.IMPORT - 66)) | (1 << (nim_Parser.FROM - 66)) | (1 << (nim_Parser.BLOCK - 66)) | (1 << (nim_Parser.MACRO - 66)))) != 0)):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class StartContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def module(self):
            return self.getTypedRuleContext(nim_Parser.ModuleContext,0)


        def getRuleIndex(self):
            return nim_Parser.RULE_start

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStart" ):
                listener.enterStart(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStart" ):
                listener.exitStart(self)




    def start(self):

        localctx = nim_Parser.StartContext(self, self._ctx, self.state)
        self.enterRule(localctx, 162, self.RULE_start)
        try:
            self.enterOuterAlt(localctx, 1)
<<<<<<< HEAD
            self.state = 970
=======
            self.state = 999
>>>>>>> rev1
            self.module()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx



    def sempred(self, localctx:RuleContext, ruleIndex:int, predIndex:int):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[37] = self.primarySuffix_sempred
        self._predicates[39] = self.parBody_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception("No predicate with index:" + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def primarySuffix_sempred(self, localctx:PrimarySuffixContext, predIndex:int):
            if predIndex == 0:
                return self._input.LT(1).type in self.primarySuffixList
         

    def parBody_sempred(self, localctx:ParBodyContext, predIndex:int):
            if predIndex == 1:
                return self._input.LT(1).type in self.parKeyWList
         




