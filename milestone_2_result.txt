FOR  for
IDENTIFIER  value
IN  in
OP2  @
OPEN_BRACK  [
INT_LIT  3
COMMA  ,
INT_LIT  4
COMMA  ,
INT_LIT  5
CLOSE_BRACK  ]
COLON  :
INDENT      
IDENTIFIER  echo
OPEN_PAREN  (
IDENTIFIER  value
CLOSE_PAREN  )
DEDENT  
FOR  for
IDENTIFIER  i
COMMA  ,
IDENTIFIER  value
IN  in
OP2  @
OPEN_BRACK  [
INT_LIT  3
COMMA  ,
INT_LIT  4
COMMA  ,
INT_LIT  5
CLOSE_BRACK  ]
COLON  :
INDENT      
IDENTIFIER  echo
OPEN_PAREN  (
STR_LIT  "index: "
COMMA  ,
DOLLAR_SIGN  $
IDENTIFIER  i
COMMA  ,
STR_LIT  ", value:"
COMMA  ,
DOLLAR_SIGN  $
IDENTIFIER  value
CLOSE_PAREN  )
DEDENT  
FOR  for
IDENTIFIER  d
IN  in
IDENTIFIER  items
OPEN_PAREN  (
IDENTIFIER  data
CLOSE_PAREN  )
COLON  :
INDENT      
IDENTIFIER  action
OPEN_PAREN  (
IDENTIFIER  d
CLOSE_PAREN  )
DEDENT  
FOR  for
IDENTIFIER  bn
IN  in
IDENTIFIER  countdown
OPEN_PAREN  (
INT_LIT  99
COMMA  ,
INT_LIT  1
CLOSE_PAREN  )
COLON  :
INDENT      
VARIABLE  var
IDENTIFIER  cur
EQUALS  =
IDENTIFIER  GetBottleNumber
OPEN_PAREN  (
IDENTIFIER  bn
CLOSE_PAREN  )
IDENTIFIER  echo
OPEN_PAREN  (
IDENTIFIER  cur
COMMA  ,
STR_LIT  " on the wall, "
COMMA  ,
IDENTIFIER  cur
COMMA  ,
STR_LIT  "."
CLOSE_PAREN  )
IDENTIFIER  echo
OPEN_PAREN  (
STR_LIT  "Take one down and pass it around, "
COMMA  ,
IDENTIFIER  GetBottleNumber
OPEN_PAREN  (
IDENTIFIER  bn
OP8  -
INT_LIT  1
CLOSE_PAREN  )
COMMA  ,
STR_LIT  " on the wall.\n"
CLOSE_PAREN  )
DEDENT  
FOR  for
IDENTIFIER  i
IN  in
IDENTIFIER  toUpper
OPEN_PAREN  (
IDENTIFIER  s
CLOSE_PAREN  )
COLON  :
INDENT      
IF  if
IDENTIFIER  ord
OPEN_PAREN  (
IDENTIFIER  i
CLOSE_PAREN  )
OP5  >=
INT_LIT  65
OP4  and
IDENTIFIER  ord
OPEN_PAREN  (
IDENTIFIER  i
CLOSE_PAREN  )
OP5  <=
INT_LIT  90
COLON  :
INDENT      
IDENTIFIER  result
DOT  .
IDENTIFIER  add
OPEN_PAREN  (
IDENTIFIER  chr
OPEN_PAREN  (
OPEN_PAREN  (
IDENTIFIER  ord
OPEN_PAREN  (
IDENTIFIER  i
CLOSE_PAREN  )
OP8  -
INT_LIT  65
OP8  +
IDENTIFIER  k
CLOSE_PAREN  )
OP9  mod
INT_LIT  26
OP8  +
INT_LIT  65
CLOSE_PAREN  )
CLOSE_PAREN  )
DEDENT  
DEDENT  
FOR  for
IDENTIFIER  c
IN  in
IDENTIFIER  txt
COLON  :
INDENT      
CASE  case
IDENTIFIER  c
OF  of
CHAR_LIT  '['
COLON  :
INDENT      
IDENTIFIER  inc
OPEN_PAREN  (
IDENTIFIER  b
CLOSE_PAREN  )
DEDENT  
OF  of
CHAR_LIT  ']'
COLON  :
INDENT      
IDENTIFIER  dec
OPEN_PAREN  (
IDENTIFIER  b
CLOSE_PAREN  )
IF  if
IDENTIFIER  b
OP5  <
INT_LIT  0
COLON  :
RETURN  return
IDENTIFIER  false
DEDENT  
ELSE  else
COLON  :
DISCARD  discard
DEDENT  
FOR  for
IDENTIFIER  n
IN  in
INT_LIT  0
OP6  ..
INT_LIT  9
COLON  :
INDENT      
LET  let
IDENTIFIER  s
EQUALS  =
IDENTIFIER  gen
OPEN_PAREN  (
IDENTIFIER  n
CLOSE_PAREN  )
IDENTIFIER  echo
OPEN_PAREN  (
STR_LIT  "'"
COMMA  ,
IDENTIFIER  s
COMMA  ,
STR_LIT  "' is "
COMMA  ,
OPEN_PAREN  (
IF  if
IDENTIFIER  balanced
OPEN_PAREN  (
IDENTIFIER  s
CLOSE_PAREN  )
COLON  :
STR_LIT  "balanced"
ELSE  else
COLON  :
STR_LIT  "not balanced"
CLOSE_PAREN  )
CLOSE_PAREN  )
DEDENT  
FOR  for
IDENTIFIER  x
IN  in
IDENTIFIER  list
COLON  :
IDENTIFIER  s
DOT  .
IDENTIFIER  add
OPEN_PAREN  (
IDENTIFIER  x
CLOSE_PAREN  )
FOR  for
IDENTIFIER  i
COMMA  ,
IDENTIFIER  x
IN  in
IDENTIFIER  n
DOT  .
IDENTIFIER  list
COLON  :
INDENT      
IF  if
IDENTIFIER  i
OP5  >
INT_LIT  0
COLON  :
IDENTIFIER  result
DOT  .
IDENTIFIER  add
OPEN_PAREN  (
STR_LIT  ", "
CLOSE_PAREN  )
IDENTIFIER  result
DOT  .
IDENTIFIER  add
OPEN_PAREN  (
DOLLAR_SIGN  $
IDENTIFIER  x
CLOSE_PAREN  )
DEDENT  
FOR  for
IDENTIFIER  x
IN  in
IDENTIFIER  n
DOT  .
IDENTIFIER  list
COLON  :
INDENT      
IDENTIFIER  result
DOT  .
IDENTIFIER  add
OPEN_PAREN  (
IDENTIFIER  flatten
OPEN_PAREN  (
IDENTIFIER  x
CLOSE_PAREN  )
CLOSE_PAREN  )
DEDENT  
FOR  for
IDENTIFIER  line
IN  in
IDENTIFIER  stdin
DOT  .
IDENTIFIER  lines
COLON  :
INDENT      
FOR  for
IDENTIFIER  word
IN  in
IDENTIFIER  line
DOT  .
IDENTIFIER  split
OPEN_PAREN  (
STR_LIT  ", "
CLOSE_PAREN  )
COLON  :
INDENT      
IDENTIFIER  wordFrequencies
DOT  .
IDENTIFIER  inc
OPEN_PAREN  (
IDENTIFIER  word
CLOSE_PAREN  )