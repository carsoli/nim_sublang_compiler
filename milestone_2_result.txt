PROC  proc
IDENTIFIER  L
OPEN_BRACK  [
IDENTIFIER  T
CLOSE_BRACK  ]
OPEN_PAREN  (
IDENTIFIER  list
COLON  :
IDENTIFIER  varargs
OPEN_BRACK  [
IDENTIFIER  TreeList
OPEN_BRACK  [
IDENTIFIER  T
CLOSE_BRACK  ]
CLOSE_BRACK  ]
CLOSE_PAREN  )
COLON  :
IDENTIFIER  TreeList
OPEN_BRACK  [
IDENTIFIER  T
CLOSE_BRACK  ]
EQUALS  =
INDENT      
FOR  for
IDENTIFIER  x
IN  in
IDENTIFIER  list
COLON  :
IDENTIFIER  s
DOT  .
IDENTIFIER  add
OPEN_PAREN  (
IDENTIFIER  x
CLOSE_PAREN  )
IDENTIFIER  TreeList
OPEN_BRACK  [
IDENTIFIER  T
CLOSE_BRACK  ]
OPEN_PAREN  (
IDENTIFIER  isLeaf
COLON  :
IDENTIFIER  false
COMMA  ,
IDENTIFIER  list
COLON  :
IDENTIFIER  s
CLOSE_PAREN  )
DEDENT  
PROC  proc
IDENTIFIER  N
OPEN_BRACK  [
IDENTIFIER  T
CLOSE_BRACK  ]
OPEN_PAREN  (
IDENTIFIER  data
COLON  :
IDENTIFIER  T
CLOSE_PAREN  )
COLON  :
IDENTIFIER  TreeList
OPEN_BRACK  [
IDENTIFIER  T
CLOSE_BRACK  ]
EQUALS  =
INDENT      
IDENTIFIER  TreeList
OPEN_BRACK  [
IDENTIFIER  T
CLOSE_BRACK  ]
OPEN_PAREN  (
IDENTIFIER  isLeaf
COLON  :
IDENTIFIER  true
COMMA  ,
IDENTIFIER  data
COLON  :
IDENTIFIER  data
CLOSE_PAREN  )
DEDENT  
PROC  proc
SYM_HEADER  `
DOLLAR_SIGN  $
SYM_HEADER  `
OPEN_BRACK  [
IDENTIFIER  T
CLOSE_BRACK  ]
OPEN_PAREN  (
IDENTIFIER  n
COLON  :
IDENTIFIER  TreeList
OPEN_BRACK  [
IDENTIFIER  T
CLOSE_BRACK  ]
CLOSE_PAREN  )
COLON  :
IDENTIFIER  string
EQUALS  =
INDENT      
IF  if
IDENTIFIER  n
DOT  .
IDENTIFIER  isLeaf
COLON  :
IDENTIFIER  result
EQUALS  =
DOLLAR_SIGN  $
IDENTIFIER  n
DOT  .
IDENTIFIER  data
ELSE  else
COLON  :
INDENT      
IDENTIFIER  result
EQUALS  =
STR_LIT  "["
FOR  for
IDENTIFIER  i
COMMA  ,
IDENTIFIER  x
IN  in
IDENTIFIER  n
DOT  .
IDENTIFIER  list
COLON  :
INDENT      
IF  if
IDENTIFIER  i
OP5  >
INT_LIT  0
COLON  :
IDENTIFIER  result
DOT  .
IDENTIFIER  add
STR_LIT  ", "
IDENTIFIER  result
DOT  .
IDENTIFIER  add
OPEN_PAREN  (
DOLLAR_SIGN  $
IDENTIFIER  x
CLOSE_PAREN  )
DEDENT  
IDENTIFIER  result
DOT  .
IDENTIFIER  add
OPEN_PAREN  (
STR_LIT  "]"
CLOSE_PAREN  )
DEDENT  
DEDENT  
PROC  proc
IDENTIFIER  flatten
OPEN_BRACK  [
IDENTIFIER  T
CLOSE_BRACK  ]
OPEN_PAREN  (
IDENTIFIER  n
COLON  :
IDENTIFIER  TreeList
OPEN_BRACK  [
IDENTIFIER  T
CLOSE_BRACK  ]
CLOSE_PAREN  )
COLON  :
IDENTIFIER  seq
OPEN_BRACK  [
IDENTIFIER  T
CLOSE_BRACK  ]
EQUALS  =
INDENT      
IF  if
IDENTIFIER  n
DOT  .
IDENTIFIER  isLeaf
COLON  :
IDENTIFIER  result
EQUALS  =
OP2  @
OPEN_BRACK  [
IDENTIFIER  n
DOT  .
IDENTIFIER  data
CLOSE_BRACK  ]
ELSE  else
COLON  :
INDENT      
IDENTIFIER  result
EQUALS  =
OP2  @
OPEN_BRACK  [
CLOSE_BRACK  ]
FOR  for
IDENTIFIER  x
IN  in
IDENTIFIER  n
DOT  .
IDENTIFIER  list
COLON  :
INDENT      
IDENTIFIER  result
DOT  .
IDENTIFIER  add
OPEN_PAREN  (
IDENTIFIER  flatten
OPEN_PAREN  (
IDENTIFIER  x
CLOSE_PAREN  )
CLOSE_PAREN  )
DEDENT  
DEDENT  
DEDENT  
PROC  proc
IDENTIFIER  gen
OPEN_PAREN  (
IDENTIFIER  n
COLON  :
IDENTIFIER  int
CLOSE_PAREN  )
COLON  :
IDENTIFIER  string
EQUALS  =
INDENT      
IDENTIFIER  result
EQUALS  =
STR_LIT  "[]"
DOT  .
IDENTIFIER  repeat
OPEN_PAREN  (
IDENTIFIER  n
CLOSE_PAREN  )
IDENTIFIER  shuffle
OPEN_PAREN  (
IDENTIFIER  result
CLOSE_PAREN  )
DEDENT  
PROC  proc
IDENTIFIER  balanced
OPEN_PAREN  (
IDENTIFIER  txt
COLON  :
IDENTIFIER  string
CLOSE_PAREN  )
COLON  :
IDENTIFIER  bool
EQUALS  =
INDENT      
FOR  for
IDENTIFIER  c
IN  in
IDENTIFIER  txt
COLON  :
INDENT      
CASE  case
IDENTIFIER  c
OF  of
CHAR_LIT  '['
COLON  :
INDENT      
IDENTIFIER  inc
OPEN_PAREN  (
IDENTIFIER  b
CLOSE_PAREN  )
DEDENT  
OF  of
CHAR_LIT  ']'
COLON  :
INDENT      
IDENTIFIER  dec
OPEN_PAREN  (
IDENTIFIER  b
CLOSE_PAREN  )
IF  if
IDENTIFIER  b
OP5  <
INT_LIT  0
COLON  :
RETURN  return
IDENTIFIER  false
DEDENT  
ELSE  else
COLON  :
DISCARD  discard
DEDENT  
IDENTIFIER  b
OP5  ==
INT_LIT  0
DEDENT  
PROC  proc
IDENTIFIER  caesar
OPEN_PAREN  (
IDENTIFIER  s
COLON  :
IDENTIFIER  string
COMMA  ,
IDENTIFIER  k
COLON  :
IDENTIFIER  int
COMMA  ,
IDENTIFIER  decode
EQUALS  =
IDENTIFIER  false
CLOSE_PAREN  )
COLON  :
IDENTIFIER  string
EQUALS  =
INDENT      
IDENTIFIER  result
EQUALS  =
STR_LIT  ""
FOR  for
IDENTIFIER  i
IN  in
IDENTIFIER  toUpper
OPEN_PAREN  (
IDENTIFIER  s
CLOSE_PAREN  )
COLON  :
INDENT      
IF  if
IDENTIFIER  ord
OPEN_PAREN  (
IDENTIFIER  i
CLOSE_PAREN  )
OP5  >=
INT_LIT  65
OP4  and
IDENTIFIER  ord
OPEN_PAREN  (
IDENTIFIER  i
CLOSE_PAREN  )
OP5  <=
INT_LIT  90
COLON  :
INDENT      
IDENTIFIER  result
DOT  .
IDENTIFIER  add
OPEN_PAREN  (
IDENTIFIER  chr
OPEN_PAREN  (
OPEN_PAREN  (
IDENTIFIER  ord
OPEN_PAREN  (
IDENTIFIER  i
CLOSE_PAREN  )
OP8  -
INT_LIT  65
OP8  +
IDENTIFIER  k
CLOSE_PAREN  )
OP9  mod
INT_LIT  26
OP8  +
INT_LIT  65
CLOSE_PAREN  )
CLOSE_PAREN  )
DEDENT  
DEDENT  
DEDENT  
PROC  proc
IDENTIFIER  quickSort
OPEN_BRACK  [
IDENTIFIER  T
CLOSE_BRACK  ]
OPEN_PAREN  (
IDENTIFIER  a
COLON  :
VARIABLE  var
IDENTIFIER  openarray
OPEN_BRACK  [
IDENTIFIER  T
CLOSE_BRACK  ]
COMMA  ,
IDENTIFIER  inl
EQUALS  =
INT_LIT  0
COMMA  ,
IDENTIFIER  inr
EQUALS  =
OP8  -
INT_LIT  1
CLOSE_PAREN  )
EQUALS  =
INDENT      
LET  let
IDENTIFIER  n
EQUALS  =
IDENTIFIER  r
OP8  -
IDENTIFIER  l
OP8  +
INT_LIT  1
IF  if
IDENTIFIER  n
OP5  <
INT_LIT  2
COLON  :
RETURN  return
LET  let
IDENTIFIER  p
EQUALS  =
IDENTIFIER  a
OPEN_BRACK  [
IDENTIFIER  l
OP8  +
INT_LIT  3
OP9  *
IDENTIFIER  n
OP9  div
INT_LIT  4
CLOSE_BRACK  ]
IF  if
IDENTIFIER  a
OPEN_BRACK  [
IDENTIFIER  l
CLOSE_BRACK  ]
OP5  <
IDENTIFIER  p
COLON  :
INDENT      
IDENTIFIER  inc
OPEN_PAREN  (
IDENTIFIER  l
CLOSE_PAREN  )
CONTINUE  continue
DEDENT  
IF  if
IDENTIFIER  a
OPEN_BRACK  [
IDENTIFIER  r
CLOSE_BRACK  ]
OP5  >
IDENTIFIER  p
COLON  :
INDENT      
IDENTIFIER  dec
OPEN_PAREN  (
IDENTIFIER  r
CLOSE_PAREN  )
CONTINUE  continue
DEDENT  
IF  if
IDENTIFIER  l
OP5  <=
IDENTIFIER  r
COLON  :
INDENT      
IDENTIFIER  swap
OPEN_PAREN  (
IDENTIFIER  a
OPEN_BRACK  [
IDENTIFIER  l
CLOSE_BRACK  ]
COMMA  ,
IDENTIFIER  a
OPEN_BRACK  [
IDENTIFIER  r
CLOSE_BRACK  ]
CLOSE_PAREN  )
IDENTIFIER  inc
OPEN_PAREN  (
IDENTIFIER  l
CLOSE_PAREN  )
IDENTIFIER  dec
OPEN_PAREN  (
IDENTIFIER  r
CLOSE_PAREN  )
DEDENT  
IDENTIFIER  quickSort
OPEN_PAREN  (
IDENTIFIER  a
COMMA  ,
IDENTIFIER  inl
COMMA  ,
IDENTIFIER  r
CLOSE_PAREN  )
IDENTIFIER  quickSort
OPEN_PAREN  (
IDENTIFIER  a
COMMA  ,
IDENTIFIER  l
COMMA  ,
IDENTIFIER  inr
CLOSE_PAREN  )
DEDENT  
PROC  proc
IDENTIFIER  GetBottleNumber
OPEN_PAREN  (
IDENTIFIER  n
COLON  :
IDENTIFIER  int
CLOSE_PAREN  )
COLON  :
IDENTIFIER  string
EQUALS  =
INDENT      
IF  if
IDENTIFIER  n
OP5  ==
INT_LIT  0
COLON  :
INDENT      
IDENTIFIER  bs
EQUALS  =
STR_LIT  "No more bottles"
DEDENT  
ELIF  elif
IDENTIFIER  n
OP5  ==
INT_LIT  1
COLON  :
INDENT      
IDENTIFIER  bs
EQUALS  =
STR_LIT  "1 bottle"
DEDENT  
ELSE  else
COLON  :
INDENT      
IDENTIFIER  bs
EQUALS  =
DOLLAR_SIGN  $
IDENTIFIER  n
OP7  &
STR_LIT  " bottles"
DEDENT  
RETURN  return
IDENTIFIER  bs
OP7  &
STR_LIT  " of beer"
DEDENT  
PROC  proc
IDENTIFIER  fibonacci
OPEN_PAREN  (
IDENTIFIER  n
COLON  :
IDENTIFIER  int
CLOSE_PAREN  )
COLON  :
IDENTIFIER  int
EQUALS  =
INDENT      
IF  if
IDENTIFIER  n
OP5  <
INT_LIT  2
COLON  :
INDENT      
IDENTIFIER  result
EQUALS  =
IDENTIFIER  n
DEDENT  
ELSE  else
COLON  :
INDENT      
IDENTIFIER  result
EQUALS  =
IDENTIFIER  fibonacci
OPEN_PAREN  (
IDENTIFIER  n
OP8  -
INT_LIT  1
CLOSE_PAREN  )
OP8  +
OPEN_PAREN  (
IDENTIFIER  n
OP8  -
INT_LIT  2
CLOSE_PAREN  )
DOT  .
IDENTIFIER  fibonacci
DEDENT  
DEDENT  
PROC  proc
IDENTIFIER  echoItem
OPEN_PAREN  (
IDENTIFIER  x
COLON  :
IDENTIFIER  string
CLOSE_PAREN  )
EQUALS  =
IMPORT  import
IDENTIFIER  x
PROC  proc
IDENTIFIER  forEach
OPEN_PAREN  (
IDENTIFIER  action
COLON  :
PROC  proc
OPEN_PAREN  (
IDENTIFIER  x
COLON  :
IDENTIFIER  string
CLOSE_PAREN  )
CLOSE_PAREN  )
EQUALS  =
INDENT      
FOR  for
IDENTIFIER  d
IN  in
IDENTIFIER  items
OPEN_PAREN  (
IDENTIFIER  data
CLOSE_PAREN  )
COLON  :
INDENT      
IDENTIFIER  action
OPEN_PAREN  (
IDENTIFIER  d
CLOSE_PAREN  )
DEDENT  
DEDENT  
PROC  proc
IDENTIFIER  yes
OPEN_PAREN  (
IDENTIFIER  question
COLON  :
IDENTIFIER  string
CLOSE_PAREN  )
COLON  :
IDENTIFIER  bool
EQUALS  =
INDENT      
IDENTIFIER  echo
OPEN_PAREN  (
IDENTIFIER  question
COMMA  ,
STR_LIT  " (y/n)"
CLOSE_PAREN  )
CASE  case
IDENTIFIER  readline
OF  of
STR_LIT  "y"
COMMA  ,
STR_LIT  "Y"
COMMA  ,
STR_LIT  "yes"
COMMA  ,
STR_LIT  "Yes"
COLON  :
RETURN  return
IDENTIFIER  true
OF  of
STR_LIT  "n"
COMMA  ,
STR_LIT  "N"
COMMA  ,
STR_LIT  "no"
COMMA  ,
STR_LIT  "No"
COLON  :
RETURN  return
IDENTIFIER  false
ELSE  else
COLON  :
IDENTIFIER  echo
OPEN_PAREN  (
STR_LIT  "Please be clear: yes or no"
CLOSE_PAREN  )