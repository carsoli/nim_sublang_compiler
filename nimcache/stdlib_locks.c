/* Generated by Nim Compiler v0.17.2 */
/*   (c) 2018 Andreas Rumpf */
/* The generated code is subject to the original license. */
/* Compiled for: Linux, amd64, gcc */
/* Command for C compiler:
   gcc -c  -w  -I/usr/lib/nim -o '/home/carol/Desktop/Semester 10/Core/Compilers Lab/M2/NumberTwo/nimcache/stdlib_locks.o' '/home/carol/Desktop/Semester 10/Core/Compilers Lab/M2/NumberTwo/nimcache/stdlib_locks.c' */
#define NIM_NEW_MANGLING_RULES
#define NIM_INTBITS 64

#include "nimbase.h"
#include <pthread.h>
#include <sys/types.h>
                          #include <pthread.h>
#undef LANGUAGE_C
#undef MIPSEB
#undef MIPSEL
#undef PPC
#undef R3000
#undef R4000
#undef i386
#undef linux
#undef mips
#undef near
#undef powerpc
#undef unix
typedef long tyArray_xDUyu9aScDpt0JZLU6q9aEZQ[5];
typedef long long tyArray_xLtLuIT9aUkeKRzzMNC75Vw[6];
static N_INLINE(void, initLock_NyibMGWEvLI6dmuAjxN9brAlocks)(pthread_mutex_t* lock);
static N_INLINE(void, deinitLock_NyibMGWEvLI6dmuAjxN9brA_2locks)(pthread_mutex_t* lock);
N_NIMCALL(NIM_BOOL, tryAcquire_9bPySkj6HXfWNB4ampKcs9bg)(pthread_mutex_t* lock);
N_NIMCALL(void, acquire_c9cbvs4ShkxrwmQmnY63PGA)(pthread_mutex_t* lock);
N_NIMCALL(void, release_c9cbvs4ShkxrwmQmnY63PGA_2)(pthread_mutex_t* lock);
static N_INLINE(void, initCond_cET5UPJTPSiflmV7IZS68Alocks)(pthread_cond_t* cond);
static N_INLINE(void, deinitCond_cET5UPJTPSiflmV7IZS68A_2locks)(pthread_cond_t* cond);
static N_INLINE(void, wait_1jWf7NqlMVz9aQJMRL9bTm9bQlocks)(pthread_cond_t* cond, pthread_mutex_t* lock);
static N_INLINE(void, signal_cET5UPJTPSiflmV7IZS68A_3locks)(pthread_cond_t* cond);
static N_INLINE(void, nimFrame)(TFrame* s);
N_NOINLINE(void, stackOverflow_II46IjNZztN9bmbxUD8dt8g)(void);
static N_INLINE(void, popFrame)(void);
extern TFrame* framePtr_HRfVMH3jYeBJz6Q6X9b6Ptw;

static N_INLINE(void, initLock_NyibMGWEvLI6dmuAjxN9brAlocks)(pthread_mutex_t* lock) {
	pthread_mutex_init(lock, NIM_NIL);
}

static N_INLINE(void, deinitLock_NyibMGWEvLI6dmuAjxN9brA_2locks)(pthread_mutex_t* lock) {
	pthread_mutex_destroy(lock);
}

N_NIMCALL(NIM_BOOL, tryAcquire_9bPySkj6HXfWNB4ampKcs9bg)(pthread_mutex_t* lock) {
	NIM_BOOL result;
	int T1_;
	result = (NIM_BOOL)0;
	T1_ = (int)0;
	T1_ = pthread_mutex_trylock(lock);
	result = (T1_ == ((NI32) 0));
	return result;
}

N_NIMCALL(void, acquire_c9cbvs4ShkxrwmQmnY63PGA)(pthread_mutex_t* lock) {
	pthread_mutex_lock(lock);
}

N_NIMCALL(void, release_c9cbvs4ShkxrwmQmnY63PGA_2)(pthread_mutex_t* lock) {
	pthread_mutex_unlock(lock);
}

static N_INLINE(void, initCond_cET5UPJTPSiflmV7IZS68Alocks)(pthread_cond_t* cond) {
	pthread_cond_init(cond, NIM_NIL);
}

static N_INLINE(void, deinitCond_cET5UPJTPSiflmV7IZS68A_2locks)(pthread_cond_t* cond) {
	pthread_cond_destroy(cond);
}

static N_INLINE(void, wait_1jWf7NqlMVz9aQJMRL9bTm9bQlocks)(pthread_cond_t* cond, pthread_mutex_t* lock) {
	pthread_cond_wait(cond, lock);
}

static N_INLINE(void, signal_cET5UPJTPSiflmV7IZS68A_3locks)(pthread_cond_t* cond) {
	pthread_cond_signal(cond);
}

static N_INLINE(void, nimFrame)(TFrame* s) {
	NI T1_;
	T1_ = (NI)0;
	{
		if (!(framePtr_HRfVMH3jYeBJz6Q6X9b6Ptw == NIM_NIL)) goto LA4_;
		T1_ = ((NI) 0);
	}
	goto LA2_;
	LA4_: ;
	{
		T1_ = ((NI) ((NI16)((*framePtr_HRfVMH3jYeBJz6Q6X9b6Ptw).calldepth + ((NI16) 1))));
	}
	LA2_: ;
	(*s).calldepth = ((NI16) (T1_));
	(*s).prev = framePtr_HRfVMH3jYeBJz6Q6X9b6Ptw;
	framePtr_HRfVMH3jYeBJz6Q6X9b6Ptw = s;
	{
		if (!((*s).calldepth == ((NI16) 2000))) goto LA9_;
		stackOverflow_II46IjNZztN9bmbxUD8dt8g();
	}
	LA9_: ;
}

static N_INLINE(void, popFrame)(void) {
	framePtr_HRfVMH3jYeBJz6Q6X9b6Ptw = (*framePtr_HRfVMH3jYeBJz6Q6X9b6Ptw).prev;
}
NIM_EXTERNC N_NOINLINE(void, stdlib_locksInit000)(void) {
	nimfr_("locks", "locks.nim");
	popFrame();
}

NIM_EXTERNC N_NOINLINE(void, stdlib_locksDatInit000)(void) {
}

